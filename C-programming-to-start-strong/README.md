# 필기

## Chapter 01 C 프로그래밍 입문

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  printf("Hello, World!\n");
  return EXIT_SUCCESS;
}
```

여기서 `#include <stdio.h>`은 전처리기(preprocesser)입니다. 처리는 컴파일 전입니다. `h`는 해더를 의미합니다.

C 언어가 라이브러리 코드를 가져오는 방법입니다. 컴파일 전에 필요한 부분을 가져와 전에 처리하고 기계어로 변환합니다.

프로그래밍은 문법적으로 맞는 것이 전부가 아닙니다. 논리적으로 올바르게 되어 있어야 합니다.

C 언어는 절차지향 프로그래밍 언어로 분류되었있습니다.

프로그램을 실행하면 `main` 함수를 실행하게 됩니다. `int`를 반환해야 합니다. 이 반환과 함께 프로그램은 종료합니다. 즉 `main`에서 시작해서 `main`에서 끝이 납니다.

함수의 목적은 계산과 동작 둘 중 하나 이상의 목적을 가질 수 있습니다.

매개변수와 인자는 컨택스트 구분을 위해서 올바르게 사용해야 합니다. 인자는 호출자가 넣은 값이라 호출자의 컨텍스트에서 논할 때입니다. 매개변수는 함수 정의자의 관점에서 논할 때입니다. 하지만 호출을 해서 넣은 값은 함수 정의 내에서 매개변수이기 때문에 본질적으로는 같습니다.

C 언어는 빌드 즉 컴파일 과정이 있습니다. `c` 확장자는 문서에 불과합니다. 소스코드입니다. 이 소스코드 파일을 목적파일 `obj`를 만듭니다. 이것은 실행파일이 실행할 부품이라고 비유할 수 있습니다. 이 부품들을 조립하는 과정을 보고 링크라고 합니다. 지금은 neovim 환경에서 커맨드라인으로 컴파일하고 있어서 잘 모릅니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  printf("010-1234-5678\n");
  printf("arch-spatula\n");
  return EXIT_SUCCESS;
}
```

ㅇㅇ

## Chapter 02 자료형

컴퓨터에게 모든 것은 본질적으로 수입니다. `0`과 `1` 이 이진수를 옵트코드와 오퍼랜드로 표현하는 어쎔블리에서 현재 하이레벨 언어로 여러 계층 추상화 되어 있는데 본질은 항상 수입니다.

기계는 그져 수를 처리할 수밖에 없습니다.

상수와 변수는 자료의 성격을 의미합니다.

정수와 실수는 자료의 형식을 의미합니다.

자료형은 자료의 구조를 나타내는 형식에 불과합니다.

상수는 2가지가 있습니다. 리터럴과 심볼릭입니다. 주로 변수 선언할 때 상수로 선언할 때는 형한정어를 사용한다고 합니다. 다른 심볼릭은 전처리기에서 제공하는 상수들입니다. 리터럴 상수는 상수 값들입니다.

```c
const int nMax = 100;
```

위는 형한정어를 사용해 정의한 상수입니다.

상수는 값 혹은 주소로 식별합니다. 문자열의 경우 주소로 식별하고 문자자체는 값으로 식별합니다.

변수는 적게 사용할수록 좋습니다. 프로그램을 작성하는 관점과 공간복잡성 관점 모두 해당합니다.

변수는 메모리로 구현됩니다. 변수를 선언하면 그 변수는 어느 메모리주소로 접근할 수 있게 해줍니다.

C 언어의 자료형은 크게 정수형, 실수형, 유도형, 함수형 정도입니다. `char`는 영문자, `int`는 정수, `double`은 실수를 다루기 위해 있습니다. 이정도부터 알아야 합니다.

<!-- @todo: 직접 표 작성하기 -->

컴퓨터는 덧셈과 뺄셈을 구현할 때 하드웨어 구조를 재사용합니다. 덧셈으로 숫자를 더하고 뺄셈도 덧셈 동작방식으로 구현합니다. 컴퓨터는 보수를 더하는 것으로 뺄셈을 구현합니다. 보수란 A라는 숫자가 B가 되기 위해 필요한 수입니다.

$$
\begin{align}

9 - 6 = 3

\end{align}
$$

이것은 일반적인 뺄셈법입니다.

$$
\begin{align}

9 + 3 = 13 = 13 - 10 = 3

\end{align}
$$

컴퓨터는 6이 10이 되기 위해 필요한 4(보수)를 더하는 방법으로 뺄셈을 구현합니다. 그리고 자릿수를 초과한 부분은 사라집니다. 그렇게 3을 구합니다. 즉 오버플로우 언더플로우를 활용합니다.

이것은 이진법으로도 동일하게 적용할 수 있습니다.

1의 보수는 모든 비트를 뒤집는다고 생각하면 됩니다. 2의 보수는 거기에 1을 더하면 됩니다.

$$
\begin{align}

00000001_{(2)}

\end{align}
$$

1에서 시작합니다.

$$
\begin{align}

11111110_{(2)}

\end{align}
$$

숫자 1에 대한 1의 보수입니다.

$$
\begin{align}

11111111_{(2)}

\end{align}
$$

숫자 1에 대한 2의 보수입니다.

여기 있는 2의 보수와 1을 더하면 -1을 빼는 것과 동일한 결과를 같습니다. 그리고 회로판은 덧셈 회로판만 활용하게 됩니다.

절댓값을 더하고 자리올림을 무시함으로 결과적으로 뺄셈을 구현합니다.

부호비트, 자료비트, 표현 범위는 직관적입니다.

부호비트는 MSB(최상위 비트, most significant bit) 보통 가장 왼쪽에 표시합니다. 그리고 남는 부분이 자료비트입니다. 0은 양수 1은 음수를 표현할 수 있게 됩니다.

예를 들어 8비트에 부호 비트를 포함하면 -128($-1 \cdot 2^{7}$)부터 127(2^{7} - 1)까지 표현할 수 있는 범위가 됩니다. 만약에 부호가 없다면 즉 `unsigned`라면 0부터 255($2^{8}-1$)까지 표현할 수 있게 됩니다. (255까지면 보통 컬러를 표현할 때 자주 봤을 것입니다. 컬러는 금융대출처럼 음수를 표현할 필요가 없습니다.)

표현범위를 초과하면 숫자 잘림 현상이 발생해 계산이 틀릴 가능성이 높습니다. 그래서 큰 수를 다룰 때는 주의해야 합니다.

```c
자료형 변수이름 = 초깃값;
int nDate = 10;
```

위 형태를 기억하기 바랍니다. 변수는 식별자입니다.

변수선언에 규칙이 있습니다.

- 영문 대소문자, `_`, 숫자로 만들어야 합니다.
- 첫글자가 숫자가 될 수 없습니다.
- 중간에 공백을 갖을 수 없습니다.
- 예약어로 변수를 사용할 수 없습니다.

| 예약어   | 설명                              | 예시 코드                                    |
| -------- | --------------------------------- | -------------------------------------------- |
| auto     | 지역 변수를 자동으로 저장         | `auto int num = 10;`                         |
| break    | switch 문이나 반복문을 종료       | `break;`                                     |
| case     | switch 문에서 조건을 지정         | `switch(num) { case 1: }`                    |
| char     | 문자 데이터 타입                  | `char ch = 'A';`                             |
| const    | 상수를 정의                       | `const int MAX = 100;`                       |
| continue | 반복문의 현재 반복을 건너뛰기     | `continue;`                                  |
| default  | switch 문에서 기본 동작 정의      | `default: break;`                            |
| do       | do-while 반복문 시작              | `do { } while (condition);`                  |
| double   | 더블형 실수 데이터 타입           | `double pi = 3.14159;`                       |
| else     | if 문의 다른 조건 정의            | `if (condition) { } else { }`                |
| enum     | 열거형 타입 정의                  | `enum Day { MON, TUE };`                     |
| extern   | 외부 변수 또는 함수 선언          | `extern int count;`                          |
| float    | 실수 데이터 타입                  | `float weight = 65.5;`                       |
| for      | 반복문 시작                       | `for (i = 0; i < 10; i++) { }`               |
| goto     | 레이블로 점프                     | `goto label;`                                |
| if       | 조건문 시작                       | `if (condition) { }`                         |
| int      | 정수 데이터 타입                  | `int age = 20;`                              |
| long     | 긴 정수 데이터 타입               | `long population = 5000000;`                 |
| register | 빠른 메모리 저장을 위한 변수 선언 | `register int count;`                        |
| return   | 함수 종료 및 반환                 | `return 0;`                                  |
| short    | 짧은 정수 데이터 타입             | `short num = 5;`                             |
| signed   | 부호 있는 데이터 타입 지정        | `signed int value = -10;`                    |
| sizeof   | 데이터 타입 또는 변수의 크기 반환 | `int size = sizeof(int);`                    |
| static   | 지역 변수를 정적으로 저장         | `static int count = 0;`                      |
| struct   | 구조체 타입 정의                  | `struct Person { char name[20]; int age; };` |
| switch   | 다중 분기 선택문 시작             | `switch(expression) { }`                     |
| typedef  | 사용자 정의 데이터 타입 정의      | `typedef int BOOL;`                          |
| union    | 공용체 타입 정의                  | `union Data { int i; float f; };`            |
| unsigned | 부호 없는 데이터 타입 지정        | `unsigned int score = 100;`                  |
| void     | 함수가 반환하지 않는 타입 지정    | `void func() { }`                            |
| volatile | 최적화 방지를 위한 변수 선언      | `volatile int flag;`                         |
| while    | 반복문 시작                       | `while (condition) { }`                      |

가독성 차원에서 준수해야 할 것들이 있습니다.

- 너무 긴 변수명은 안 좋습니다.
- 변수의 용도에 맞게 명명해야 합니다. 좌표를 `a`, `b`, `c`, 보단 `x`, `y`, `z`가 더 적절합니다.
- 의미없는 이름은 남용하지 않습니다.

컴퓨터에게 문자도 숫자입니다. 컴퓨터는 특정 숫자를 특정 문자로 취급하고 이것을 보고 부호체계라고 부릅니다.

ASCII는 현재 표준입니다. 과거에는 컴퓨터 제조사마다 부호체계가 다 달랐습니다.

7비트 코드 체계였습니다. 거기에 확장 비트 1개를 더해 8비트로 영어 글자 1개를 저장하고 표현했습니다.

내부적으로 컴퓨터에게 문자는 정수에 불과합니다. 문자는 C 언어에서 `char` 타입이고 부호 있는 8비트입니다.

```c
char ch  = 'A';
```

이것은 변수 선언입니다. 메모리 공간 8비트를 확보하고 선언해야 합니다.

`short`, `wchar_t`

`short`은 부호있는 16비트 정수입니다. `unsigned short`으로 선언해서 부호 없이 $0 ~ 2^{16}-1$ 형식으로 표현할 수 없습니다.

`wchar_t`은 문자하나를 저장하는 자료형입니다. 윈도우에서는 `short` 형과 같은 16비트입니다.

```c
short s = 1234;   // 정수는 보편적으로 int로 표현하지만 상수 표현할 때는 int, short을 구분하지 않음
wchar_t w = L'A'; // 문자 상수랑 다르게 앞에 L을 붙여야함
```

구분이 필요 없는 이유는 메모리의 크기와 값만 알면 항상 똑같이 처리하기 때문입니다.

`int`, `long`

`int`는 32비트 정수형입니다. 다루는 비즈니스 및 기술 도메인이 특수하지 않다면 가장 자주 사용하는 자료형입니다. 상수의 경우 접사도 없고 32비트 범위 내면 그냥 `int`입니다.

```c
#include <stdlib.h>
#include <wchar.h>

int main(void) {
	char ch = 'A';
	wchar_t wch = L'A';
	short sData = 10;
	int nData = 10;
	long lData = 10L;
	long int lnData = 10L;
	long long int llnData = 10LL;

	unsigned char byNewData = 0;
	unsigned short sNewData = 65535U;
	unsigned int uNewData = 1U;
	unsigned long int ulNewData = 1UL;
	unsigned long long int ullNewData = 1ULL;

	return EXIT_SUCCESS;
}
```

실수 자료형은 부동 소수점을 표현해야 합니다.

컴퓨터가 정수를 표현하고 비트 단위크기차이는 있어도 해석방법은 같고 숫자는 명확합니다. 정수와 정수 사이 실수는 애매합니다.

실수는 수학적으로 그 사이에 무한하게 존재할 수 있습니다. 이 무한한 표현을 메모리의 유한한 공간에 정확히 표현하기는 어렵습니다. 여기부터 컴퓨터는 일정 수준의 부동 소수점 오차를 전제로 다양한 표현을 합니다. 구체적인 내용 모두 언제가는 알기는 해야 합니다.

하지만 가장 중요한 것은 부동 소수 과련 오차입니다.

컴퓨터는 일정 수준까지만 표현을 확정하고 더 정밀한 숫자는 범위상 가까운 수로 인식하기로 했습니다.

과거에는 컴퓨터 제조사마다 부동 소수점 처리를 각각의 방식으로 했습니다. IEEE 754 스펙이 부동 소수점 표준안입니다.

소수점 표현을 위해 32비트 단정도, 64비트 배정도 및 79비트(80비트 구현) 확장 배정도 형식에 대해 표준을 규정했습니다.

| 크기    | 자료형        | 표현 범위                                                                    |
| ------- | ------------- | ---------------------------------------------------------------------------- |
| 32비트  | `float`       | $1.17 \cdot 10^{-38} ~ 3.4 \cdot 10^{38} $ 유한 자릿수 소수점 이하 6자리     |
| 64비트  | `double`      | $2.22 \cdot 10^{-308} ~ 1.79 \cdot 10^{308} $ 유한 자릿수 소수점 이하 15자리 |
| 128비트 | `long double` | `double` 이상                                                                |

`float`형은 32비트 단정도형입니다. 여기서 단정도라고 하는데 그냥 single을 의미합니다. 소수점은 6번째자리까지 표현합니다. 7번째부터 부정확한 숫자로 활용하지 말아야 합니다.

부호 비트 1비트 + 지수부 8비트 + 기수부 23비트 = 32비트

- 실제 실수형 계산작없을 많이 해야 하면 `double`형을 사용할 것을 권장합니다.
- 실수형은 부호 표기를 무조건 포함하기 때문에 앞에 U가 붙지 않습니다.
- f를 붙이지 않으면 double 형이고 상수로 취급됩니다.

`double`은 일반적인 실수를 의미합니다. 하지만 여전히 한계가 있습니다. 15번째 자리까지 유효합니다. 또 자동 상수로 형변환을 하는데 정확성 때문입니다.

부호 비트 1비트 + 지수부 11비트 + 기수부 52비트 = 64비트

```c
// DoubleRange.c
#include <float.h>
#include <stdio.h>
#include <stdlib.h>

int main(void) {

	double dData = 123.456;

	printf("%f\n", dData);
	printf("%E - %E\n", DBL_MIN, DBL_MAX);

  return EXIT_SUCCESS;
}

// 123.456000
// 2.225074E-308 - 1.797693E+308
```

첫번째 출력은 `float`로 취급해서 소수 6번째 자리까지 보여줍니다.

또 `double`의 최대 최소 범위를 보여주고 있습니다.

C 언어를 배울 사람들이 배웠다고 착각하는 것 중 하나가 문자열입니다. 문자열은 정확히 문자(배)열입니다. 여러 문자 인스턴스의 집합입니다. 문제는 본질이 배열인데 다른 자료형처럼 인스턴스가 1개라는 착각입니다. 가변길이 자료형이라 다른 자료형보다 고려할 것이 많습니다.

배열은 1개의 메모리상 존재하는 인스터가 아니라 여러 메모리 인스턴스를 하나로 묶어둔 것입니다. 개별 인스턴스는 이름이 아니라 주소에 이름이 부여된 것입니다.

```c
#include <stdlib.h>

int main(void) {

  char ch1 = 'A', ch2 = 'B', ch3 = 'C';
  char szData[4] = {'A', 'B', 'C'};
  char szNewData[4] = {"ABC"};

  return EXIT_SUCCESS;
}
```

`ch1`, `ch2`, `ch3`는 3개의 개별문자 상수입니다.

`szData`는 4개의 문자를 담은 배열입니다. 인스턴스 4개를 갖습니다. 또 초깃값(`A`, `B`, `C`)도 명시하고 있습니다. 명시하지 않으면 0이 됩니다.

`szData`는 `szNewData`랑 의미상 같습니다. 물론 메모리 주소는 다릅니다.

왜 4로 선언했는데 3개만 활용하는가? 둘다 문자열 끝에 null 문자(`\0`)가 들어갑니다. 즉 null 문자를 포함해야 합니다. 그래야 문제열이 끝났음을 알려 줄 수 있습니다.

프로그램 소스코드는 그자체로 문서입니다. 사람이 읽기 때문에 가독성이 중요합니다. 가독성 좋은 코드야 말로 진정한 기본기입니다. 또 이름짓기와 주석이야 말로 기본 중 기본입니다.

이름은 다르게 부르면 식별자라고 부르기도 합니다. 변수는 코드의 식별자 ID의 역할을 합니다. 이름으로 목적을 알수 있게 작성해야 합니다. 이름 짓기를 할 때 변수의 목적을 다시 생각하면서 작성하도록 합니다.

주석은 실행하지 않습니다. 개발자의 메모에 불과합니다. 하지만 상당히 중요합니다. 코드만으로 설명이 가능하기는 해야 하지만 그렇지 못한 경우도 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

/*
 * 이 구간의 코드는 모두 주석
 */

int main(void) {

	// 결과를 저장하는 변수
	int nResult = 10;
	char ch = 'A'; // 사용자 입력

	// printf("Hello, World!\n");

	return EXIT_SUCCESS;
}
```

소스코드는 회사 문서입니다. 가독성을 위한 노력이 중요합니다.

1. 변수는 프로그램이 실행하면서 값이 바뀔 수 있는 값을 의미
2. 자료형은 데이터를 표현하는 형식
3. 자료형, 변수명, 초깃값
4. `10`은 음수 부호를 갖을 수 있게 부호 비트 1비트와 자료 비트 7비트를 할당합니다. 하지만 `10U`은 부호가 없음으로 음수표현 지원 없이 자료 비트 8비트로 할당합니다.
5. ASCII
6. `&nData`은 `nData` 변수의 주소를 의미합니다. 즉 우변(RValue 만 있어야 할 자리)에서 좌변(LValue)의 값인 주소를 접근하는 표현입니다.

## Chapter 03 표준 입출력 도구

UX 혹은 HCI는 결국에는 프로그래머 입장에서는 입출력을 기반으로 합니다.

사용자의 입력을 얼마나 의도에 맞게 정확히 전달하는가가 관건입니다.

### 문자 입출력

영문 한 글자는 `char`입니다. 내부적으로 8비트 정수입니다. 8비트 정수라 덧셈 뺄셈도 가능합니다. 이것을 다시 기억하도록 합니다.

`int getchar()`는 인자가 없습니다. 표준입력장치 버퍼 메모리에서 한글자를 읽어오는 함수입니다. 버퍼 메모리가 비어있으면 유저에게 입력을 받아 채운 후 반환합니다. 주의할 점은 `char`을 반환할 것처럼 생겼는데 `int`를 반환합니다. 크기 차이를 제외하면 결국 모두 정수입니다.

`int putchar(int c)` 표준 출력장치인 콘솔에서 영문 한 글자를 출력합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;

  ch = getchar();

  putchar(ch);
  putchar('Z');

  return EXIT_SUCCESS;
}
// h
// hZ%
```

`getchar`는 입력을 받기위해 1번 대기 했습니다. 그리고 `putchar`는 출력에 사용되었습니다. 기존에 입력 받은 것을 출력하고 또 `Z`앞에 저장한 문자열을 출력했습니다.

여기서 `ch` 처음 초기화 했을 때 값은 사라지고 사용자의 입력을 받은 값을 저장 혹은 복사하게 됩니다.

대부분의 함수는 인자로 대입하면 변수 그자체가 아니라 변수의 정보를 매개변수로 전달하게 됩니다.

```c
#include <stdio.h>
#include <stdlib.h>
/*#include <conio.h>*/
/*#include <curses.h>*/

int main(void) {
  char ch = 0;
  printf("아무 키나 누르면 다음으로 넘어갑니다. \n");

	/*ch = getch();*/
  printf("입력한 키는 ");
  putchar(ch);
  printf("입니다.\n");
  return EXIT_SUCCESS;
}
```

위 코드는 동작하지 않을 것입니다. 먼저 `<conio.h>`는 윈도우에서만 제공합니다. 맥에서는 `<curses.h>`을 따로 설치해야 합니다.

[why does this error occur: 'conio.h' file not found](https://stackoverflow.com/questions/67320428/why-does-this-error-occur-conio-h-file-not-found)

위를 보면 그렇습니다.

```sh
brew install ncurses # curses 파일 설치
```

`_getch()` 혹은 `_getche()` 함수는 Non-buffered I/O 합니다. 버퍼를 안 거치고 전달합니다. 어떤 키라도 입력이 있으면 즉시 반환합니다.

### 문자열 입출력

문자열은 문자의 배열입니다. `H`, `e`, `l`, `l`, `o`, `\0` 문자들을 묶는 것이 문자열입니다. 이런 표현은 일일이 입력하기 귀찮습니다. 그래서 `"Hello"`라고 표현합니다. 이렇게 표현해도 문자의 배열로 취급합니다.

문자를 다루는 것과 문자열을 다루는 것의 차이는 한 인스턴스(`char`)를 다루는 것과 인스턴스(`char[n]`)을 묶어서 다루는 것의 차이입니다.

배열의 이름은 일반 변수의 이름과 달리 메모리의 주소에 부여한 식별자입니다. `char szName[32]`은 `char`이 32개인 배열입니다. `szName`은 주소를 접근할 식별자입니다.

배열의 이름은 주소입니다.

주소를 저장하는 변수는 포인터입니다. 배열을 활용하면 포인터도 같이 활용하는 경우가 많습니다.

`char *gets(char *buffer)` / `int puts(const char *string)` 함수는 문자열을 입출력 해주는 함수입니다.

`gets()`는 버퍼 즉 입력받은 문자를 저장할 메모리 주소를 인자로 받습니다. 반환입니다. 에러는 `NULL` 성공은 받은 메모리 주소입니다. 목적은 표준입력장치의 문자열을 받는 함수입니다.

`puts()`는 출력할 문자열이 저장된 메모리의 주소입니다. 반환입니다. 정상이면 음수가 아닌 정수입니다. 에러는 `EOF`입니다. 표준출력장치에 문자열을 출력하는 것이 목적입니다.

`getchar()`, `putchar()`과 다릅니다. 인자가 포인터입니다. `gets()`는 저장될 메모리 주소입니다. `puts()`는 출력할 메모리 주소를 접근하고 화면에 출력합니다.

다음은 가장 전형적인 문자열 입출력 예지입니다. SDL 검사에 주의하기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_BUF_SIZE 32

int main(void) {
  // char 변수 32개가 한 덩어리로 묶인 배열 선언
  char szName[MAX_BUF_SIZE] = {0};

  // 사용자로부터 이름(문자열)을 입력받는다.
  printf("이름을 입력하세요: ");
  /*
   * 사용자가 입력한 문자들을 문자 배열에 모두 저장
   * gets은 보안 결함이 있습니다.
   * gets_s은 윈도우 전용입니다.
   */
  fgets(szName, MAX_BUF_SIZE, stdin);

  // 배열에 저장된 이름을 화면에 출력
  printf("당신의 이름은 ");
  puts(szName);
  puts("입니다.");

  return EXIT_SUCCESS;
}
```

과거에 쓰던 `gets()` 함수는 키보드 입력 버퍼를 검사합니다. 버퍼가 비어있으면 사용자의 문자열을 입력받아 저장합니다. `gets()`는 인자가 1개입니다. 이 인자는 버퍼에서 저장된 문자열을 인자(`szName`)에 복사합니다. 이미 버퍼에 정보가 있었다면 별도로 사용자 입력을 안 받습니다.

`gets` 함수는 보안 결함을 갖고 있습니다. 버퍼로 받은 문자열의 메모리 주소와 문자열이 저장될 메모리의 바이트 단위 크기를 인자로 넣고 제어하는데 문제가 있습니다. 책의 예제는 `gets` 대신에 `gets_s`를 권장했습니다. 저는 `fgets`를 사용했습니다.

`gets`의 문제는 버퍼 오버플로우로 버퍼 오버런 공격이 가능합니다. 이 보안 취약점 등급은 심각한 수준입니다. 허가 받지 않은 원격 사용자가 관리자 권한을 얻는 사고입니다.

```c
#include <stdio.h>
#include <stdlib.h>


int main(void) {
  // char 변수 32개가 한 덩어리로 묶인 배열 선언
  char szName[32] = {0};

  // 사용자로부터 이름(문자열)을 입력받는다.
  printf("이름을 입력하세요: ");
  /*
   * 사용자가 입력한 문자들을 문자 배열에 모두 저장
   * gets은 보안 결함이 있습니다.
   * gets_s은 윈도우 전용입니다.
   */
  fgets(szName, sizeof(szName), stdin);

  // 배열에 저장된 이름을 화면에 출력
  printf("당신의 이름은 ");
  puts(szName);
  puts("입니다.");

  return EXIT_SUCCESS;
}
```

도서의 예제는 `sizeof`를 알려줍니다. 보안 결함이 될 가능성이 있는 행위 즉 배열의 경계를 넘어서 사용이 허가된 메모리 이상을 사용하는 경우입니다. 이 경우 예외를 발생시킵니다. 프로그램이 비정상 종료되는 것 같아도 해킹을 방어할 수 있게 됩니다.

`sizeof`는 메모리의 크기를 측정하는 연사자입니다. 지금은 `char` 32 개를 바이트 단위로 계산하는 경우입니다. `char`는 1 바이트라 총 32바이트에 해당합니다.

`printf`는 콘솔 기반으로 정보 출력할 때 가장 많이 사용하는 함수 중 하나입니다. 문자, 숫자(정수, 실수), 문자열 모두 출력이 가능합니다.

```c
int printf(const char *format [, argument]...);
```

`printf` 시그니쳐를 보면 제대로 활용을 위해 형식 문자열(format string)을 이해해야 합니다. 형식 문자열은 문자열, 형식 문자, 이스케이프 시퀀스로 구성됩니다.

시그니쳐를 잘 보면 가변인자입니다. 인자의 개수가 형식 문자의 개수와 일치해야 합니다.

형식 문자는 출력할 정보의 자료형과 밀접하게 관련되어 있습니다. 형식문자열과 인자를 조합해서 최종 문자열을 만드는 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 10;

  /* 문자상수를 화면에 출력 */
  putchar('B');

  /* '\n'은 개행문자이므로 알파벳 문자가 화면에 보이지 않을 것 */
  putchar('\n');

  /* 개행 문자 출력 이후 A와 개행문제를 출력 */
  printf("%c\n", 'A');

  /* %d라는 형식 문자에 맞춰 변수 x에 담긴 정보 출력 */
  printf("x는 %d 입니다.\n", x);

  return EXIT_SUCCESS;
}
```

`printf`를 사용하면 각종 안내 문구를 조합하고 출력이 가능합니다. `putchar`, `puts`로는 언젠가 비슷한 결과를 만들어도 `int`를 출력할 수 없습니다.

`%d`은 10진수(decimal)를 의미합니다. 단순하지만 자주 사용합니다.

| 형식 문자 | 자료형             | 설명                                               |
| --------- | ------------------ | -------------------------------------------------- |
| `%c`      | `char`             | 문자를 출력 및 입력할 때 사용                      |
| `%d`      | `int`              | 정수를 출력 및 입력할 때 사용                      |
| `%o`      | `int`              | 정수를 8진수로 출력할 때 사용                      |
| `%u`      | `unsigned int`     | 부호 없는 정수를 출력 및 입력할 때 사용            |
| `%x`      |                    | 정수를 16진수로 출력할 때 사용                     |
| `%e`      | `float or double`  | 지수 형식의 실수를 출력할 때 사용                  |
| `%f`      | `float`            | 실수를 출력 및 입력할 때 사용                      |
| `%g`      | `float or double`  | 값에 따라 `%f` 또는 `%e`를 선택하여 출력할 때 사용 |
| `%p`      | `void`             | 포인터의 주소 값을 출력할 때 사용                  |
| `%s`      | `char[]` or `char` | 문자열을 출력 및 입력할 때 사용                    |
| `%a`      | `float or double`  | 16진수 부동소수점을 출력할 때 사용                 |
| `%n`      | `int`              | 출력된 문자의 개수를 저장할 변수를 지정할 때 사용  |

`%s`는 문자열 즉 메모리 주소를 받아 출력하기만 합니다. 자료형 정보와 출력이 올바르게 일치하지 않으면 컴파일러는 어떤 경고도 안해줍니다.

`%`을 출력하고 싶은 경우 `%%`으로 이스케이프 해야 합니다.

문자와 정수 출력

C 언어 정수 표시에 사용하는 자료형은 `char`, `short`, `int`, `long`, `long long int`입니다. `char`, `int`은 `%c`, `%d`으로 나타냅니다.

ASCII 코드 영문 `'A'`는 10진수로 65이고 16진수로 `0x41`입니다. 65는 10진수 정수이고 `int`입니다. `'A'`은 `char`이고 상수입니다. `'A'`의 본질은 10진수 65라 정수인가? 반대로 65가 `char`가 아닌가?

`char`와 `int`는 부호있는 정수라는 점이 같습니다. 길이가 8비트, 32비트만 다릅니다. `%c`과 `%d` 모두 `int` 다루는 것을 원칙으로 합니다. 그냥 `char`가 크기를 작게 다룰 뿐입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // 문자상수를 ASCII 코드 문자형으로 출력
  printf("%c\n", 'A');      // A
  // 문자 'A'의 ASCII 코드값(65)에 1을 더한 값을 문자로 출력
  printf("%c\n", 'A' + 1);  // B
  // 문자상수를 ASCII 코드 문자형으로 출력
  printf("%c\n", 'C');      // C

  // 문자 'A'의 ASCII 코드값을 10진수(%d)로 출력
  printf("%d\n", 'A');      // 65
  // 문자 'A'의 ASCII 코드값에 1을 더하고 10진수(%d)로 출력
  printf("%d\n", 'A' + 1);  // 66
  // 문자상수를 ASCII 코드값을 10진수(%d)로 출력
  printf("%d\n", 'C');      // 67

  // 10진수(정수)를 문자(ASCII)로 출력
  printf("%c\n", 65);       // A
  printf("%c\n", 65 + 1);   // B
  printf("%c\n", 67);       // C

  return EXIT_SUCCESS;
}
```

본질은 `char`, `int`가 모두 부호 있는 정수입니다. 정보의 본질은 달라지는 것이 아니라 출력 형식만 변경하는 것으로 다른 정보로 인식합니다.

`%d` 부호가 있으면 `char`, `short`, `int` 모두 숫자로 출력합니다.

`%u`은 부호가 없으면 32비트로 표시할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // int형 상수 10을 10진 부호가 있는 정수형식으로 출력
	printf("%d\n", 10);
	// 10을 '부호가 없는' 정수형식으로 출력
	printf("%u\n", 10);
	// unsigned int 상수 10U을 %d 형식으로 출력
	printf("%d\n", 10U);
	// unsigned int 상수 10U을 %u 형식으로 출력
	printf("%u\n", 10U);

	// 부호가 있는 32비트 정수로 표현할 수 있는 가장 큰 수
	printf("%d\n", 2147483647);
	// 부호가 있는 32비트 정수로 표현할 수 있는 '범위를 넘어선' 정수를 출력
	printf("%d\n", 2147483648);
	// 부호가 있는 32비트로 정상 출력
	printf("%u\n", 2147483649);

	// -1을 부호있는 10진수로 출력
	printf("%d\n", -1);
	// 같은 값(-1)이지만 부호가 없는 형식으로는 전혀 다른 값 출력
	printf("%u\n", -1);

  return EXIT_SUCCESS;
}
```

이렇게 작성하면 컴파일부터 막힙니다. 비트 오버플로우 비트 언더플로우 문제를 컴파일러가 감지합니다.

32비트 단위로 표현할 수 있는 것을 넘습니다.

부호가 있으면 너무 작습니다. 하지만 부호가 없으면 43억 미만입니다. 물론 통계 프로그램을 작성하는 지금시대에도 작은 단위입니다.

더큰 자료형을 다룰 때는 `long long int`로 해결해야 합니다.

$$
\begin{align}

-2^{63} ~ 2^{63} - 1

\end{align}
$$

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // 부호 있는 64비트 변수 정의
  long long int lldData = 4294967295LL;

  // 64비트 정보를 32비트 문자로 출력
  printf("d\n", lldData);
  printf("u\n", lldData);

  // 32비트로 표현할 수 없는 범위의 정보 출력
  printf("%u\n", lldData + 1);
  printf("%u\n", lldData + 2);
  printf("%u\n", lldData + 3);

  // 64비트 정보를 64비트 형식 문자(%lld)로 출력
  printf("%lld\n", lldData + 1);
  printf("%lld\n", lldData + 2);
  printf("%lld\n", lldData + 3);

  return EXIT_SUCCESS;
}
```

역시나 컴파일에러가 또 발생할 것입니다.

`%ld`와 `%lld`의 차이는 비트 응용프로그램의 차이입니다. 32비트로 응용 프로그램을 운용하는지 64비트로 응용 프로그램을 운용하는지는 다릅니다.

10억 단위 정수를 다룰 때는 `long long int`와 `%lld`를 활용할 것을 권장합니다.

참고로 형식문자는 자릿수, 폭 제한, 왼쪽 정렬 처럼 form을 제어하는 기능을 갖고 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  printf("%d\n", 1234);
  printf("%d, %d\n", 1234, -5678);
  // 부호를 붙여 출력
  // +을 출력하는 것은 아님
  printf("%+d, %+d\n", 1234, -5678);

  // 정수를 8자리로 맞추고 오른쪽 정렬
  printf("%8d\n", 1234);
  // 오른쪽 정렬하고 공백은 0으로 채움
  printf("%08d\n", 1234);
  // 왼쪽 정렬
  printf("%-8d\n", 1234);

  return EXIT_SUCCESS;
}
```

출력을 포맷팅할 수 있습니다.

실수와 지수 출력

자료형에 부동소수점 표현도 다루었는데 출력은 안다루는가? 다룹니다. 컴퓨터의 특성은 우리가 이론적으로만 알고 있는 것입니다.

정수는 부호를 구분했습니다. 실수는 실수 출력과 지수출력을 구별할 수 있습니다. 정수처럼 표현 범위가 달라지거나 부호개념이 사라지는 경우는 없습니다. `%f`, `%e`만 다를 뿐입니다.

`F`붙으면 `float` 실수형이고 없으면 `double`입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // 실수 자료형의 메모리 사이즈 출력
  printf("%d\n", sizeof(123.456F)); // 4
  printf("%d\n", sizeof(123.456));  // 8

  // float 형을 실수형으로 출력
  printf("%f\n", 123.456F); // 123.456001

  // double형을 실수형으로 출력
  printf("%f\n", 123.456);  // 123.456000
  printf("%lf\n", 123.456); // 123.456000

  return EXIT_SUCCESS;
}
```

`%f`는 `float`이고 `%lf`는 `double`에 해당하는 출력 형식입니다. `printf` 함수에서는 구분을 안해도 괜찮습니다.

하지만 `scanf`는 구분해야 합니다. `float`형이라도 부동 소수점 오차는 있습니다. 이 실수단위 연산 혹은 출력에서 부동소수점 오차는 문제입니다.

형식 문자와 가변인자를 잘못연결하는 실수가 없어야 합니다. 실수 출력은 문법만 다룰 것이 아니라 부동소수점 오차도 같이 논해야합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  printf("%f\n", 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F);  // 4.999998
  return EXIT_SUCCESS;
}
```

심각한 오류입니다. 0.000002이 부족합니다. 실수 연산은 가능하면 `float`보단 `double`을 활용할 것을 권장합니다. 15번째 정보까지 신뢰할 수 있습니다.

`%f`를 출력할 때 주의할 점은 소수점을 표시하는 것입니다. 더 많이 혹은 덜 표시할 수 있습니다. 자동으로 반올림할지도 모릅니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  double dData = 123.456;
  printf("%f, %f\n", dData, -123.456); /*123.456000, -123.456000*/

  // 소수점 반올림
  printf("%.1f\n", dData); /*123.5*/
  printf("%.2f\n", dData); /*123.46*/
  printf("%.3f\n", dData); /*123.456*/

  printf("%8d\n", dData);  // 컴파일 에러

  // 소수점을 포함해 12자리출력 소수점 4번째에서 반올림하고 3번째자리까지 출력
  printf("%12.3f\n", dData);  /*     123.456*/
  printf("%012.3f\n", dData); /*00000123.456*/

  return EXIT_SUCCESS;
}
```

`%(전체_자리).(소수점_최대길이)f`

위 형식을 따릅니다. 최대길이를 벗어나면 자동으로 반올림처리합니다. 이것은 개발자의 주의해야 합니다.

실수를 다룰 때 다양한 전략이 있는데 먼저 정책으로 정수를 먼저 활용하게 만드는 것입니다. 성적표의 평균을 계산하는 것보다 총점을 합산하는 것이 더 쉬울지도 모릅니다. 현실에서는 시키는데로 해야 하기 때문에 무조건 평균을 활용해야 하면 다른 전략은 곱셈으로 정수단위가 되게 만들어서 계산을 처리하면 됩니다. 단지 성능문제가 발생할 것이 문제입니다.

### `scanf` 함수

```c
int scanf(const char *format [, argument]...);
```

형식 문자열에 맞추어, 표준입력장치(`stdin`)로부터 정보를 읽어들이는 함수입니다. 가변인자는 사용자가 입력한 값이 저장될 메모리의 주소들입니다.

`format`: 형식 문자열이 저장된 메모리 주소
`[, argument]`: 형식 문자열에 대응하는 가변인자

인력할 문자열의 개수를 반환합니다. 유효하게 입력했는지 확인할 때 활용해볼 수 있습니다.

주의해야할 점은 형식 문자에 대응하는 가변인자는 모두 주소입니다.

`scanf` 함수의 가변인자는 모두 메모리 주소가 되어야 합니다. 이것은 `gets` 함수와 동일합니다. 매개변수로 주소를 대입하는 방식은 C 언어에서 자주 등장합니다.

사용자 나이(정수)를 받고 출력하는 예제입니다. 또 보안문제도 있을 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nAge = 0;
  printf("나이를 입력하세요. :");
  scanf("%d", &nAge);
  printf("당신의 나이는 %d세 입니다.\n", nAge);
  return EXIT_SUCCESS;
}

// 정상적인 경우 (정수 입력)
// 나이를 입력하세요. :10
// 당신의 나이는 10세 입니다.
// 비정상적인 경우 (문자열 입력)
// 나이를 입력하세요. :asdf
// 당신의 나이는 0세 입니다.
```

사용자의 입력을 해석할 수 없고 전달된 주소로 식별되는 메모리를 담아주지 않습니다.

오픈북으로 문제를 풀었습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int age = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d", &age);
  while (getchar() != '\n') {
    continue;
  }

  char name[32] = {0};
  printf("\n이름을 입력하세요. : ");
  scanf("%s", name);
  while (getchar() != '\n') {
    continue;
  }

  printf("\n 당신의 나이는 %d살이고 이름은 \'%s\'입니다.\n", age, name);

  return EXIT_SUCCESS;
}
```

문제 풀이해설을 설명하기 전에 풀이 과정을 보여줍니다.

여기서 주의할 점은 기본 입출력이 불가능하면 아무것도 할 수 없습니다.

기본 입출력은 암기라도 해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("%d", nInput);

  printf("Input : %d\n", nInput);
  return EXIT_SUCCESS;
}
```

저는 작성할 때부터 린트가 주소를 넣으라고 알려줬습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("%d\n", &nInput);

  printf("%d\n", nInput);
  return EXIT_SUCCESS;
}
```

여기서 문제는 문자를 입력해야 입력이 종료 됩니다.

`getchar`, `gets`, `scanf` 세 함수 모두 키보드 입력을 완료하기 위해 엔터키를 입력 받아야 합니다. 하지만 `scanf`는 함수의 형식 문자열로 개행문자(`\n`)를 넣는 것은 잘못된 것입니다. 입력을 완료하기 위해 개행문자와 문자가 요구하는 개행문자는 구분할 수 없습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("Input : %d", &nInput);

  printf("Input : %d\n", nInput);
  return EXIT_SUCCESS;
}
```

여기서 입력하면 항상 `0`이 될 것입니다. 하지만 `Input : `을 앞에 붙이면 숫자를 받을 것입니다.

형식문자열로 표준입력에서 받는데 사용자가 입력을 알 수 있게 하는 것이 아닙니다. `printf`랑 `scanf` 함수를 혼동하면 큰일납니다.

지금까지는 입력을 1개만 입력받고자 했습니다. 이번에는 2개를 입력 받아보겠습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0, y = 0;
	printf("두 정수를 입력하세요. : ");

  scanf("%d%d", &x, &y);

  printf("두 수의 합은 %d입니다.\n", x + y);
  return EXIT_SUCCESS;
}
```

공백으로 구분해서 숫자 2개 입력하면 잘 동작할 것입니다. 붙여서 입력하면 이해할 것이라고 착각하는데 아닙니다.

띄어쓰기는 화이트 스페이스(탭, 개행문제, 스페이스바)에 해당합니다. 눈에 안보이고 존재하는 문자입니다. 고려해서 문자열 길이에 포함해야 합니다.

`Hello\n`은 개행문자를 포함해서 6개입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;
  scanf("%c", &ch);
  printf("입력한 문자는 %c 입니다.\n", ch);
  return EXIT_SUCCESS;
}
```

위 코드는 보안취약점을 갖고 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[32] = { 0 };
  scanf("%s", szBuffer);
  printf("%s\n", szBuffer);
  return EXIT_SUCCESS;
}
```

하지만 한계가 있습니다. `%s`은 공백 문자를 포함해서 입력받을 수 없습니다. 뭐 여러개받는 것도 전략이지만 효율적이지 않을 것 같습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBufferLeft[32] = { 0 };
  char szBufferRight[32] = { 0 };
  scanf("%s%s", szBufferLeft, szBufferRight);
  printf("%s %s\n", szBufferLeft, szBufferRight);
  return EXIT_SUCCESS;
}
```

이렇게 여러개 받을 수 있게 변수를 추가합니다. 문제는 변수를 1억개를 추가할 것인가?

공백을 포함하고 싶으면 `gets`를 활용합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szName[32] = {0};
  int nAge = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d", &nAge);

  printf("이름을 입력하세요. : ");
  gets(szName);

  printf("%d, %s\n", nAge, szName);
  return EXIT_SUCCESS;
}
```

보안 문제를 여전히 갖고 있습니다. 나이를 문자로 입력하면 버퍼에 남아있고 `gets`가 접근하는 문제가 있습니다. 그래서 이름 입력을 못하게 됩니다.

참고로 gcc는 컴파일을 못하게 막습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szName[32] = {0};
  int nAge = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d%*c", &nAge);

  printf("이름을 입력하세요. : ");
  fgets(szName, sizeof(szName), stdin);

  printf("%d %s\n", nAge, szName);
  return EXIT_SUCCESS;
}
```

위는 조금더 안전하게 처리하는 방법입니다.

`%*c`이 나중에 추가된 형식 문자입니다. 문자 하나를 입력 버퍼로 읽고 그 후에 버린다는 의미입니다. 그리고 이 방법은 다양한 운영체제 호환성 문제가 없습니다.

동작하는 원리가 `scanf`는 엔터를 입력하면서 개행문자를 보고 입력의 종료로 판단하는데 숫자는 꺼내도 개행문자는 계속 갖고 있습니다. 하지만 `%*c`은 문자에 속한 개행문자를 버리겠다는 의미로 버퍼는 비워지고 `fgets`로 문자열을 입력할 수 있게 됩니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int age = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d%*c", &age);

  char name[32] = {0};
  printf("\n이름을 입력하세요. : ");
  fgets(name, sizeof(name), stdin);

  printf("\n 당신의 나이는 %d살이고 이름은 \'%s\'입니다.\n", age, name);

  return EXIT_SUCCESS;
}
```

정확한 정답은 위와 같아집니다.

1. `getchar()` 함수를 호출하고 사용자 입력을 받는데 4글자 이상 입력 받고 그 중에 두번째 글자만 출력합니다.

요구사항은 3개입니다. 글자 4개이상 받아야 합니다. 그리고 두번째 글자를 접근합니다. 접근할 글자를 출력합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int count = 0;
	char buf = 0;
	printf("입력 : ");
  while (buf != '\n') {
		buf = getchar();
    count += 1;
		if (count == 2) {
			printf("출력 : %c\n", buf);
		}
  }
  if (count < 4) {
    printf("4개 이하 문자를 입력했습니다.\n");
  }
  return EXIT_SUCCESS;
}
```

2. `getchar` 함수와 `_getch` 함수가 내부적으로 다른 점은 무엇이 다른가?

`getchar` 함수는 Buffer IO를 하고 `_getch` 함수는 Non-Buffer IO를 합니다. 버퍼 메모리를 직접 접근하는 것과 입력 여부에 대한 감지가 다릅니다.

3. `gets` 함수는 보안결함이 있습니다. 이 함수를 대체할 수 있는 것들은 무엇인가?

`fgets`로 대체가 가능합니다.

4. 만일 부호가 있는 10진 정수형 표현할 수 있는 가장 큰 양수 범위를 1넘어서면 컴퓨터는 이를 어떤 숫자로 인식하는지 기술하시오.

```c
#include <stdio.h>

int main(void) {
  char num1 = 127;
  char num2 = 128;
  printf("%d\n", num1); // 127
  printf("%d\n", num2); // -128
  return 0;
}
```

위처럼 동작하게 되는 이유입니다.

편의를 위해 8비트 단위로 설명하겠습니다. 8비트면 0부터 2의 8제곱에서 1이 부족한 127까지입니다. 하지만 부호 비트가 있으면 최대 양수는 127까지입니다.

$$
\begin{align}

01111111_{(2)}

\end{align}
$$

127을 이진수로 표현하면 위와 같습니다. 여기서 1을 더하면 오버플로우 현상이 발생해서 양수가 음수가 됩니다.

$$
\begin{align}

10000000_{(2)}

\end{align}
$$

이 오버플로우 현상은 -1이 아닙니다. 가장 낮은 -128입니다. 넘겨진 숫자는 버려지고 회전하게 됩니다. 숫자를 원으로 생각하면 직관적일 것입니다.

5. 부호가 없는 10진 정수 형식과 부호가 있는 10진 정수 형식을 출력하기에 적절한 형식문자는 각각 무엇인가?

```c
printf("부호 없는 10진 정수 %u", 10U);
printf("부호 있는 10진 정수 %d", 10);
```

6. `123.45` 자료형은 무엇인가? 그리고 이 값을 출력하기에 적절한 형식 문자는 무엇인가?

자료형은 `double`입니다.

```c
printf("%d\n", 123.45);
```

7. 형식 문자 `%012.3F`가 의미하는 것은 무엇인지 기술하시오.

총 12자리가 있는 실수표현에서 소수점 3째자리까지 보여주고 4째는 반올립처리하고 왼쪽 정렬을 하는데 0으로 채웁니다.

8. 배열에 담긴 문자열을 출력하려 합니다. 적절한 형식 문자는 무엇인가?

```c
printf("%s\n", i);
```

문자열은 `%s`으로 출력하는데 이것을 뭐 순회해서 출력하는 것을 묻는지 모르겠습니다.

9. `scanf` 함수로 정수를 입력받은 후, 입력 버퍼에 남은 개행문자를 제거하려합니다. 전략은 무엇이 있는가?

```c
scanf("%d%*c", &num);

while (getchar() != '\n') {}
```

10. 만일 `nInput`이 정수형 변수라면 다음 코드는 무엇이 잘못되었는가?

```c
scanf("%d", nInput);
```

두번째 인자로 주소를 대입해야 하는데 값을 대입하고 있습니다.

11. `scanf` 함수로 `double`로 입력받으려고 합니다. 적절한 형식문자는 무엇인가?

```c
double num1 = 123.456;
scanf("%lf\n", &num1);
```

이렇게 처리합니다.

## Chapter 04 연산자 - 기본

자료형과 변수의 저장은 메모리 중 RAM와 관련되어 있습니다. 지금부터 다룰 연산자는 메모리가 아닌 CPU의 작업과 직결됩니다.

프로그래밍의 본격적인 부분은 여기서부터입니다.

연산자와 피연산자 그리고 항입니다. `3 + 4`의 항은 총 3개입니다. 피연산자 3, 4 연산자 `+`으로 모두 개입니다.

피연산자 항만 감안하면 2개입니다. 주로 피연산자를 칭하기 때문에 `+`은 2개의 피연산자가 필요해서 2항 연산자라고 부릅니다.

C 언어는 단항 연산자부터 3항 연산자까지 있습니다.

| 우선순위 | 연산자                                                             | 결합성 |
| -------- | ------------------------------------------------------------------ | ------ |
| 1        | `()`, `.`,`[]`, `->`                                               | →      |
| 2        | `*`, `&`, `!` `++`, `--`, `(datatype)`, `sizeof - `,               | ←      |
| 3        | `*`, `%`, `/`                                                      | →      |
| 4        | `+`, `-`                                                           | →      |
| 5        | `<<`, `>>`                                                         | →      |
| 6        | `<`, `<=`, `>`, `>=`                                               | →      |
| 7        | `==`, `!=`                                                         | →      |
| 8        | `&`                                                                | →      |
| 9        | `^`                                                                | →      |
| 10       | `\|`                                                               | →      |
| 11       | `&&`                                                               | →      |
| 12       | `\|\|`                                                             | →      |
| 13       | `?:`                                                               | ←      |
| 14       | `=`, `+=`, `-=`, `*=`, `%=`, `/=`, `&=`, `\|=`, `^=`, `<<=`, `>>=` | ←      |
| 15       | `,`                                                                | →      |

위는 우선순위입니다. 표전전체를 암기하는 것이 시험문제입니다. 우선순위는 당연히 맞추고 연산자의 순서까지 암기하세요. 우선순위가 같으면 방향으로 결합성 방향 순으로 처리합니다. 하지만 여러분은 상대평가하기 위해서 연산자 순서에 무조건 집중해서 암기하세요.

수학 시간이 아니지만 교환법칙은 알아야 합니다. 덧셈 연산은 교환법칙이 성립합니다. `3 + 4`와 `4 + 3`은 결과가 같습니다. 항의 자리를 교환해도 문제가 없으면 교환법칙이 성립한다고 합니다. 곱셈도 성립합니다. 하지만 성립하지 않는 연산자도 있습니다.

### 산술 연산자

`+`, `-`, `*`, `/`, `%` 뭐 특별한 거 없습니다. 수학이랑 같습니다.

뭐 특별히 알아야 할 것은 연산의 임시결과입니다. 이 임시 결과는 CPU 레지스터에 연산 결과를 저장하고 처리하고 저장한 레지스터를 갱신하고 처리가 끝나면 다시 메모리에 쓰기를 하는 것을 의미합니다. 이런거는 일반인도 교양 다큐나 유튜브에서 다 보는 내용입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nResult = 0;

  nResult = 3 + 4 - 5;

  printf("nResult: %d\n", nResult);
  return EXIT_SUCCESS;
}
```

뭐 결과가 2가 될 거라는 것은 눈으로 보고 알 수 있습니다. 하지만 2가 될 것이라고 처리하는 과정은 CPU가 메모리에서 순서대로 읽고 처리하고 레지스터의 값을 메모리 쓰기하는 문제입니다.

처음에 연산자 우선순위가 같은 덧셈, 뺄셈입니다. 여기서 왼쪽에서 시작에서 오른쪽으로 처리하고 마지막에 할당으로 왼쪽으로 흐릅니다. 피연산자 `3`, `4`를 먼저 레지스터합니다. 그리고 더하기 작업을 수행합니다. 결과로 7을 레지스터에 저장합니다. 다음 `-`은 작업 레지스터 `5`는 오퍼랜드 레지스터에 적재합니다. 작업을 수행하고 `2`로 저장했던 레지스터를 갱신합니다. 마지막으로 `2`를 `nResult`의 주소에 레지스터에 있던 값을 쓰기를 합니다.

뭐 어쎔블리 생각하는 그대로 이해하면 됩니다. 여기서 임시 저장이라고 하는데 CPU가 작업할 대상인 레지스터입니다. 정상적인 프로그래밍을 하려면 이 레지스터에 저장하면서 작업을 수행한다는 것을 알고 있어야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nResult = 0;

  nResult = 3 + 4;

  printf("nResult: %d\n", nResult - 5);
  return EXIT_SUCCESS;
}
```

이거는 화면에 출력 전에 메모리 주소에서 값을 가져오고 연산하고 결과를 보여주는 경우입니다.

C 언어는 수동으로 처리해주는 기본에 충실한 언어입니다. 기계의 특성을 고려한 이론이 기본입니다. 수동으로 처리하는 것 중하나는 이형자료 사이 연산입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  char ch = 'A';
  printf("%c\n", ch);

  printf("%c\n", ch + 1);
  printf("%c\n", 'A' + 1);

  /*printf("%d\n", 5.0 + 2);*/
  printf("%f\n", 5.0 + 2);
  return EXIT_SUCCESS;
}
```

컴파일러 에러 때문에 주석처리했습니다. 하지만 `double`과 `int`를 더하면 `double`로 승격됩니다. 그리고 `char`는 원래 본질은 `int` 인데 지금은 `char`로 출력해서 `char`가 나옵니다. 과거에 시도했던 예제가 이미 이형간 연산이었습니다.

`char`와 `int`를 더할 때 레지스터에는 어떻게 저장하는가? `int`로 저장합니다. 뭐 생각해보면 숫자를 처리하기 더 쉬운데 굳이 어려운 자료형을 사용해야 하는가? 이런 생각을 해볼 수 있습니다. 하지만 이런 원칙을 기준으로 생각하면 됩니다. 임시결과의 자료형은 연산에 참여한 피연산자 중 정보 표현 범위가 더 넓은 자료형으로 변환합니다. 이런 원칙을 기준으로 `int`와 `double` 중 `double`이 되는 것이 말이 됩니다. 추측 해보면 `float`와 `double`을 같이 더하면 `double`이 될 것입니다.

연산의 결과가 피연산자의 자료형보다 표현범위가 넓은 형으로 변환되는 현상을 형승격(type promotion)이라고 부릅니다.

참고로 `int`와 `char` 사이 `int`로 표현범위가 같은데 `int`로 승격되는 것을 것을 integral promotion이라고 부릅니다.

C 언어는 개발자가 모든 것을 알고 있다고 가정합니다. 연산이나 정보 출력에 이런 내부 현상을 고려하는 것은 기본입니다.

곱셈 나눗셈도 크게 다른 것은 작습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int x = 10;
  printf("%d\n", x * 10);       // 100
  /*printf("%d\n", x * 10.0);*/ // 출력 자료형 컴파일 에러
  printf("%d\n", x / 10);       // 1

  printf("%d\n", 5 / 2);        // 2
  /*printf("%f\n", 5 / 2);*/    // 출력 자료형 컴파일 에러
  printf("%f\n", 5.0 / 2);      // 2.500000

  return EXIT_SUCCESS;
}
```

여기서 형승격의 일반적인 원리를 잘 이히해면 됩니다.

나눗셈에서 주의할 점은 정수와 정수로 나누면 정수입니다. 굳이 형승격할 이유가 없습니다. 소수점은 그냥 절사 처리하고 끝냅니다.

수학적으로 당연한 말이지만 0으로 나눌 수 없습니다.

프로그래밍의 기본은 예외처리입니다. 프로그래밍 하루만 배워도 다음과 같은 실수 안 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  printf("정수를 입력하세요. : ");

  scanf("%d", &nInput);

  printf("%d\n", 10 / nInput);
  return EXIT_SUCCESS;
}
// 정수를 입력하세요. : 0
// 0
```

gcc 컴파일러가 내부적으로 안전하게 처리한 것 같습니다. 원래 에러가 발생하고 비정상적인 종료를 할 거라고 예상했는데 아니었지만 0에 대해서 예외처리를 올바르게 했어야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  printf("두 정수를 입력하세요. : ");
  // 입력 10, 20
  int num1 = 0, num2 = 0;
  scanf("%d%d", &num1, &num2);
  // 출력 15.00
  printf("AVG : %.2f\n", (num1 + num2) / 2.0);
  return EXIT_SUCCESS;
}
// 두 정수를 입력하세요. : 10 20
// AVG : 15.00
```

간단한 연습 문제입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0;
  scanf("%d", &x);
  printf("몫: %d\n", x / 3);
  printf("나머지: %d\n", x % 3);
  return EXIT_SUCCESS;
}
/*17*/
/*몫: 5*/
/*나머지: 2*/
```

나머지 연산자에서 주의할 점은 나머지 연산자의 피연산자로 실수를 사용할 없다는 점입니다. `12.3 % 3`, `12.3f % 3` 이런 연산은 허용되지 않습니다. 

나머지 연산자는 덧셈, 뻴셈보다는 높고 곱셈, 나눗셈과 같습니다.

프로그래머에게 나머지 연산자는 수학적으로 나머지를 구하는 것말고 공학적으로 문제 해결에 사용하는 훌륭한 도구입니다. 

나머지 연산은 제수만큼 경우의 수를 갖습니다. 이것은 문제해결에 유용한 수학적 성질입니다. 

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int sec = 0;
  scanf("%d", &sec);
  printf("%d초는 %02d시간 %02d분 %02d초 입니다.\n", sec, sec / (60 * 60),
         sec % (60 * 60) / 60, sec % 60);
  return EXIT_SUCCESS;
}
/*4000*/
/*4000초는 01시간 06분 40초 입니다.*/
```

뭐 어려운 문제는 아닙니다.

### 대입 연산자

`=` 이 대입 연산자는 그냥 보면 별거 없습니다. 하지만 내부의 동작 방식을 이해해보면 우변의 있는 변수들의 값을 메모리에서 읽고 연산자들에 따라 처리하고 처리하는 동안 레지스터에 저장하고 있다가 좌변 메모리 주소에 쓰기를 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0, nInput = 0;
  scanf("%d", &nInput);

  x = nInput;

  printf("%d\n", x);
  return EXIT_SUCCESS;
}
```

표준입력으로 정수를 입력하면 정수를 `x` 변수에 저장할 것이라는 것을 알고 있습니다.

지금은 원래 `0`으로 써져있던 메모리 주소에 사용자가 입력한 `10`으로 덮어 써졌다는 것입니다. 쓰기를 위해 L-value이고 좌변입니다. 읽기를 위해 우변에서의 변수를 R-value라고 합니다. 좌변인지 우변인지에 따라 주소를 읽고 값을 접근하는 것인지 레지스터에 저장했던 값을 특정 메모리 주소에 쓰기를 하는 것인지 다릅니다.

L은 Left도 의미하지만 locator(위치 지정자)를 의미하기도 합니다. 

정보를 담을 수 없으면 L-value가 아닙니다. 정보를 담는다는 표현에 변수를 보고 상자라고 하는데 여기서 이렇게 비유하는 이유를 바로 알 수 있게 됩니다.

```c
#include <stdlib.h>

int main(void) {

  char szBuffer[32] = {0};

  3 = 4;  // 컴파일 에러

  szBuffer = 'A'; // 컴파일 에러

  return EXIT_SUCCESS;
}
```

딱히 컴파일 할 것은 아니지만 정보를 담을 수 없는 피연산자에 대입연산자를 사용하려고 하고 있습니다.

배열의 이름은 메모리 주소라고 배웠습니다. 즉 L-value가 아닙니다. 상수이고 `szBuffer`에 쓰기를 할 수 없습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 10, y = 20, nTemp = 0;
  printf("Before : x=%d, y=%d\n", x, y);

  nTemp = x;
  x = y;
  y = nTemp;

  printf("After  : x=%d, y=%d\n", x, y);
  return EXIT_SUCCESS;
}
/*Before : x=10, y=20*/
/*After  : x=20, y=10*/
```

메모리 배우면 이런 응용은 바로 가능해야 합니다. 어처구니 없게 설명을 굳이해주면 다음과 같습니다. `x`가 들고 있던 값은 임시 메모리 주소 `nTemp`에 저장합니다. 그러면 지금부터 `x`에 `y`를 할당해도 문제가 없습니다. 그래서 바로 할당합니다. `y`가 갖고 있던 값을 `x`에 저장하면 `y` 변수는 덮어 써도 됩니다. 원래 `x`의 값을 저장했던 `nTemp`의 값을 `y`에 저장합니다. 이렇게 되면 두 변수의 값을 바꿉니다.

이런 거는 처음배우면 바로 할 수 있어야 합니다.

복합 대입 연산자입니다. 그냥 연산자 2개 합친 것입니다. 연산하고 할당하고 2개의 연산을 하는 것입니다. 연산자 표현만 1개입니다. 

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nResult = 0, nData = 10;

  nResult += 3;
  printf("%d\n", nResult); // 3

  nResult *= nData;
  printf("%d\n", nResult); // 30

  nResult /= 2;
  printf("%d\n", nResult); // 15

  nResult -= 5;
  printf("%d\n", nResult); // 10

  nResult %= 3;
  printf("%d\n", nResult); // 1

  return EXIT_SUCCESS;
}
```

할당하고 그 후에 대입하는 것입니다. 뭐 특별한 것은 없습니다.

연산 우선순위가 낮고 결합성은 오른쪽에서 윈쪽으로 향합니다. 

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0, y = 0;
  x = y = 10;
  printf("%d, %d\n", x, y); // 10, 10
  return EXIT_SUCCESS;
}
```

꽤나 충격적입니다. 하지만 논리적으로 불만은 없습니다. `10`이라는 값을 `y`에 쓰고 `y`라는 값을 `x`에 쓰기를 하는 것입니다. 이렇게 쓰기를 하는 이유는 직렬로 코드를 일을 때 `x = (y = 10)` 여기서 `y = 10`이고 여기서 `10`이라는 값을 확인하고 `y`에 저장하고 저장한 `y`값을 또 `x`에 쓰기를 하는 것입니다. 결합성의 방향에서 할당을 할 때는 오른쪽에서 왼쪽이고 실행 순서를 결정할 때는 오른쪽을 먼저 올립니다.


