# 필기

## Chapter 01 C 프로그래밍 입문

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  printf("Hello, World!\n");
  return EXIT_SUCCESS;
}
```

여기서 `#include <stdio.h>`은 전처리기(preprocesser)입니다. 처리는 컴파일 전입니다. `h`는 해더를 의미합니다.

C 언어가 라이브러리 코드를 가져오는 방법입니다. 컴파일 전에 필요한 부분을 가져와 전에 처리하고 기계어로 변환합니다.

프로그래밍은 문법적으로 맞는 것이 전부가 아닙니다. 논리적으로 올바르게 되어 있어야 합니다.

C 언어는 절차지향 프로그래밍 언어로 분류되었있습니다.

프로그램을 실행하면 `main` 함수를 실행하게 됩니다. `int`를 반환해야 합니다. 이 반환과 함께 프로그램은 종료합니다. 즉 `main`에서 시작해서 `main`에서 끝이 납니다.

함수의 목적은 계산과 동작 둘 중 하나 이상의 목적을 가질 수 있습니다.

매개변수와 인자는 컨택스트 구분을 위해서 올바르게 사용해야 합니다. 인자는 호출자가 넣은 값이라 호출자의 컨텍스트에서 논할 때입니다. 매개변수는 함수 정의자의 관점에서 논할 때입니다. 하지만 호출을 해서 넣은 값은 함수 정의 내에서 매개변수이기 때문에 본질적으로는 같습니다.

C 언어는 빌드 즉 컴파일 과정이 있습니다. `c` 확장자는 문서에 불과합니다. 소스코드입니다. 이 소스코드 파일을 목적파일 `obj`를 만듭니다. 이것은 실행파일이 실행할 부품이라고 비유할 수 있습니다. 이 부품들을 조립하는 과정을 보고 링크라고 합니다. 지금은 neovim 환경에서 커맨드라인으로 컴파일하고 있어서 잘 모릅니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  printf("010-1234-5678\n");
  printf("arch-spatula\n");
  return EXIT_SUCCESS;
}
```

ㅇㅇ

## Chapter 02 자료형

컴퓨터에게 모든 것은 본질적으로 수입니다. `0`과 `1` 이 이진수를 옵트코드와 오퍼랜드로 표현하는 어쎔블리에서 현재 하이레벨 언어로 여러 계층 추상화 되어 있는데 본질은 항상 수입니다.

기계는 그져 수를 처리할 수밖에 없습니다.

상수와 변수는 자료의 성격을 의미합니다.

정수와 실수는 자료의 형식을 의미합니다.

자료형은 자료의 구조를 나타내는 형식에 불과합니다.

상수는 2가지가 있습니다. 리터럴과 심볼릭입니다. 주로 변수 선언할 때 상수로 선언할 때는 형한정어를 사용한다고 합니다. 다른 심볼릭은 전처리기에서 제공하는 상수들입니다. 리터럴 상수는 상수 값들입니다.

```c
const int nMax = 100;
```

위는 형한정어를 사용해 정의한 상수입니다.

상수는 값 혹은 주소로 식별합니다. 문자열의 경우 주소로 식별하고 문자자체는 값으로 식별합니다.

변수는 적게 사용할수록 좋습니다. 프로그램을 작성하는 관점과 공간복잡성 관점 모두 해당합니다.

변수는 메모리로 구현됩니다. 변수를 선언하면 그 변수는 어느 메모리주소로 접근할 수 있게 해줍니다.

C 언어의 자료형은 크게 정수형, 실수형, 유도형, 함수형 정도입니다. `char`는 영문자, `int`는 정수, `double`은 실수를 다루기 위해 있습니다. 이정도부터 알아야 합니다.

<!-- @todo: 직접 표 작성하기 -->

컴퓨터는 덧셈과 뺄셈을 구현할 때 하드웨어 구조를 재사용합니다. 덧셈으로 숫자를 더하고 뺄셈도 덧셈 동작방식으로 구현합니다. 컴퓨터는 보수를 더하는 것으로 뺄셈을 구현합니다. 보수란 A라는 숫자가 B가 되기 위해 필요한 수입니다.

$$
\begin{align}

9 - 6 = 3

\end{align}
$$

이것은 일반적인 뺄셈법입니다.

$$
\begin{align}

9 + 3 = 13 = 13 - 10 = 3

\end{align}
$$

컴퓨터는 6이 10이 되기 위해 필요한 4(보수)를 더하는 방법으로 뺄셈을 구현합니다. 그리고 자릿수를 초과한 부분은 사라집니다. 그렇게 3을 구합니다. 즉 오버플로우 언더플로우를 활용합니다.

이것은 이진법으로도 동일하게 적용할 수 있습니다.

1의 보수는 모든 비트를 뒤집는다고 생각하면 됩니다. 2의 보수는 거기에 1을 더하면 됩니다.

$$
\begin{align}

00000001_{(2)}

\end{align}
$$

1에서 시작합니다.

$$
\begin{align}

11111110_{(2)}

\end{align}
$$

숫자 1에 대한 1의 보수입니다.

$$
\begin{align}

11111111_{(2)}

\end{align}
$$

숫자 1에 대한 2의 보수입니다.

여기 있는 2의 보수와 1을 더하면 -1을 빼는 것과 동일한 결과를 같습니다. 그리고 회로판은 덧셈 회로판만 활용하게 됩니다.

절댓값을 더하고 자리올림을 무시함으로 결과적으로 뺄셈을 구현합니다.

부호비트, 자료비트, 표현 범위는 직관적입니다.

부호비트는 MSB(최상위 비트, most significant bit) 보통 가장 왼쪽에 표시합니다. 그리고 남는 부분이 자료비트입니다. 0은 양수 1은 음수를 표현할 수 있게 됩니다.

예를 들어 8비트에 부호 비트를 포함하면 -128($-1 \cdot 2^{7}$)부터 127(2^{7} - 1)까지 표현할 수 있는 범위가 됩니다. 만약에 부호가 없다면 즉 `unsigned`라면 0부터 255($2^{8}-1$)까지 표현할 수 있게 됩니다. (255까지면 보통 컬러를 표현할 때 자주 봤을 것입니다. 컬러는 금융대출처럼 음수를 표현할 필요가 없습니다.)

표현범위를 초과하면 숫자 잘림 현상이 발생해 계산이 틀릴 가능성이 높습니다. 그래서 큰 수를 다룰 때는 주의해야 합니다.

```c
자료형 변수이름 = 초깃값;
int nDate = 10;
```

위 형태를 기억하기 바랍니다. 변수는 식별자입니다.

변수선언에 규칙이 있습니다.

- 영문 대소문자, `_`, 숫자로 만들어야 합니다.
- 첫글자가 숫자가 될 수 없습니다.
- 중간에 공백을 갖을 수 없습니다.
- 예약어로 변수를 사용할 수 없습니다.

| 예약어   | 설명                              | 예시 코드                                    |
| -------- | --------------------------------- | -------------------------------------------- |
| auto     | 지역 변수를 자동으로 저장         | `auto int num = 10;`                         |
| break    | switch 문이나 반복문을 종료       | `break;`                                     |
| case     | switch 문에서 조건을 지정         | `switch(num) { case 1: }`                    |
| char     | 문자 데이터 타입                  | `char ch = 'A';`                             |
| const    | 상수를 정의                       | `const int MAX = 100;`                       |
| continue | 반복문의 현재 반복을 건너뛰기     | `continue;`                                  |
| default  | switch 문에서 기본 동작 정의      | `default: break;`                            |
| do       | do-while 반복문 시작              | `do { } while (condition);`                  |
| double   | 더블형 실수 데이터 타입           | `double pi = 3.14159;`                       |
| else     | if 문의 다른 조건 정의            | `if (condition) { } else { }`                |
| enum     | 열거형 타입 정의                  | `enum Day { MON, TUE };`                     |
| extern   | 외부 변수 또는 함수 선언          | `extern int count;`                          |
| float    | 실수 데이터 타입                  | `float weight = 65.5;`                       |
| for      | 반복문 시작                       | `for (i = 0; i < 10; i++) { }`               |
| goto     | 레이블로 점프                     | `goto label;`                                |
| if       | 조건문 시작                       | `if (condition) { }`                         |
| int      | 정수 데이터 타입                  | `int age = 20;`                              |
| long     | 긴 정수 데이터 타입               | `long population = 5000000;`                 |
| register | 빠른 메모리 저장을 위한 변수 선언 | `register int count;`                        |
| return   | 함수 종료 및 반환                 | `return 0;`                                  |
| short    | 짧은 정수 데이터 타입             | `short num = 5;`                             |
| signed   | 부호 있는 데이터 타입 지정        | `signed int value = -10;`                    |
| sizeof   | 데이터 타입 또는 변수의 크기 반환 | `int size = sizeof(int);`                    |
| static   | 지역 변수를 정적으로 저장         | `static int count = 0;`                      |
| struct   | 구조체 타입 정의                  | `struct Person { char name[20]; int age; };` |
| switch   | 다중 분기 선택문 시작             | `switch(expression) { }`                     |
| typedef  | 사용자 정의 데이터 타입 정의      | `typedef int BOOL;`                          |
| union    | 공용체 타입 정의                  | `union Data { int i; float f; };`            |
| unsigned | 부호 없는 데이터 타입 지정        | `unsigned int score = 100;`                  |
| void     | 함수가 반환하지 않는 타입 지정    | `void func() { }`                            |
| volatile | 최적화 방지를 위한 변수 선언      | `volatile int flag;`                         |
| while    | 반복문 시작                       | `while (condition) { }`                      |

가독성 차원에서 준수해야 할 것들이 있습니다.

- 너무 긴 변수명은 안 좋습니다.
- 변수의 용도에 맞게 명명해야 합니다. 좌표를 `a`, `b`, `c`, 보단 `x`, `y`, `z`가 더 적절합니다.
- 의미없는 이름은 남용하지 않습니다.

컴퓨터에게 문자도 숫자입니다. 컴퓨터는 특정 숫자를 특정 문자로 취급하고 이것을 보고 부호체계라고 부릅니다.

ASCII는 현재 표준입니다. 과거에는 컴퓨터 제조사마다 부호체계가 다 달랐습니다.

7비트 코드 체계였습니다. 거기에 확장 비트 1개를 더해 8비트로 영어 글자 1개를 저장하고 표현했습니다.

내부적으로 컴퓨터에게 문자는 정수에 불과합니다. 문자는 C 언어에서 `char` 타입이고 부호 있는 8비트입니다.

```c
char ch  = 'A';
```

이것은 변수 선언입니다. 메모리 공간 8비트를 확보하고 선언해야 합니다.

`short`, `wchar_t`

`short`은 부호있는 16비트 정수입니다. `unsigned short`으로 선언해서 부호 없이 $0 ~ 2^{16}-1$ 형식으로 표현할 수 없습니다.

`wchar_t`은 문자하나를 저장하는 자료형입니다. 윈도우에서는 `short` 형과 같은 16비트입니다.

```c
short s = 1234;   // 정수는 보편적으로 int로 표현하지만 상수 표현할 때는 int, short을 구분하지 않음
wchar_t w = L'A'; // 문자 상수랑 다르게 앞에 L을 붙여야함
```

구분이 필요 없는 이유는 메모리의 크기와 값만 알면 항상 똑같이 처리하기 때문입니다.

`int`, `long`

`int`는 32비트 정수형입니다. 다루는 비즈니스 및 기술 도메인이 특수하지 않다면 가장 자주 사용하는 자료형입니다. 상수의 경우 접사도 없고 32비트 범위 내면 그냥 `int`입니다.

```c
#include <stdlib.h>
#include <wchar.h>

int main(void) {
	char ch = 'A';
	wchar_t wch = L'A';
	short sData = 10;
	int nData = 10;
	long lData = 10L;
	long int lnData = 10L;
	long long int llnData = 10LL;

	unsigned char byNewData = 0;
	unsigned short sNewData = 65535U;
	unsigned int uNewData = 1U;
	unsigned long int ulNewData = 1UL;
	unsigned long long int ullNewData = 1ULL;

	return EXIT_SUCCESS;
}
```

실수 자료형은 부동 소수점을 표현해야 합니다.

컴퓨터가 정수를 표현하고 비트 단위크기차이는 있어도 해석방법은 같고 숫자는 명확합니다. 정수와 정수 사이 실수는 애매합니다.

실수는 수학적으로 그 사이에 무한하게 존재할 수 있습니다. 이 무한한 표현을 메모리의 유한한 공간에 정확히 표현하기는 어렵습니다. 여기부터 컴퓨터는 일정 수준의 부동 소수점 오차를 전제로 다양한 표현을 합니다. 구체적인 내용 모두 언제가는 알기는 해야 합니다.

하지만 가장 중요한 것은 부동 소수 과련 오차입니다.

컴퓨터는 일정 수준까지만 표현을 확정하고 더 정밀한 숫자는 범위상 가까운 수로 인식하기로 했습니다.

과거에는 컴퓨터 제조사마다 부동 소수점 처리를 각각의 방식으로 했습니다. IEEE 754 스펙이 부동 소수점 표준안입니다.

소수점 표현을 위해 32비트 단정도, 64비트 배정도 및 79비트(80비트 구현) 확장 배정도 형식에 대해 표준을 규정했습니다.

| 크기    | 자료형        | 표현 범위                                                                    |
| ------- | ------------- | ---------------------------------------------------------------------------- |
| 32비트  | `float`       | $1.17 \cdot 10^{-38} ~ 3.4 \cdot 10^{38} $ 유한 자릿수 소수점 이하 6자리     |
| 64비트  | `double`      | $2.22 \cdot 10^{-308} ~ 1.79 \cdot 10^{308} $ 유한 자릿수 소수점 이하 15자리 |
| 128비트 | `long double` | `double` 이상                                                                |

`float`형은 32비트 단정도형입니다. 여기서 단정도라고 하는데 그냥 single을 의미합니다. 소수점은 6번째자리까지 표현합니다. 7번째부터 부정확한 숫자로 활용하지 말아야 합니다.

부호 비트 1비트 + 지수부 8비트 + 기수부 23비트 = 32비트

- 실제 실수형 계산작없을 많이 해야 하면 `double`형을 사용할 것을 권장합니다.
- 실수형은 부호 표기를 무조건 포함하기 때문에 앞에 U가 붙지 않습니다.
- f를 붙이지 않으면 double 형이고 상수로 취급됩니다.

`double`은 일반적인 실수를 의미합니다. 하지만 여전히 한계가 있습니다. 15번째 자리까지 유효합니다. 또 자동 상수로 형변환을 하는데 정확성 때문입니다.

부호 비트 1비트 + 지수부 11비트 + 기수부 52비트 = 64비트

```c
// DoubleRange.c
#include <float.h>
#include <stdio.h>
#include <stdlib.h>

int main(void) {

	double dData = 123.456;

	printf("%f\n", dData);
	printf("%E - %E\n", DBL_MIN, DBL_MAX);

  return EXIT_SUCCESS;
}

// 123.456000
// 2.225074E-308 - 1.797693E+308
```

첫번째 출력은 `float`로 취급해서 소수 6번째 자리까지 보여줍니다.

또 `double`의 최대 최소 범위를 보여주고 있습니다.

C 언어를 배울 사람들이 배웠다고 착각하는 것 중 하나가 문자열입니다. 문자열은 정확히 문자(배)열입니다. 여러 문자 인스턴스의 집합입니다. 문제는 본질이 배열인데 다른 자료형처럼 인스턴스가 1개라는 착각입니다. 가변길이 자료형이라 다른 자료형보다 고려할 것이 많습니다.

배열은 1개의 메모리상 존재하는 인스터가 아니라 여러 메모리 인스턴스를 하나로 묶어둔 것입니다. 개별 인스턴스는 이름이 아니라 주소에 이름이 부여된 것입니다.

```c
#include <stdlib.h>

int main(void) {

  char ch1 = 'A', ch2 = 'B', ch3 = 'C';
  char szData[4] = {'A', 'B', 'C'};
  char szNewData[4] = {"ABC"};

  return EXIT_SUCCESS;
}
```

`ch1`, `ch2`, `ch3`는 3개의 개별문자 상수입니다.

`szData`는 4개의 문자를 담은 배열입니다. 인스턴스 4개를 갖습니다. 또 초깃값(`A`, `B`, `C`)도 명시하고 있습니다. 명시하지 않으면 0이 됩니다.

`szData`는 `szNewData`랑 의미상 같습니다. 물론 메모리 주소는 다릅니다.

왜 4로 선언했는데 3개만 활용하는가? 둘다 문자열 끝에 null 문자(`\0`)가 들어갑니다. 즉 null 문자를 포함해야 합니다. 그래야 문제열이 끝났음을 알려 줄 수 있습니다.

프로그램 소스코드는 그자체로 문서입니다. 사람이 읽기 때문에 가독성이 중요합니다. 가독성 좋은 코드야 말로 진정한 기본기입니다. 또 이름짓기와 주석이야 말로 기본 중 기본입니다.

이름은 다르게 부르면 식별자라고 부르기도 합니다. 변수는 코드의 식별자 ID의 역할을 합니다. 이름으로 목적을 알수 있게 작성해야 합니다. 이름 짓기를 할 때 변수의 목적을 다시 생각하면서 작성하도록 합니다.

주석은 실행하지 않습니다. 개발자의 메모에 불과합니다. 하지만 상당히 중요합니다. 코드만으로 설명이 가능하기는 해야 하지만 그렇지 못한 경우도 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

/*
 * 이 구간의 코드는 모두 주석
 */

int main(void) {

	// 결과를 저장하는 변수
	int nResult = 10;
	char ch = 'A'; // 사용자 입력

	// printf("Hello, World!\n");

	return EXIT_SUCCESS;
}
```

소스코드는 회사 문서입니다. 가독성을 위한 노력이 중요합니다.

1. 변수는 프로그램이 실행하면서 값이 바뀔 수 있는 값을 의미
2. 자료형은 데이터를 표현하는 형식
3. 자료형, 변수명, 초깃값
4. `10`은 음수 부호를 갖을 수 있게 부호 비트 1비트와 자료 비트 7비트를 할당합니다. 하지만 `10U`은 부호가 없음으로 음수표현 지원 없이 자료 비트 8비트로 할당합니다.
5. ASCII
6. `&nData`은 `nData` 변수의 주소를 의미합니다. 즉 우변(RValue 만 있어야 할 자리)에서 좌변(LValue)의 값인 주소를 접근하는 표현입니다.

## Chapter 03 표준 입출력 도구

UX 혹은 HCI는 결국에는 프로그래머 입장에서는 입출력을 기반으로 합니다.

사용자의 입력을 얼마나 의도에 맞게 정확히 전달하는가가 관건입니다.

### 문자 입출력

영문 한 글자는 `char`입니다. 내부적으로 8비트 정수입니다. 8비트 정수라 덧셈 뺄셈도 가능합니다. 이것을 다시 기억하도록 합니다.

`int getchar()`는 인자가 없습니다. 표준입력장치 버퍼 메모리에서 한글자를 읽어오는 함수입니다. 버퍼 메모리가 비어있으면 유저에게 입력을 받아 채운 후 반환합니다. 주의할 점은 `char`을 반환할 것처럼 생겼는데 `int`를 반환합니다. 크기 차이를 제외하면 결국 모두 정수입니다.

`int putchar(int c)` 표준 출력장치인 콘솔에서 영문 한 글자를 출력합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;

  ch = getchar();

  putchar(ch);
  putchar('Z');

  return EXIT_SUCCESS;
}
// h
// hZ%
```

`getchar`는 입력을 받기위해 1번 대기 했습니다. 그리고 `putchar`는 출력에 사용되었습니다. 기존에 입력 받은 것을 출력하고 또 `Z`앞에 저장한 문자열을 출력했습니다.

여기서 `ch` 처음 초기화 했을 때 값은 사라지고 사용자의 입력을 받은 값을 저장 혹은 복사하게 됩니다.

대부분의 함수는 인자로 대입하면 변수 그자체가 아니라 변수의 정보를 매개변수로 전달하게 됩니다.

```c
#include <stdio.h>
#include <stdlib.h>
/*#include <conio.h>*/
/*#include <curses.h>*/

int main(void) {
  char ch = 0;
  printf("아무 키나 누르면 다음으로 넘어갑니다. \n");

	/*ch = getch();*/
  printf("입력한 키는 ");
  putchar(ch);
  printf("입니다.\n");
  return EXIT_SUCCESS;
}
```

위 코드는 동작하지 않을 것입니다. 먼저 `<conio.h>`는 윈도우에서만 제공합니다. 맥에서는 `<curses.h>`을 따로 설치해야 합니다.

[why does this error occur: 'conio.h' file not found](https://stackoverflow.com/questions/67320428/why-does-this-error-occur-conio-h-file-not-found)

위를 보면 그렇습니다.

```sh
brew install ncurses # curses 파일 설치
```

`_getch()` 혹은 `_getche()` 함수는 Non-buffered I/O 합니다. 버퍼를 안 거치고 전달합니다. 어떤 키라도 입력이 있으면 즉시 반환합니다.

### 문자열 입출력

문자열은 문자의 배열입니다. `H`, `e`, `l`, `l`, `o`, `\0` 문자들을 묶는 것이 문자열입니다. 이런 표현은 일일이 입력하기 귀찮습니다. 그래서 `"Hello"`라고 표현합니다. 이렇게 표현해도 문자의 배열로 취급합니다.

문자를 다루는 것과 문자열을 다루는 것의 차이는 한 인스턴스(`char`)를 다루는 것과 인스턴스(`char[n]`)을 묶어서 다루는 것의 차이입니다.

배열의 이름은 일반 변수의 이름과 달리 메모리의 주소에 부여한 식별자입니다. `char szName[32]`은 `char`이 32개인 배열입니다. `szName`은 주소를 접근할 식별자입니다.

배열의 이름은 주소입니다.

주소를 저장하는 변수는 포인터입니다. 배열을 활용하면 포인터도 같이 활용하는 경우가 많습니다.

`char *gets(char *buffer)` / `int puts(const char *string)` 함수는 문자열을 입출력 해주는 함수입니다.

`gets()`는 버퍼 즉 입력받은 문자를 저장할 메모리 주소를 인자로 받습니다. 반환입니다. 에러는 `NULL` 성공은 받은 메모리 주소입니다. 목적은 표준입력장치의 문자열을 받는 함수입니다.

`puts()`는 출력할 문자열이 저장된 메모리의 주소입니다. 반환입니다. 정상이면 음수가 아닌 정수입니다. 에러는 `EOF`입니다. 표준출력장치에 문자열을 출력하는 것이 목적입니다.

`getchar()`, `putchar()`과 다릅니다. 인자가 포인터입니다. `gets()`는 저장될 메모리 주소입니다. `puts()`는 출력할 메모리 주소를 접근하고 화면에 출력합니다.

다음은 가장 전형적인 문자열 입출력 예지입니다. SDL 검사에 주의하기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_BUF_SIZE 32

int main(void) {
  // char 변수 32개가 한 덩어리로 묶인 배열 선언
  char szName[MAX_BUF_SIZE] = {0};

  // 사용자로부터 이름(문자열)을 입력받는다.
  printf("이름을 입력하세요: ");
  /*
   * 사용자가 입력한 문자들을 문자 배열에 모두 저장
   * gets은 보안 결함이 있습니다.
   * gets_s은 윈도우 전용입니다.
   */
  fgets(szName, MAX_BUF_SIZE, stdin);

  // 배열에 저장된 이름을 화면에 출력
  printf("당신의 이름은 ");
  puts(szName);
  puts("입니다.");

  return EXIT_SUCCESS;
}
```

과거에 쓰던 `gets()` 함수는 키보드 입력 버퍼를 검사합니다. 버퍼가 비어있으면 사용자의 문자열을 입력받아 저장합니다. `gets()`는 인자가 1개입니다. 이 인자는 버퍼에서 저장된 문자열을 인자(`szName`)에 복사합니다. 이미 버퍼에 정보가 있었다면 별도로 사용자 입력을 안 받습니다.

`gets` 함수는 보안 결함을 갖고 있습니다. 버퍼로 받은 문자열의 메모리 주소와 문자열이 저장될 메모리의 바이트 단위 크기를 인자로 넣고 제어하는데 문제가 있습니다. 책의 예제는 `gets` 대신에 `gets_s`를 권장했습니다. 저는 `fgets`를 사용했습니다.

`gets`의 문제는 버퍼 오버플로우로 버퍼 오버런 공격이 가능합니다. 이 보안 취약점 등급은 심각한 수준입니다. 허가 받지 않은 원격 사용자가 관리자 권한을 얻는 사고입니다.

```c
#include <stdio.h>
#include <stdlib.h>


int main(void) {
  // char 변수 32개가 한 덩어리로 묶인 배열 선언
  char szName[32] = {0};

  // 사용자로부터 이름(문자열)을 입력받는다.
  printf("이름을 입력하세요: ");
  /*
   * 사용자가 입력한 문자들을 문자 배열에 모두 저장
   * gets은 보안 결함이 있습니다.
   * gets_s은 윈도우 전용입니다.
   */
  fgets(szName, sizeof(szName), stdin);

  // 배열에 저장된 이름을 화면에 출력
  printf("당신의 이름은 ");
  puts(szName);
  puts("입니다.");

  return EXIT_SUCCESS;
}
```

도서의 예제는 `sizeof`를 알려줍니다. 보안 결함이 될 가능성이 있는 행위 즉 배열의 경계를 넘어서 사용이 허가된 메모리 이상을 사용하는 경우입니다. 이 경우 예외를 발생시킵니다. 프로그램이 비정상 종료되는 것 같아도 해킹을 방어할 수 있게 됩니다.

`sizeof`는 메모리의 크기를 측정하는 연사자입니다. 지금은 `char` 32 개를 바이트 단위로 계산하는 경우입니다. `char`는 1 바이트라 총 32바이트에 해당합니다.

`printf`는 콘솔 기반으로 정보 출력할 때 가장 많이 사용하는 함수 중 하나입니다. 문자, 숫자(정수, 실수), 문자열 모두 출력이 가능합니다.

```c
int printf(const char *format [, argument]...);
```

`printf` 시그니쳐를 보면 제대로 활용을 위해 형식 문자열(format string)을 이해해야 합니다. 형식 문자열은 문자열, 형식 문자, 이스케이프 시퀀스로 구성됩니다.

시그니쳐를 잘 보면 가변인자입니다. 인자의 개수가 형식 문자의 개수와 일치해야 합니다.

형식 문자는 출력할 정보의 자료형과 밀접하게 관련되어 있습니다. 형식문자열과 인자를 조합해서 최종 문자열을 만드는 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 10;

  /* 문자상수를 화면에 출력 */
  putchar('B');

  /* '\n'은 개행문자이므로 알파벳 문자가 화면에 보이지 않을 것 */
  putchar('\n');

  /* 개행 문자 출력 이후 A와 개행문제를 출력 */
  printf("%c\n", 'A');

  /* %d라는 형식 문자에 맞춰 변수 x에 담긴 정보 출력 */
  printf("x는 %d 입니다.\n", x);

  return EXIT_SUCCESS;
}
```

`printf`를 사용하면 각종 안내 문구를 조합하고 출력이 가능합니다. `putchar`, `puts`로는 언젠가 비슷한 결과를 만들어도 `int`를 출력할 수 없습니다.

`%d`은 10진수(decimal)를 의미합니다. 단순하지만 자주 사용합니다.

| 형식 문자 | 자료형             | 설명                                               |
| --------- | ------------------ | -------------------------------------------------- |
| `%c`      | `char`             | 문자를 출력 및 입력할 때 사용                      |
| `%d`      | `int`              | 정수를 출력 및 입력할 때 사용                      |
| `%o`      | `int`              | 정수를 8진수로 출력할 때 사용                      |
| `%u`      | `unsigned int`     | 부호 없는 정수를 출력 및 입력할 때 사용            |
| `%x`      |                    | 정수를 16진수로 출력할 때 사용                     |
| `%e`      | `float or double`  | 지수 형식의 실수를 출력할 때 사용                  |
| `%f`      | `float`            | 실수를 출력 및 입력할 때 사용                      |
| `%g`      | `float or double`  | 값에 따라 `%f` 또는 `%e`를 선택하여 출력할 때 사용 |
| `%p`      | `void`             | 포인터의 주소 값을 출력할 때 사용                  |
| `%s`      | `char[]` or `char` | 문자열을 출력 및 입력할 때 사용                    |
| `%a`      | `float or double`  | 16진수 부동소수점을 출력할 때 사용                 |
| `%n`      | `int`              | 출력된 문자의 개수를 저장할 변수를 지정할 때 사용  |

`%s`는 문자열 즉 메모리 주소를 받아 출력하기만 합니다. 자료형 정보와 출력이 올바르게 일치하지 않으면 컴파일러는 어떤 경고도 안해줍니다.

`%`을 출력하고 싶은 경우 `%%`으로 이스케이프 해야 합니다.

문자와 정수 출력

C 언어 정수 표시에 사용하는 자료형은 `char`, `short`, `int`, `long`, `long long int`입니다. `char`, `int`은 `%c`, `%d`으로 나타냅니다.

ASCII 코드 영문 `'A'`는 10진수로 65이고 16진수로 `0x41`입니다. 65는 10진수 정수이고 `int`입니다. `'A'`은 `char`이고 상수입니다. `'A'`의 본질은 10진수 65라 정수인가? 반대로 65가 `char`가 아닌가?

`char`와 `int`는 부호있는 정수라는 점이 같습니다. 길이가 8비트, 32비트만 다릅니다. `%c`과 `%d` 모두 `int` 다루는 것을 원칙으로 합니다. 그냥 `char`가 크기를 작게 다룰 뿐입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // 문자상수를 ASCII 코드 문자형으로 출력
  printf("%c\n", 'A');      // A
  // 문자 'A'의 ASCII 코드값(65)에 1을 더한 값을 문자로 출력
  printf("%c\n", 'A' + 1);  // B
  // 문자상수를 ASCII 코드 문자형으로 출력
  printf("%c\n", 'C');      // C

  // 문자 'A'의 ASCII 코드값을 10진수(%d)로 출력
  printf("%d\n", 'A');      // 65
  // 문자 'A'의 ASCII 코드값에 1을 더하고 10진수(%d)로 출력
  printf("%d\n", 'A' + 1);  // 66
  // 문자상수를 ASCII 코드값을 10진수(%d)로 출력
  printf("%d\n", 'C');      // 67

  // 10진수(정수)를 문자(ASCII)로 출력
  printf("%c\n", 65);       // A
  printf("%c\n", 65 + 1);   // B
  printf("%c\n", 67);       // C

  return EXIT_SUCCESS;
}
```

본질은 `char`, `int`가 모두 부호 있는 정수입니다. 정보의 본질은 달라지는 것이 아니라 출력 형식만 변경하는 것으로 다른 정보로 인식합니다.

`%d` 부호가 있으면 `char`, `short`, `int` 모두 숫자로 출력합니다.

`%u`은 부호가 없으면 32비트로 표시할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // int형 상수 10을 10진 부호가 있는 정수형식으로 출력
	printf("%d\n", 10);
	// 10을 '부호가 없는' 정수형식으로 출력
	printf("%u\n", 10);
	// unsigned int 상수 10U을 %d 형식으로 출력
	printf("%d\n", 10U);
	// unsigned int 상수 10U을 %u 형식으로 출력
	printf("%u\n", 10U);

	// 부호가 있는 32비트 정수로 표현할 수 있는 가장 큰 수
	printf("%d\n", 2147483647);
	// 부호가 있는 32비트 정수로 표현할 수 있는 '범위를 넘어선' 정수를 출력
	printf("%d\n", 2147483648);
	// 부호가 있는 32비트로 정상 출력
	printf("%u\n", 2147483649);

	// -1을 부호있는 10진수로 출력
	printf("%d\n", -1);
	// 같은 값(-1)이지만 부호가 없는 형식으로는 전혀 다른 값 출력
	printf("%u\n", -1);

  return EXIT_SUCCESS;
}
```

이렇게 작성하면 컴파일부터 막힙니다. 비트 오버플로우 비트 언더플로우 문제를 컴파일러가 감지합니다.

32비트 단위로 표현할 수 있는 것을 넘습니다.

부호가 있으면 너무 작습니다. 하지만 부호가 없으면 43억 미만입니다. 물론 통계 프로그램을 작성하는 지금시대에도 작은 단위입니다.

더큰 자료형을 다룰 때는 `long long int`로 해결해야 합니다.

$$
\begin{align}

-2^{63} ~ 2^{63} - 1

\end{align}
$$

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // 부호 있는 64비트 변수 정의
  long long int lldData = 4294967295LL;

  // 64비트 정보를 32비트 문자로 출력
  printf("d\n", lldData);
  printf("u\n", lldData);

  // 32비트로 표현할 수 없는 범위의 정보 출력
  printf("%u\n", lldData + 1);
  printf("%u\n", lldData + 2);
  printf("%u\n", lldData + 3);

  // 64비트 정보를 64비트 형식 문자(%lld)로 출력
  printf("%lld\n", lldData + 1);
  printf("%lld\n", lldData + 2);
  printf("%lld\n", lldData + 3);

  return EXIT_SUCCESS;
}
```

역시나 컴파일에러가 또 발생할 것입니다.

`%ld`와 `%lld`의 차이는 비트 응용프로그램의 차이입니다. 32비트로 응용 프로그램을 운용하는지 64비트로 응용 프로그램을 운용하는지는 다릅니다.

10억 단위 정수를 다룰 때는 `long long int`와 `%lld`를 활용할 것을 권장합니다.

참고로 형식문자는 자릿수, 폭 제한, 왼쪽 정렬 처럼 form을 제어하는 기능을 갖고 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  printf("%d\n", 1234);
  printf("%d, %d\n", 1234, -5678);
  // 부호를 붙여 출력
  // +을 출력하는 것은 아님
  printf("%+d, %+d\n", 1234, -5678);

  // 정수를 8자리로 맞추고 오른쪽 정렬
  printf("%8d\n", 1234);
  // 오른쪽 정렬하고 공백은 0으로 채움
  printf("%08d\n", 1234);
  // 왼쪽 정렬
  printf("%-8d\n", 1234);

  return EXIT_SUCCESS;
}
```

출력을 포맷팅할 수 있습니다.

실수와 지수 출력

자료형에 부동소수점 표현도 다루었는데 출력은 안다루는가? 다룹니다. 컴퓨터의 특성은 우리가 이론적으로만 알고 있는 것입니다.

정수는 부호를 구분했습니다. 실수는 실수 출력과 지수출력을 구별할 수 있습니다. 정수처럼 표현 범위가 달라지거나 부호개념이 사라지는 경우는 없습니다. `%f`, `%e`만 다를 뿐입니다.

`F`붙으면 `float` 실수형이고 없으면 `double`입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // 실수 자료형의 메모리 사이즈 출력
  printf("%d\n", sizeof(123.456F)); // 4
  printf("%d\n", sizeof(123.456));  // 8

  // float 형을 실수형으로 출력
  printf("%f\n", 123.456F); // 123.456001

  // double형을 실수형으로 출력
  printf("%f\n", 123.456);  // 123.456000
  printf("%lf\n", 123.456); // 123.456000

  return EXIT_SUCCESS;
}
```

`%f`는 `float`이고 `%lf`는 `double`에 해당하는 출력 형식입니다. `printf` 함수에서는 구분을 안해도 괜찮습니다.

하지만 `scanf`는 구분해야 합니다. `float`형이라도 부동 소수점 오차는 있습니다. 이 실수단위 연산 혹은 출력에서 부동소수점 오차는 문제입니다.

형식 문자와 가변인자를 잘못연결하는 실수가 없어야 합니다. 실수 출력은 문법만 다룰 것이 아니라 부동소수점 오차도 같이 논해야합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  printf("%f\n", 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F);  // 4.999998
  return EXIT_SUCCESS;
}
```

심각한 오류입니다. 0.000002이 부족합니다. 실수 연산은 가능하면 `float`보단 `double`을 활용할 것을 권장합니다. 15번째 정보까지 신뢰할 수 있습니다.

`%f`를 출력할 때 주의할 점은 소수점을 표시하는 것입니다. 더 많이 혹은 덜 표시할 수 있습니다. 자동으로 반올림할지도 모릅니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  double dData = 123.456;
  printf("%f, %f\n", dData, -123.456); /*123.456000, -123.456000*/

  // 소수점 반올림
  printf("%.1f\n", dData); /*123.5*/
  printf("%.2f\n", dData); /*123.46*/
  printf("%.3f\n", dData); /*123.456*/

  printf("%8d\n", dData);  // 컴파일 에러

  // 소수점을 포함해 12자리출력 소수점 4번째에서 반올림하고 3번째자리까지 출력
  printf("%12.3f\n", dData);  /*     123.456*/
  printf("%012.3f\n", dData); /*00000123.456*/

  return EXIT_SUCCESS;
}
```

`%(전체_자리).(소수점_최대길이)f`

위 형식을 따릅니다. 최대길이를 벗어나면 자동으로 반올림처리합니다. 이것은 개발자의 주의해야 합니다.

실수를 다룰 때 다양한 전략이 있는데 먼저 정책으로 정수를 먼저 활용하게 만드는 것입니다. 성적표의 평균을 계산하는 것보다 총점을 합산하는 것이 더 쉬울지도 모릅니다. 현실에서는 시키는데로 해야 하기 때문에 무조건 평균을 활용해야 하면 다른 전략은 곱셈으로 정수단위가 되게 만들어서 계산을 처리하면 됩니다. 단지 성능문제가 발생할 것이 문제입니다.

### `scanf` 함수

```c
int scanf(const char *format [, argument]...);
```

형식 문자열에 맞추어, 표준입력장치(`stdin`)로부터 정보를 읽어들이는 함수입니다. 가변인자는 사용자가 입력한 값이 저장될 메모리의 주소들입니다.

`format`: 형식 문자열이 저장된 메모리 주소
`[, argument]`: 형식 문자열에 대응하는 가변인자

인력할 문자열의 개수를 반환합니다. 유효하게 입력했는지 확인할 때 활용해볼 수 있습니다.

주의해야할 점은 형식 문자에 대응하는 가변인자는 모두 주소입니다.

`scanf` 함수의 가변인자는 모두 메모리 주소가 되어야 합니다. 이것은 `gets` 함수와 동일합니다. 매개변수로 주소를 대입하는 방식은 C 언어에서 자주 등장합니다.

사용자 나이(정수)를 받고 출력하는 예제입니다. 또 보안문제도 있을 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nAge = 0;
  printf("나이를 입력하세요. :");
  scanf("%d", &nAge);
  printf("당신의 나이는 %d세 입니다.\n", nAge);
  return EXIT_SUCCESS;
}

// 정상적인 경우 (정수 입력)
// 나이를 입력하세요. :10
// 당신의 나이는 10세 입니다.
// 비정상적인 경우 (문자열 입력)
// 나이를 입력하세요. :asdf
// 당신의 나이는 0세 입니다.
```

사용자의 입력을 해석할 수 없고 전달된 주소로 식별되는 메모리를 담아주지 않습니다.

오픈북으로 문제를 풀었습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int age = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d", &age);
  while (getchar() != '\n') {
    continue;
  }

  char name[32] = {0};
  printf("\n이름을 입력하세요. : ");
  scanf("%s", name);
  while (getchar() != '\n') {
    continue;
  }

  printf("\n 당신의 나이는 %d살이고 이름은 \'%s\'입니다.\n", age, name);

  return EXIT_SUCCESS;
}
```

문제 풀이해설을 설명하기 전에 풀이 과정을 보여줍니다.

여기서 주의할 점은 기본 입출력이 불가능하면 아무것도 할 수 없습니다.

기본 입출력은 암기라도 해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("%d", nInput);

  printf("Input : %d\n", nInput);
  return EXIT_SUCCESS;
}
```

저는 작성할 때부터 린트가 주소를 넣으라고 알려줬습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("%d\n", &nInput);

  printf("%d\n", nInput);
  return EXIT_SUCCESS;
}
```

여기서 문제는 문자를 입력해야 입력이 종료 됩니다.

`getchar`, `gets`, `scanf` 세 함수 모두 키보드 입력을 완료하기 위해 엔터키를 입력 받아야 합니다. 하지만 `scanf`는 함수의 형식 문자열로 개행문자(`\n`)를 넣는 것은 잘못된 것입니다. 입력을 완료하기 위해 개행문자와 문자가 요구하는 개행문자는 구분할 수 없습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("Input : %d", &nInput);

  printf("Input : %d\n", nInput);
  return EXIT_SUCCESS;
}
```

여기서 입력하면 항상 `0`이 될 것입니다. 하지만 `Input : `을 앞에 붙이면 숫자를 받을 것입니다.

형식문자열로 표준입력에서 받는데 사용자가 입력을 알 수 있게 하는 것이 아닙니다. `printf`랑 `scanf` 함수를 혼동하면 큰일납니다.

지금까지는 입력을 1개만 입력받고자 했습니다. 이번에는 2개를 입력 받아보겠습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0, y = 0;
	printf("두 정수를 입력하세요. : ");

  scanf("%d%d", &x, &y);

  printf("두 수의 합은 %d입니다.\n", x + y);
  return EXIT_SUCCESS;
}
```

공백으로 구분해서 숫자 2개 입력하면 잘 동작할 것입니다. 붙여서 입력하면 이해할 것이라고 착각하는데 아닙니다.

띄어쓰기는 화이트 스페이스(탭, 개행문제, 스페이스바)에 해당합니다. 눈에 안보이고 존재하는 문자입니다. 고려해서 문자열 길이에 포함해야 합니다.

`Hello\n`은 개행문자를 포함해서 6개입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;
  scanf("%c", &ch);
  printf("입력한 문자는 %c 입니다.\n", ch);
  return EXIT_SUCCESS;
}
```

위 코드는 보안취약점을 갖고 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[32] = { 0 };
  scanf("%s", szBuffer);
  printf("%s\n", szBuffer);
  return EXIT_SUCCESS;
}
```

하지만 한계가 있습니다. `%s`은 공백 문자를 포함해서 입력받을 수 없습니다. 뭐 여러개받는 것도 전략이지만 효율적이지 않을 것 같습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBufferLeft[32] = { 0 };
  char szBufferRight[32] = { 0 };
  scanf("%s%s", szBufferLeft, szBufferRight);
  printf("%s %s\n", szBufferLeft, szBufferRight);
  return EXIT_SUCCESS;
}
```

이렇게 여러개 받을 수 있게 변수를 추가합니다. 문제는 변수를 1억개를 추가할 것인가?

공백을 포함하고 싶으면 `gets`를 활용합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szName[32] = {0};
  int nAge = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d", &nAge);

  printf("이름을 입력하세요. : ");
  gets(szName);

  printf("%d, %s\n", nAge, szName);
  return EXIT_SUCCESS;
}
```

보안 문제를 여전히 갖고 있습니다. 나이를 문자로 입력하면 버퍼에 남아있고 `gets`가 접근하는 문제가 있습니다. 그래서 이름 입력을 못하게 됩니다.

참고로 gcc는 컴파일을 못하게 막습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szName[32] = {0};
  int nAge = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d%*c", &nAge);

  printf("이름을 입력하세요. : ");
  fgets(szName, sizeof(szName), stdin);

  printf("%d %s\n", nAge, szName);
  return EXIT_SUCCESS;
}
```

위는 조금더 안전하게 처리하는 방법입니다.

`%*c`이 나중에 추가된 형식 문자입니다. 문자 하나를 입력 버퍼로 읽고 그 후에 버린다는 의미입니다. 그리고 이 방법은 다양한 운영체제 호환성 문제가 없습니다.

동작하는 원리가 `scanf`는 엔터를 입력하면서 개행문자를 보고 입력의 종료로 판단하는데 숫자는 꺼내도 개행문자는 계속 갖고 있습니다. 하지만 `%*c`은 문자에 속한 개행문자를 버리겠다는 의미로 버퍼는 비워지고 `fgets`로 문자열을 입력할 수 있게 됩니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int age = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d%*c", &age);

  char name[32] = {0};
  printf("\n이름을 입력하세요. : ");
  fgets(name, sizeof(name), stdin);

  printf("\n 당신의 나이는 %d살이고 이름은 \'%s\'입니다.\n", age, name);

  return EXIT_SUCCESS;
}
```

정확한 정답은 위와 같아집니다.

1. `getchar()` 함수를 호출하고 사용자 입력을 받는데 4글자 이상 입력 받고 그 중에 두번째 글자만 출력합니다.

요구사항은 3개입니다. 글자 4개이상 받아야 합니다. 그리고 두번째 글자를 접근합니다. 접근할 글자를 출력합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int count = 0;
	char buf = 0;
	printf("입력 : ");
  while (buf != '\n') {
		buf = getchar();
    count += 1;
		if (count == 2) {
			printf("출력 : %c\n", buf);
		}
  }
  if (count < 4) {
    printf("4개 이하 문자를 입력했습니다.\n");
  }
  return EXIT_SUCCESS;
}
```

2. `getchar` 함수와 `_getch` 함수가 내부적으로 다른 점은 무엇이 다른가?

`getchar` 함수는 Buffer IO를 하고 `_getch` 함수는 Non-Buffer IO를 합니다. 버퍼 메모리를 직접 접근하는 것과 입력 여부에 대한 감지가 다릅니다.

3. `gets` 함수는 보안결함이 있습니다. 이 함수를 대체할 수 있는 것들은 무엇인가?

`fgets`로 대체가 가능합니다.

4. 만일 부호가 있는 10진 정수형 표현할 수 있는 가장 큰 양수 범위를 1넘어서면 컴퓨터는 이를 어떤 숫자로 인식하는지 기술하시오.

```c
#include <stdio.h>

int main(void) {
  char num1 = 127;
  char num2 = 128;
  printf("%d\n", num1); // 127
  printf("%d\n", num2); // -128
  return 0;
}
```

위처럼 동작하게 되는 이유입니다.

편의를 위해 8비트 단위로 설명하겠습니다. 8비트면 0부터 2의 8제곱에서 1이 부족한 127까지입니다. 하지만 부호 비트가 있으면 최대 양수는 127까지입니다.

$$
\begin{align}

01111111_{(2)}

\end{align}
$$

127을 이진수로 표현하면 위와 같습니다. 여기서 1을 더하면 오버플로우 현상이 발생해서 양수가 음수가 됩니다.

$$
\begin{align}

10000000_{(2)}

\end{align}
$$

이 오버플로우 현상은 -1이 아닙니다. 가장 낮은 -128입니다. 넘겨진 숫자는 버려지고 회전하게 됩니다. 숫자를 원으로 생각하면 직관적일 것입니다.

5. 부호가 없는 10진 정수 형식과 부호가 있는 10진 정수 형식을 출력하기에 적절한 형식문자는 각각 무엇인가?

```c
printf("부호 없는 10진 정수 %u", 10U);
printf("부호 있는 10진 정수 %d", 10);
```

6. `123.45` 자료형은 무엇인가? 그리고 이 값을 출력하기에 적절한 형식 문자는 무엇인가?

자료형은 `double`입니다.

```c
printf("%d\n", 123.45);
```

7. 형식 문자 `%012.3F`가 의미하는 것은 무엇인지 기술하시오.

총 12자리가 있는 실수표현에서 소수점 3째자리까지 보여주고 4째는 반올립처리하고 왼쪽 정렬을 하는데 0으로 채웁니다.

8. 배열에 담긴 문자열을 출력하려 합니다. 적절한 형식 문자는 무엇인가?

```c
printf("%s\n", i);
```

문자열은 `%s`으로 출력하는데 이것을 뭐 순회해서 출력하는 것을 묻는지 모르겠습니다.

9. `scanf` 함수로 정수를 입력받은 후, 입력 버퍼에 남은 개행문자를 제거하려합니다. 전략은 무엇이 있는가?

```c
scanf("%d%*c", &num);

while (getchar() != '\n') {}
```

10. 만일 `nInput`이 정수형 변수라면 다음 코드는 무엇이 잘못되었는가?

```c
scanf("%d", nInput);
```

두번째 인자로 주소를 대입해야 하는데 값을 대입하고 있습니다.

11. `scanf` 함수로 `double`로 입력받으려고 합니다. 적절한 형식문자는 무엇인가?

```c
double num1 = 123.456;
scanf("%lf\n", &num1);
```

이렇게 처리합니다.

## Chapter 04 연산자 - 기본

자료형과 변수의 저장은 메모리 중 RAM와 관련되어 있습니다. 지금부터 다룰 연산자는 메모리가 아닌 CPU의 작업과 직결됩니다.

프로그래밍의 본격적인 부분은 여기서부터입니다.

연산자와 피연산자 그리고 항입니다. `3 + 4`의 항은 총 3개입니다. 피연산자 3, 4 연산자 `+`으로 모두 개입니다.

피연산자 항만 감안하면 2개입니다. 주로 피연산자를 칭하기 때문에 `+`은 2개의 피연산자가 필요해서 2항 연산자라고 부릅니다.

C 언어는 단항 연산자부터 3항 연산자까지 있습니다.

| 우선순위 | 연산자                                                             | 결합성 |
| -------- | ------------------------------------------------------------------ | ------ |
| 1        | `()`, `.`,`[]`, `->`                                               | →      |
| 2        | `*`, `&`, `!` `++`, `--`, `(datatype)`, `sizeof - `,               | ←      |
| 3        | `*`, `%`, `/`                                                      | →      |
| 4        | `+`, `-`                                                           | →      |
| 5        | `<<`, `>>`                                                         | →      |
| 6        | `<`, `<=`, `>`, `>=`                                               | →      |
| 7        | `==`, `!=`                                                         | →      |
| 8        | `&`                                                                | →      |
| 9        | `^`                                                                | →      |
| 10       | `\|`                                                               | →      |
| 11       | `&&`                                                               | →      |
| 12       | `\|\|`                                                             | →      |
| 13       | `?:`                                                               | ←      |
| 14       | `=`, `+=`, `-=`, `*=`, `%=`, `/=`, `&=`, `\|=`, `^=`, `<<=`, `>>=` | ←      |
| 15       | `,`                                                                | →      |

위는 우선순위입니다. 표전전체를 암기하는 것이 시험문제입니다. 우선순위는 당연히 맞추고 연산자의 순서까지 암기하세요. 우선순위가 같으면 방향으로 결합성 방향 순으로 처리합니다. 하지만 여러분은 상대평가하기 위해서 연산자 순서에 무조건 집중해서 암기하세요.

수학 시간이 아니지만 교환법칙은 알아야 합니다. 덧셈 연산은 교환법칙이 성립합니다. `3 + 4`와 `4 + 3`은 결과가 같습니다. 항의 자리를 교환해도 문제가 없으면 교환법칙이 성립한다고 합니다. 곱셈도 성립합니다. 하지만 성립하지 않는 연산자도 있습니다.

### 산술 연산자

`+`, `-`, `*`, `/`, `%` 뭐 특별한 거 없습니다. 수학이랑 같습니다.

뭐 특별히 알아야 할 것은 연산의 임시결과입니다. 이 임시 결과는 CPU 레지스터에 연산 결과를 저장하고 처리하고 저장한 레지스터를 갱신하고 처리가 끝나면 다시 메모리에 쓰기를 하는 것을 의미합니다. 이런거는 일반인도 교양 다큐나 유튜브에서 다 보는 내용입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nResult = 0;

  nResult = 3 + 4 - 5;

  printf("nResult: %d\n", nResult);
  return EXIT_SUCCESS;
}
```

뭐 결과가 2가 될 거라는 것은 눈으로 보고 알 수 있습니다. 하지만 2가 될 것이라고 처리하는 과정은 CPU가 메모리에서 순서대로 읽고 처리하고 레지스터의 값을 메모리 쓰기하는 문제입니다.

처음에 연산자 우선순위가 같은 덧셈, 뺄셈입니다. 여기서 왼쪽에서 시작에서 오른쪽으로 처리하고 마지막에 할당으로 왼쪽으로 흐릅니다. 피연산자 `3`, `4`를 먼저 레지스터합니다. 그리고 더하기 작업을 수행합니다. 결과로 7을 레지스터에 저장합니다. 다음 `-`은 작업 레지스터 `5`는 오퍼랜드 레지스터에 적재합니다. 작업을 수행하고 `2`로 저장했던 레지스터를 갱신합니다. 마지막으로 `2`를 `nResult`의 주소에 레지스터에 있던 값을 쓰기를 합니다.

뭐 어쎔블리 생각하는 그대로 이해하면 됩니다. 여기서 임시 저장이라고 하는데 CPU가 작업할 대상인 레지스터입니다. 정상적인 프로그래밍을 하려면 이 레지스터에 저장하면서 작업을 수행한다는 것을 알고 있어야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nResult = 0;

  nResult = 3 + 4;

  printf("nResult: %d\n", nResult - 5);
  return EXIT_SUCCESS;
}
```

이거는 화면에 출력 전에 메모리 주소에서 값을 가져오고 연산하고 결과를 보여주는 경우입니다.

C 언어는 수동으로 처리해주는 기본에 충실한 언어입니다. 기계의 특성을 고려한 이론이 기본입니다. 수동으로 처리하는 것 중하나는 이형자료 사이 연산입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  char ch = 'A';
  printf("%c\n", ch);

  printf("%c\n", ch + 1);
  printf("%c\n", 'A' + 1);

  /*printf("%d\n", 5.0 + 2);*/
  printf("%f\n", 5.0 + 2);
  return EXIT_SUCCESS;
}
```

컴파일러 에러 때문에 주석처리했습니다. 하지만 `double`과 `int`를 더하면 `double`로 승격됩니다. 그리고 `char`는 원래 본질은 `int` 인데 지금은 `char`로 출력해서 `char`가 나옵니다. 과거에 시도했던 예제가 이미 이형간 연산이었습니다.

`char`와 `int`를 더할 때 레지스터에는 어떻게 저장하는가? `int`로 저장합니다. 뭐 생각해보면 숫자를 처리하기 더 쉬운데 굳이 어려운 자료형을 사용해야 하는가? 이런 생각을 해볼 수 있습니다. 하지만 이런 원칙을 기준으로 생각하면 됩니다. 임시결과의 자료형은 연산에 참여한 피연산자 중 정보 표현 범위가 더 넓은 자료형으로 변환합니다. 이런 원칙을 기준으로 `int`와 `double` 중 `double`이 되는 것이 말이 됩니다. 추측 해보면 `float`와 `double`을 같이 더하면 `double`이 될 것입니다.

연산의 결과가 피연산자의 자료형보다 표현범위가 넓은 형으로 변환되는 현상을 형승격(type promotion)이라고 부릅니다.

참고로 `int`와 `char` 사이 `int`로 표현범위가 같은데 `int`로 승격되는 것을 것을 integral promotion이라고 부릅니다.

C 언어는 개발자가 모든 것을 알고 있다고 가정합니다. 연산이나 정보 출력에 이런 내부 현상을 고려하는 것은 기본입니다.

곱셈 나눗셈도 크게 다른 것은 작습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int x = 10;
  printf("%d\n", x * 10);       // 100
  /*printf("%d\n", x * 10.0);*/ // 출력 자료형 컴파일 에러
  printf("%d\n", x / 10);       // 1

  printf("%d\n", 5 / 2);        // 2
  /*printf("%f\n", 5 / 2);*/    // 출력 자료형 컴파일 에러
  printf("%f\n", 5.0 / 2);      // 2.500000

  return EXIT_SUCCESS;
}
```

여기서 형승격의 일반적인 원리를 잘 이히해면 됩니다.

나눗셈에서 주의할 점은 정수와 정수로 나누면 정수입니다. 굳이 형승격할 이유가 없습니다. 소수점은 그냥 절사 처리하고 끝냅니다.

수학적으로 당연한 말이지만 0으로 나눌 수 없습니다.

프로그래밍의 기본은 예외처리입니다. 프로그래밍 하루만 배워도 다음과 같은 실수 안 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  printf("정수를 입력하세요. : ");

  scanf("%d", &nInput);

  printf("%d\n", 10 / nInput);
  return EXIT_SUCCESS;
}
// 정수를 입력하세요. : 0
// 0
```

gcc 컴파일러가 내부적으로 안전하게 처리한 것 같습니다. 원래 에러가 발생하고 비정상적인 종료를 할 거라고 예상했는데 아니었지만 0에 대해서 예외처리를 올바르게 했어야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  printf("두 정수를 입력하세요. : ");
  // 입력 10, 20
  int num1 = 0, num2 = 0;
  scanf("%d%d", &num1, &num2);
  // 출력 15.00
  printf("AVG : %.2f\n", (num1 + num2) / 2.0);
  return EXIT_SUCCESS;
}
// 두 정수를 입력하세요. : 10 20
// AVG : 15.00
```

간단한 연습 문제입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0;
  scanf("%d", &x);
  printf("몫: %d\n", x / 3);
  printf("나머지: %d\n", x % 3);
  return EXIT_SUCCESS;
}
/*17*/
/*몫: 5*/
/*나머지: 2*/
```

나머지 연산자에서 주의할 점은 나머지 연산자의 피연산자로 실수를 사용할 없다는 점입니다. `12.3 % 3`, `12.3f % 3` 이런 연산은 허용되지 않습니다.

나머지 연산자는 덧셈, 뻴셈보다는 높고 곱셈, 나눗셈과 같습니다.

프로그래머에게 나머지 연산자는 수학적으로 나머지를 구하는 것말고 공학적으로 문제 해결에 사용하는 훌륭한 도구입니다.

나머지 연산은 제수만큼 경우의 수를 갖습니다. 이것은 문제해결에 유용한 수학적 성질입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int sec = 0;
  scanf("%d", &sec);
  printf("%d초는 %02d시간 %02d분 %02d초 입니다.\n", sec, sec / (60 * 60),
         sec % (60 * 60) / 60, sec % 60);
  return EXIT_SUCCESS;
}
/*4000*/
/*4000초는 01시간 06분 40초 입니다.*/
```

뭐 어려운 문제는 아닙니다.

### 대입 연산자

`=` 이 대입 연산자는 그냥 보면 별거 없습니다. 하지만 내부의 동작 방식을 이해해보면 우변의 있는 변수들의 값을 메모리에서 읽고 연산자들에 따라 처리하고 처리하는 동안 레지스터에 저장하고 있다가 좌변 메모리 주소에 쓰기를 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0, nInput = 0;
  scanf("%d", &nInput);

  x = nInput;

  printf("%d\n", x);
  return EXIT_SUCCESS;
}
```

표준입력으로 정수를 입력하면 정수를 `x` 변수에 저장할 것이라는 것을 알고 있습니다.

지금은 원래 `0`으로 써져있던 메모리 주소에 사용자가 입력한 `10`으로 덮어 써졌다는 것입니다. 쓰기를 위해 L-value이고 좌변입니다. 읽기를 위해 우변에서의 변수를 R-value라고 합니다. 좌변인지 우변인지에 따라 주소를 읽고 값을 접근하는 것인지 레지스터에 저장했던 값을 특정 메모리 주소에 쓰기를 하는 것인지 다릅니다.

L은 Left도 의미하지만 locator(위치 지정자)를 의미하기도 합니다.

정보를 담을 수 없으면 L-value가 아닙니다. 정보를 담는다는 표현에 변수를 보고 상자라고 하는데 여기서 이렇게 비유하는 이유를 바로 알 수 있게 됩니다.

```c
#include <stdlib.h>

int main(void) {

  char szBuffer[32] = {0};

  3 = 4;  // 컴파일 에러

  szBuffer = 'A'; // 컴파일 에러

  return EXIT_SUCCESS;
}
```

딱히 컴파일 할 것은 아니지만 정보를 담을 수 없는 피연산자에 대입연산자를 사용하려고 하고 있습니다.

배열의 이름은 메모리 주소라고 배웠습니다. 즉 L-value가 아닙니다. 상수이고 `szBuffer`에 쓰기를 할 수 없습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 10, y = 20, nTemp = 0;
  printf("Before : x=%d, y=%d\n", x, y);

  nTemp = x;
  x = y;
  y = nTemp;

  printf("After  : x=%d, y=%d\n", x, y);
  return EXIT_SUCCESS;
}
/*Before : x=10, y=20*/
/*After  : x=20, y=10*/
```

메모리 배우면 이런 응용은 바로 가능해야 합니다. 어처구니 없게 설명을 굳이해주면 다음과 같습니다. `x`가 들고 있던 값은 임시 메모리 주소 `nTemp`에 저장합니다. 그러면 지금부터 `x`에 `y`를 할당해도 문제가 없습니다. 그래서 바로 할당합니다. `y`가 갖고 있던 값을 `x`에 저장하면 `y` 변수는 덮어 써도 됩니다. 원래 `x`의 값을 저장했던 `nTemp`의 값을 `y`에 저장합니다. 이렇게 되면 두 변수의 값을 바꿉니다.

이런 거는 처음배우면 바로 할 수 있어야 합니다.

복합 대입 연산자입니다. 그냥 연산자 2개 합친 것입니다. 연산하고 할당하고 2개의 연산을 하는 것입니다. 연산자 표현만 1개입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nResult = 0, nData = 10;

  nResult += 3;
  printf("%d\n", nResult); // 3

  nResult *= nData;
  printf("%d\n", nResult); // 30

  nResult /= 2;
  printf("%d\n", nResult); // 15

  nResult -= 5;
  printf("%d\n", nResult); // 10

  nResult %= 3;
  printf("%d\n", nResult); // 1

  return EXIT_SUCCESS;
}
```

할당하고 그 후에 대입하는 것입니다. 뭐 특별한 것은 없습니다.

연산 우선순위가 낮고 결합성은 오른쪽에서 윈쪽으로 향합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0, y = 0;
  x = y = 10;
  printf("%d, %d\n", x, y); // 10, 10
  return EXIT_SUCCESS;
}
```

꽤나 충격적입니다. 하지만 논리적으로 불만은 없습니다. `10`이라는 값을 `y`에 쓰고 `y`라는 값을 `x`에 쓰기를 하는 것입니다. 이렇게 쓰기를 하는 이유는 직렬로 코드를 일을 때 `x = (y = 10)` 여기서 `y = 10`이고 여기서 `10`이라는 값을 확인하고 `y`에 저장하고 저장한 `y`값을 또 `x`에 쓰기를 하는 것입니다. 결합성의 방향에서 할당을 할 때는 오른쪽에서 왼쪽이고 실행 순서를 결정할 때는 오른쪽을 먼저 올립니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0, nTotal = 0;

  scanf("%d", &nInput);
  nTotal += nInput;

  scanf("%d", &nInput);
  nTotal += nInput;

  scanf("%d", &nInput);
  nTotal += nInput;

  printf("Total :%d\n", nTotal);

  return EXIT_SUCCESS;
}
/*1*/
/*2*/
/*3*/
/*Total :6*/
```

당연한 말이지만 누적 대상이 되는 변수는 `0`으로 초기화해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nResult; // 그냥 0으로 초기화 안하고 컴파일러 에러 발생

  nResult += 10;
  nResult += 10;
  nResult += 10;

  printf("Result :%d\n", nResult);
  return EXIT_SUCCESS;
}
```

gcc가 컴파일 에러를 발생시킵니다.

### 형변환 연산자

형변환(type cast)를 지원하는 연산자들이 있습니다. 연산자들 중 우선순위가 높습니다. 산술연산자(`+`, `-`, `*`, `/`, `%`)과 중첩되면 형변환이 우선입니다.

형변환은 주의해야 하는 행동인데 아무렇지 않게 많이 합니다. 형변환은 강제로 변환을 합니다. 올바른면 큰문제 없겠지만 틀린 형변환을 하면 정보의 손실과 큰 논리적 오류를 만들 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 5;

  printf("%d\n", 5 / 2);           // int / int    -> int
  printf("%f\n", 5.0 / 2);         // double / int -> double
  printf("%f\n", 5 / 2.0);         // int / double -> double
  printf("%f\n", (double)5 / 2);   // double / int -> double
  printf("%f\n", (double)x / 2);   // double / int -> double
  printf("%f\n", x / (double)2);   // int / double -> double
  printf("%f\n", (double)(x / 2)); // double

  return EXIT_SUCCESS;
}
/*2*/
/*2.500000*/
/*2.500000*/
/*2.500000*/
/*2.500000*/
/*2.500000*/
/*2.000000*/
```

타입 승격을 통한 형변환입니다.

당연한 말이지만 실수형을 정수형으로 형변환하면 소수점 이하 정보는 모두 절사됩니다. 표현할 방법도 없고 표현해야 할 이유도 보통 없으니 삭제합니다.

### 단항 증감 연산자

자주 보이는 `++`, `--`을 단항 증감 연산자라고 지칭합니다. 하지만 기본 전제는 당연하지만 피연산자가 L-value 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 10;

  x = x + 1;
  printf("%d\n", x); // 11

  x += 1;
  printf("%d\n", x); // 12

  ++x;
  printf("%d\n", x); // 13

  return EXIT_SUCCESS;
}
```

크게 특별한 것은 없습니다. 그냥 전위연산, 후위연산만 주의하면 됩니다. 전위연산은 우선순위가 높지만 후위연산자는 우선순위가 거의 최하에 가깝습니다. 할당연산자보다 낮은 편입니다.

`++`은 1단위로 누적해서 계수(counting)이라 표현하는 경우가 많습니다.

당연한 말이지만 계수기 역할을 하는 변수는 연산하기 전에 초기화해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0, nResult = 0;

  ++x;
  printf("%d\n", x);

  x++;
  printf("%d\n", x);

  nResult = ++x;
  printf("%d, %d\n", nResult, x);

  nResult = x--;
  printf("%d, %d\n", nResult, x);

  return EXIT_SUCCESS;
}
// 1
// 2
// 3, 3
// 3, 2
```

후위연산이 할당 보다 느리다는 것을 보면 충격적입니다. 그래서 `nResult`는 `3`이고 `x`는 감산을 해서 `2`가 됩니다. 감산하기 전에 할당하고 할당 뒤에 감산을 처리한 것입니다.

우위연산은 실수할 것이라고 생각이 든다면 사용금지를 컨벤션으로 정하고 전위연산만 하는 방법도 있습니다.

### 비트 연산자

비트 연산자는 일정 길이의 메모리에 담긴 2진수 정보를 말 그대로 비트 단위로 계산하는 연산자입니다.

C 언어가 제공하는 비트 연산자는 AND(`&`), OR(`|`), NOT(`~`), shift left(`<<`), shift right(`>>`)입니다. 단항 연산자인 NOT(`~`)을 제외하면 모두 이항연산자입니다.

비트 단위 상수를 작성할 때는 보통 16진수를 사용합니다.

다음예시는 비트단위로 변환하고 비교하기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nData = 0x11223344;

  printf("%08x\n", nData & 0x00FFFF00);
  printf("%08x\n", nData | 0x2211FFFF);
  printf("%08x\n", nData ^ 0x2211FFFF);
  printf("%08x\n", ~nData);
  printf("%08x\n", nData >> 8);
  printf("%08x\n", nData << 16);

  return EXIT_SUCCESS;
}
/*00223300*/
/*3333ffff*/
/*3333ccbb*/
/*eeddccbb*/
/*00112233*/
/*33440000*/
```

```
     1    1    2    2    3    3    4    4
  0001 0001 0010 0010 0011 0011 0100 0100
     0    0    f    f    f    f    0    0
& 0000 0000 1111 1111 1111 1111 0000 0000
     0    0    2    2    3    3    0    0
  0000 0000 0010 0010 0011 0011 0000 0000
```

16진수는 1자리당 4자리 이진수로 표현할 수 있습니다. AND 연산을 하면 모두 1이어야 통과 됩니다. 지금 예시 직관적입니다. 가운데 2233만 그대로 전달되고 1144는 0으로 제거 되었습니다.

```
     1    1    2    2    3    3    4    4
  0001 0001 0010 0010 0011 0011 0100 0100
     2    2    1    1    f    f    f    f
| 0010 0010 0001 0001 1111 1111 1111 1111
     3    3    3    3    f    f    f    f
  0011 0011 0011 0011 1111 1111 1111 1111
```

OR는 둘중 1개라도 true(1)이면 true(1)이 됩니다. 상당히 직관적입니다.

```
     1    1    2    2    3    3    4    4
  0001 0001 0010 0010 0011 0011 0100 0100
     2    2    1    1    f    f    f    f
^ 0010 0010 0001 0001 1111 1111 1111 1111
     3    3    3    3    c    c    b    b
  0011 0011 0011 0011 1100 1100 1011 1011
```

XOR는 모두 true(1)이면 false(0)가 됩니다.

```
     1    1    2    2    3    3    4    4
~ 0001 0001 0010 0010 0011 0011 0100 0100
     e    e    d    d    c    c    b    b
  1110 1110 1101 1101 1100 1100 1011 1011
```

NOT은 1을 0으로 0을 1로 뒤집는다고 생각하면 됩니다.

```
     0    0 |    1    1    2    2    3    3 |    4    4
  0000 0000 | 0001 0001 0010 0010 0011 0011 | 0100 0100
     0    0      1    1    2    2    3    3
  0000 0000   0001 0001 0010 0010 0011 0011
```

시프트 연산은 값을 통으로 이동 시키는 것입니다. `>>` 오른쪽으로 8 즉 16진수에서 2자리 2진수에서 8자리를 이동시킨 것입니다. 이동을 위해 `0`으로 채우는데 이것을 보고 패딩이라고 합니다.

```
     1    1    2    2 |    3    3    4    4 |    0    0    0    0
  0001 0001 0010 0010 | 0011 0011 0100 0100 | 0000 0000 0000 0000
                           3    3    4    4      0    0    0    0
                        0011 0011 0100 0100   0000 0000 0000 0000
```

`<<` 왼쪽으로 밀어낸 것입니다. 16진수에서 4자리만큼 2진수에서 16자리 만큼 밀어낸 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nData = 0x11223344;

  printf("%08x\n", nData & 0xFFFF0000);
  printf("%08x\n", nData & 0x00FFFF00);
  printf("%08x\n", nData & 0x0000FFFF);
  printf("%08x\n", nData & 0xFF0000FF);

  return EXIT_SUCCESS;
}

/*11220000*/
/*00223300*/
/*00003344*/
/*11000044*/
```

1. 연산의 중첩에서 연산의 '임시결과'란 무엇을 의미하며, 임시 결과의 가장 중요한 특징은 무엇인가?

임시결과 작업을 처리할 때 CPU 레지스터에 담고 할당을 결정할 때 레지스터에서 메모리에 쓰기를 합니다. 임시 결과의 가장 중요한 특징은 우선순위입니다.

2. `char` 자료형은 `int` 자료형 사이 `+`를 수행하면 임시 결과의 자료형으 무엇인가?

표현 범위가 더 넓은 자료형으로 타입승격이 발생하지만 `char`와 `int`는 표현 범위가 같습니다. 표현 범위가 같은데 `char`와 `int` 사이 연산이 있으면 내부적으로 `char`를 `int`로 타입승격을 시키고 계산을 처리하고 `int`로 저장합니다.

3. 2번 문제는 같은 현상을 부르는 용어는 무엇이며, 이형자료 사이 연산에 임시 결과에 대한 자료형이 결정되는 근거는 무엇인가?

이 현상은 타입승격이라고 부릅니다. 자료형이 다른 것 사이 연산이 있으면 임시 결과는 표현범위가 더 넓은 타입으로 타입 승격을 시키고 처리하고 저장합니다. 타입 승격으로 표현 범위가 더 넓은 자료형으로 변환하는 이유는 정보 손실을 덜하기 때문입니다. 범위가 작으면 정보 손실이 발생합니다. 하지만 넓은 쪽을 선택하면 메모리 공간상 점유량이 늘어납니다.

4. `5 / 2`의 연산 결과의 자료형과 값은 무엇인가?

`int`이고 `2`입니다.

5. 사용자로부터 정수 입력받아 5로 나눈 나머지를 출력하는 프로그램을 작성하시오.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int input = 0;

  scanf("%d%*c", &input);

  input %= 5;

  printf("%d\n", input);

  return EXIT_SUCCESS;
}
```

6. 대입 연산자의 왼쪽 피연산자가 될 수 있는 자격을 갖춘 대상을 부르는 용어는 무엇인지 답하시오.

L-value

Locater value로 위 값인데 여기서 말하는 위치는 메모리 주소입니다.

7. 다음 코드의 실행결과는 무엇니가?

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  printf("%08x\n", 0xFFFFFFFF & 0x00080000);
  printf("%08x\n", 0xAAAABBBB & 0x00080000);
  printf("%08x\n", 0xAABBCCDD & 0x00080000);

  printf("%08x\n", 0xFFFFFFFF | 0x00080000);
  printf("%08x\n", 0x11223344 | 0x00080000);
  printf("%08x\n", 0x00000000 | 0x000F0000);

  return EXIT_SUCCESS;
}
/*00080000*/
/*00080000*/
/*00080000*/
/*ffffffff*/
/*112a3344*/
/*000f0000*/
```

## Chapter 05 연산자 응용

숫자 계산처럼 생겨먹은 거는 아닌데 연산자인 것들이 있습니다. `sizeof`는 컴파일러 수행하고 CPU가 실행하지 않는 특수한 연산합니다. 이번에 다룰 연산자들은 중요하고 반드시 알아야 하고 주의할 점들을 학습니다.

### `sizeof` 연산자

`sizeof`의 피연산자는 자료형입니다. `sizeof(5)`는 `sizeof(int)`입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nData = 10;

  printf("%d, %d, %d\n", sizeof(5), sizeof(nData), sizeof(int));
  printf("%d, %d\n", sizeof('A'), sizeof(char));
  printf("%d, %d\n", sizeof(123.45F), sizeof(123.45));

  printf("%d, %d\n", sizeof(nData + 10), sizeof(++nData));
  printf("%d\n", nData);

  return EXIT_SUCCESS;
}
/*4, 4, 4*/
/*4, 1*/
/*4, 8*/
/*4, 4*/
/*10*/
```

`gcc`에서 컴파일러 경고가 많아 힘들게 컴파일했습니다.

`sizeof(nData + 10)`을 보면 연산식을 계산하고 계산 결과의 타입을 `sizeof`의 피연산자로 활용합니다. 식 전체는 피연산자가 아닙니다. 상당히 당연하지만 컴파일러와 프로그램 관점에서는 아닙니다. 컴파일러가 계산을 처리한다는 것은 프로그램이 실행해야 할 영역을 대신하는 것입니다.

`sizeof` 내에서 전위 단항연산자로 더해도 `nData`는 더해지지 않았습니다. 즉 `sizeof(++nData)`는 실행된 것이 아닙니다.

`sizeof`는 런타임에 실행하지 않고 컴파일 타임에 실행하는 연산자입니다. 그래서 성능 문제가 없습니다. 많이 사용할수록 좋은 연산자입니다. 사용할 때 모미리 사이즈를 정하고 생각하기 좋은 연산자입니다.

### 관계 연산자

관계 연산자는 두 피연산자의 값을 비교해 참(`True`, `1`) 혹은 거짓(`False`, `0`)의 결과를 내는 연산자입니다.

| 연산식   | 분류     | 의미                             |
| -------- | -------- | -------------------------------- |
| `A == B` | 상등연산 | A는 B와 같다(즉, 뻴셈 결과가 0). |
| `A != B` | 부등연산 | A는 B와 같지 않다.               |
| `A > B`  | 비교연산 | A는 B보다 크다.                  |
| `A < B`  | 비교연산 | A는 B보다 작다.                  |
| `A >= B` | 비교연산 | A는 B보다 크거나 같다(B 이상).   |
| `A <= B` | 비교연산 | A는 B보다 작거나 같다(B 이하).   |

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 5, y = 10;

  printf("%d\n", x == y);
  printf("%d\n", x != y);
  printf("%d\n", x > y);
  printf("%d\n", x < y);

  printf("%d\n", y >= 10);
  printf("%d\n", y <= x + 5);

  return EXIT_SUCCESS;
}
/*0*/
/*1*/
/*0*/
/*1*/
/*1*/
/*1*/
```

크게 어려운 것은 없습니다.

비교연산자는 내부적으로 뺄셈을 한다고 생각해볼 수 있습니다. 0인지 아니면 부호가 반대인지 확인하는 것을 응용했을 것이라고 알 수 있습니다.

만약 문자열을 배열에을 비고해야 하면 원소단위로 비교해야 합니다. 이런 비교는 전용함수를 사용해야 합니다. `memcmp()`과 `strcmp()` 함수가 존재합니다.

관계 연산에서 주의해야 할점은 있습니다. 자료형이 같아야 합니다. 정수와 상수를 비교하면 엉뚱한 결과를 얻습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  printf("%d\n", 300 == 299.99999F);
  printf("%d\n", 300 == 299.99999);
  printf("%d\n", 300 == 299.9999);
  printf("%d\n", 300 == 300.00001F);
  return EXIT_SUCCESS;
}
/*1*/
/*0*/
/*0*/
/*1*/
```

모두 당연히 다릅니다. 하지만 일부는 같다고 여기고 있습니다. 실수형이 같다고 간주하고 있습니다.

### 논리 연산자

논리합(OR), 논리곱(AND)는 다른 프로그래밍 언어와 비슷합니다. `||`이 합인데 이 `|` 기호를 보고 pipe이라고 부릅니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nInput = 0, bResult = 0;

  scanf("%d%*c", &nInput);
  bResult = nInput < 4 || nInput >= 60;

  printf("Result : %d (1:True, 0:False)\n", bResult);

  return EXIT_SUCCESS;
}
/*42*/
/*Result : 0 (1:True, 0:False)*/
```

논리합은 하나라도 참이면 모두 참이 됩니다.

하지 않아도 될 연산을 생략하여 논리식의 효율을 높이는 것을 쇼트서킷(short circuit)이라고 합니다. 이 경우 참이 나올 때까지 평가할 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nInput = 0, bResult = 0;

  scanf("%d%*c", &nInput);
  bResult = nInput > 3 && nInput < 20;

  printf("Result : %d (1:True, 0:False)\n", bResult);

  return EXIT_SUCCESS;
}
/*17*/
/*Result : 1 (1:True, 0:False)*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nInput = 0, bResult = 0;

  scanf("%d%*c", &nInput);
  bResult = 3 < nInput < 20;

  printf("Result : %d (1:True, 0:False)\n", bResult);

  return EXIT_SUCCESS;
}
```

린트부터 바로 에러를 알려줍니다. 어떤 값을 입력해도 1은 20보다 작으니 항상 True라고 할 것입니다. 여기서 범위를 표현하고 싶으면 `3 < nInput && nInput < 20`이라고 작성하면 됩니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nInput = 0, bResult = 0;

  scanf("%d%*c", &nInput);
  bResult = !nInput;

  printf("Result : %d (1:True, 0:False)\n", bResult);

  return EXIT_SUCCESS;
}
/*0*/
/*Result : 1 (1:True, 0:False)*/
```

부정은 너무 많이 사용하지 않습니다. 극단적으로 많으면 논리적으로 혼란을 만들 가능성이 많습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nAge = 0, nHeight = 0;

  printf("나이를 입력하세요. : ");
  scanf("%d%*c", &nAge);
  printf("키를 입력하세요. : ");
  scanf("%d%*c", &nHeight);

  printf("결과 : %d (1:합격, 0:불합격)\n",
         nAge >= 20 && nAge <= 30 && nHeight >= 150);

  return EXIT_SUCCESS;
}
/*나이를 입력하세요. : 29*/
/*키를 입력하세요. : 180*/
/*결과 : 1 (1:합격, 0:불합격)*/
```

AND는 `false`를 찾을 때 까지 처리합니다. OR는 반대로 `true`를 찾을 때까지 처리합니다. 모두 왼쪽에서 오른쪽 순서대로 처리합니다.

혼합식 즉 섞여있는 경우 OR와 AND로 한번 묶고 처리합니다.

### 삼항 연산자

`조건식 ? A : B` 이게 끝입니다. C 언어의 유일한 삼항 연산자가 조건 연산자입니다. 항이 모두 3개입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0, nSelect = 0;
  scanf("%d", &nInput);

  nSelect = nInput <= 10 ? 10 : 20;
  printf("%d\n", nSelect);

  return EXIT_SUCCESS;
}
/*5*/
/*10*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0, nSelect = 0;
  scanf("%d", &nInput);

  /*nInput <= 10 ? nSelect = 10 : nSelect = 20; // 컴파일 에러 발생*/
  nInput <= 10 ? (nSelect = 10) : (nSelect = 20);
  printf("%d\n", nSelect);

  return EXIT_SUCCESS;
}
```

`nInput <= 10 ? (nSelect = 10) : (nSelect = 20);`이렇게 작성해도 컴파일 에러가 발생하지 않아 놀랍습니다.

`sizeof` 혹은 주소 연산자(`&`) 처럼 컴파일 타임에 사용되는 연산자가 있고 그 이후에 런타임에는 피연산자는 변수가 아니라 변수 안에 담긴 값입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int input = 0;

  printf("키를 입력하세요. :");
  scanf("%d%*c", &input);
  printf("결과: %s\n", input >= 150 ? "합격" : "불합격");

  return EXIT_SUCCESS;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nMax = 0;
  int a, b, c;

  scanf("%d %d %d", &a, &b, &c);

  a > b ? (nMax = a) : (b > c ? (nMax = b) : (nMax = c));

  printf("MAX: %d\n", nMax);
  return EXIT_SUCCESS;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nMax = 0, nInput = 0;
  scanf("%d", &nInput);
  nMax = nInput;

  scanf("%d", &nInput);
  nMax = nInput > nMax ? nInput : nMax;

  scanf("%d", &nInput);
  nMax = nInput > nMax ? nInput : nMax;

  printf("MAX: %d\n", nMax);
  return EXIT_SUCCESS;
}
```

각각 3번 입력하는 경우입니다. 간단합니다.

여기서 알아야 할 것은 이방식이 유지보수하기 쉽습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nMax = -100, nInput = -100;
  scanf("%d", &nInput);
  nMax = nInput > nMax ? nInput : nMax;

  scanf("%d", &nInput);
  nMax = nInput > nMax ? nInput : nMax;

  scanf("%d", &nInput);
  nMax = nInput > nMax ? nInput : nMax;

  printf("MAX: %d\n", nMax);

  return EXIT_SUCCESS;
}
```

쉽게 풀이할 수 있습니다. 가장 작은 값보다 작을 수 없게 시작하면 됩니다.

어떤 알고리즘이 좋은 알고리즘인가 평가할 때는 당연히 근거입니다. 그 중 하나는 동작횟수 지금의 경우 비교횟수에 해당합니다.

지금 예시의 경우 이전과 크게 다르지 않습니다. 그래서 성능 비교는 무의미합니다.

유지보수와 확장성을 생각해봐야 합니다.

몆출 복붙하는 관점으로 확장한다고 생각하면 당연히 매번 입력 받는 버전이 더 유리합니다.

메모리 사용량을 비교해볼 수 있습니다. 이것은 공간복잡성 문제입니다. 변수의 개수로 생각하면 이번에도 3번 변수로 받으면 변수마다 확보해야 하는 메모리 량이 많아집니다. 하지만 여러번 입력받는 버전은 입력 받을 때마다 새로운 메모리 확보는 안하고 사용했던 메모리를 계속 사용합니다.

1. 다음 코드의 실행 결과 및 원리에 대해 답하세요.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nResult, w = 0, x = -1, y = -1, z = 1;
  nResult = w++ || x++ && ++y || ++z;
  printf("%d %d %d %d %d\n", w, x, y, z, nResult); // 1 0 0 2 1
  return EXIT_SUCCESS;
}
```

표준 컴파일 플래그를 사용하면 소괄호 사용하라고 에러를 던집니다.

여기서 우위 연산은 늦게 동작합니다. 그래서 전위 연산 후위 연산 처리하면 다음과 같은 표현이 가능합니다.

`0 \|\| -1 \&\& 0 \|\| 2` 여기서 이제 왼쪽에서 오른쪽 순서대로 처리하면 됩니다. AND, OR를 참 거짓을 받을 때 까지로 보면 이렇게 처리 될 수 있습니다. 또 논리연산자의 결과는 `0` 또는 `1`입니다.

1. `0 \|\| -1 \&\& 0 \|\| 2` : 시작. OR(`\|\|`)은 `true`를 찾을 때까지 실행
2. `1 \&\& 0 \|\| 2` : `0`은 `false`라 제거. AND(`\&\&`)는 `false`를 찾을 때까지 실행.
3. `0 \|\| 2` : `0`은 `false`라 제거. AND(`\&\&`)는 `false`를 찾을 때까지 실행.
4. `1` : 마지막은 둘 중 하나가 `true`라 결국 `1`이 됨.
5. `1` : 후위연산은 할당이후 실행하기 때문에 `w`, `x`, `y`, `z`는 `1 0 0 2`가 됨

## Chapter 06 기본 제어문

조건문은 다른 언어에서도 배우는 것이입니다. 본격적인 프로그래밍의 부분입니다. 자료형과 연산자는 단어와 숙어와 비슷합니다. 제어문은 문장과 비슷합니다.

### if 문

if 문은 다른 말로 분기문이라고 합니다. 조건을 기준으로 절차상 흐름을 제어합니다. 다른 제어문도 조건문을 기반으로 합니다. 처음 프로그래밍한다면 의식을 많이 하기 바랍니다.

제어문은 연산자가 포함되어 있습니다. 연산에 참여하는 변숫값의 변화를 추적할 수 있어야 합니다.

기본구조는 직관적입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nAge = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d", &nAge);
  if (nAge >= 20) {
    printf("당신의 나이는 %d세 입니다.\n", nAge);
  }
  printf("End");

  return EXIT_SUCCESS;
}
/*나이를 입력하세요. : 20*/
/*당신의 나이는 20세 입니다.*/
/*End%*/
```

여기 예시에서 들여쓰기와 열맞춤에 신경쓰는 습관을 들이기 바랍니다. 안하면 읽기 어렵습니다.

개발자의 소스코드는 문서입니다. 간결하고 가독성 높이는 것이 중요한 개발자의 덕목입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nAge = 0;

  printf("나이를 입력하세요. : ");
  scanf("%d", &nAge);

  if (nAge >= 20) {
    printf("당신의 나이는 %d세 입니다.\n", nAge);
		nAge = 20;
  }
  printf("당신의 나이는 %d세 입니다.\n", nAge);

  return EXIT_SUCCESS;
}
/*나이를 입력하세요. : 30*/
/*당신의 나이는 30세 입니다.*/
/*당신의 나이는 20세 입니다.*/
```

나이 알고리즘이 이렇게 되면 좋겠습니다. 30대가 되어도 강제로 20살이 된다는 것이 행복할 것 같습니다.

블록 스코프(`{}`)는 문법적으로 영역을 만드는 것입니다. 하지만 실행문은 아닙니다.

C 언어는 괄호로 여러 항을 묶어 한 항우로 만들고 블록 스코프로 여러 구문을 묶어 한 구문을 만들 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int max = -100, input = -100;
  scanf("%d", &input);
  if (input > max)
    max = input;
  scanf("%d", &input);
  if (input > max)
    max = input;
  scanf("%d", &input);
  if (input > max)
    max = input;

  printf("MAX : %d\n", max);

  return EXIT_SUCCESS;
}
/*10*/
/*30*/
/*-10*/
/*MAX : 30*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int age = 0, cost = 1000;
  scanf("%d", &age);
  if (age < 20) {
    cost = cost * 75 / 100;
  }

  printf("최종요금: %d원\n", cost);
  return EXIT_SUCCESS;
}
/*17*/
/*최종요금: 750원*/
```

간단하게 해결했습니다.

```c
if (nAge >= 20);
```

여기서 주의할 점은 세미코론(`;`)이 조건식 끝에 붙으면 컴파일러는 그 지점에서 if문이 끝난 것으로 인식합니다.

여러 줄이면 블록 스코프로 묶어야 합니다.

### if else문

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0, nSelect = 0;
  scanf("%d", &nInput);

  if (nInput <= 10)
    nSelect = 10;
  else
    nSelect = 20;
  printf("%d\n", nSelect);
  return EXIT_SUCCESS;
}
/*24*/
/*20*/
```

`else`는 조건이 없습니다. 이전 모든 조건들에서 안 걸리면 실행하는 로직입니다.

상호 배타적인 로직을 실행할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0, nSelect = 0;
  scanf("%d", &nInput);

  if (nInput <= 10) {
    if (nInput < 0)
      nSelect = 0;
    else
      nSelect = 10;
  } else {
    nSelect = 20;
  }

  printf("%d\n", nSelect);
  return EXIT_SUCCESS;
}
/*-10*/
/*0*/
```

뭐 안 어려운 예제입니다.

다음은 학점 분류 계산기입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  char ch = 'A';

  printf("점수를 입력하세요: ");
  scanf("%d", &nInput);

  if (nInput >= 80) {
    if (nInput >= 90)
      ch = 'A';
    else
      ch = 'B';
  } else {
    if (nInput >= 70)
      ch = 'C';
    else
      ch = 'D';

    if (nInput < 60)
      ch = 'F';
  }

  printf("%c\n", ch);
  return EXIT_SUCCESS;
}
/*점수를 입력하세요: 85*/
/*B*/
/*점수를 입력하세요: 59*/
/*F*/
```

조건에 의한 분류와 선택이 중요합니다.

프로그래머는 발생 가능한 경우의 수를 나열한 후, 어떤 조건과 방법으로 하나를 정확히 선택할 수 있는지 기술할 수 있어야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int input = 0, discount = 100;
  scanf("%d", &input);

  if (input <= 13) {
    if (input <= 3)
      discount = 0;
    else
      discount = 50;
  } else {
    if (input <= 19)
      discount = 75;
    else
      discount = 100;
  }

  printf("최종요금: %d원\n", 1000 * discount / 100);
  return EXIT_SUCCESS;
}
```

문제는 간단하게 풀 수 있습니다.

식별자 검색순서

변수의 통용범위는 그 변수를 선언한 블록 스코프로 제한됩니다. 스코프를 벗어나면 변수는 사라집니다. 기본적으로 local 변수이고 auto 변수이기 때문입니다.
외부 스코프에서는 같은 변수선언도 가능합니다. 다음은 식별자 검색 실험입니다. 실무는 이렇게 하면 곤란합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("%d", &nInput);

  if (nInput > 10) {
    int nInput = 20;
    printf("%d\n", nInput);

    if (nInput < 20) {
      int nInput = 30;
      printf("%d\n", nInput);
    }
  }

  printf("%d\n", nInput);

  return EXIT_SUCCESS;
}
/*11*/
/*20*/
/*11*/
```

핵심입니다. 가장 최근에 형성된 스코프가 우선합니다. 스코프가 닫히면 그 내부에 선언된 변수는 소멸합니다. 코드를 복붙하면서 실수로 발생할 가능성이 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  char ch = 'A';

  printf("점수를 입력하세요: ");
  scanf("%d", &nInput);
  if (nInput >= 90)
    ch = 'A';
  else if (nInput >= 80)
    ch = 'B';
  else if (nInput >= 70)
    ch = 'C';
  else if (nInput >= 60)
    ch = 'D';
  else
    ch = 'F';

  printf("점수: %d, 학점: %c\n", nInput, ch);
  return EXIT_SUCCESS;
}
/*점수를 입력하세요: 59*/
/*점수: 59, 학점: F*/
```

경우의 수가 늘어날수록 성능 문제가 있습니다. 2진 탐색과 선형탐색이 성능이 다른 것과 같습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int input = 0, discount = 100;
  scanf("%d", &input);

  if (input <= 3 || input >= 65)
    discount = 0;
  else if (input <= 13)
    discount = 50;
  else if (input <= 19)
    discount = 75;
  else
    discount = 100;

  printf("최종요금: %d원\n", 1000 * discount / 100);
  return EXIT_SUCCESS;
}
```

## switch-case문

정보를 분류하는데 사용하는 제어문입니다. 경우의 수를 선택하지 않고 단 한번의 연산(혹은 변수)으로 특정한 경우 하나를 선택합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char cOperator = 0;
  int x = 0, y = 0, nResult = 0;
  scanf("%d%c%d", &x, &cOperator, &y);

  switch (cOperator) {
  case '+':
    nResult = x + y;
    break;
  case '-':
    nResult = x - y;
    break;
  case '*':
    nResult = x * y;
    break;
  case '/':
    nResult = x / y;
    break;
  default:
    puts("ERROR: 알 수 없는 산술 연산입니다.");
  }

  printf("Result: %d\n", nResult);

  return EXIT_SUCCESS;
}
/*3*2*/
/*Result: 6*/
```

switch 문은 각 경우에 대응하는 값과 기술한 값을 비교하는 상등연산(`==`)을 수행합니다.

case 문 끝에는 세미콜론(`;`)이 아닙니다. C 언어에서 레이블이 존재합니다. 연산식이 아니고 코드의 위치를 기술하는 것입니다. 레이블도 끝이 `:`입니다.

break 문은 연산을 즉시 멈추고 자신이 속한 스코프를 벗어나도록 흐름을 변경합니다.

case 문 내에서는 반드시 작성해야 합니다.

때로는 의도적으로 break 문을 생략할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char chCredit = 'x';
  int nInput = 0;

  printf("점수를 입력하세요. : ");
  scanf("%d", &nInput);

  switch (nInput / 10) {
  case 10:
  case 9:
    chCredit = 'A';
    break;
  case 8:
    chCredit = 'B';
    break;
  case 7:
    chCredit = 'C';
    break;
  case 6:
    chCredit = 'D';
    break;
  default:
    chCredit = 'F';
  }

  printf("학점 : %c\n", chCredit);

  return EXIT_SUCCESS;
}

/*점수를 입력하세요. : 95*/
/*학점 : A*/
```

100점과 90이상인 경우 모두 포함합니다.

## goto 문

goto문은 break 문처럼 특정 위치로 프로그램의 흐름을 '즉시' 변경합니다. break문은 그 대상위치가 문법적으로 제한된 상태입니다. 변경이 불가능합니다.

goto 문은 사용자가 레이블로 명시한 위치면 어디든지 이동할 수 있습니다. 아무 제한 없이 코드의 흐름을 변경할 수 있습니다.

장점같지만 단점이 되기도 합니다. 코드의 흐름이 논리적으로 파악이 어려워 질 수 있습니다. 해결하기 어려운 상태가 될 가능성이 높습니다. 문법은 알아두고 필요한 상황에만 활용합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput;

INPUT:
  printf("Input number : ");
  scanf("%d", &nInput);

  if (nInput < 0 || nInput > 10)
    goto INPUT;

  puts("End");

  return EXIT_SUCCESS;
}
/*Input number : -1*/
/*Input number : 11*/
/*Input number : 5*/
/*End*/
```

goto 문은 오른쪽에 레이블명을 기술합니다. 어디든 맥락에 상관없이 goto 문으로 이동할 수 있습니다. 편리하지만 꼬이면 스파게티코드가 됩니다. 많은 사람들이 goto문을 사악한 코드(evil code)라고 부르고 사용하지 말라고 권합니다.

다익스트라이 주장이 와전된 것입니다.

설계적으로 전혀 관련이 없어야 할 두 대상을 하나로 묶어줄 수 있기 때문에 구조적 결함을 만들 가능송이 높습니다. 유지보수 측면의 효율이 많이 떨어집니다.

1. if문을 사용하여 사용자로부터 정수 5개를 입력받아 그중 가장 큰 수를 출력하는 프로그램을 작성하시오. 사용자는 0 ~ 100 사이 값만 입력하도록 강제합니다. 범위를 벗어난 숫자를 입력할 경우 0 미만은 0으로 100초과는 100으로 조정합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int input = 0, i = 0, max = 0;

INPUT:
  scanf("%d", &input);
  i += 1;

  if (input < 0)
    input = 0;
  if (input > 100)
    input = 100;

  if (input >= max)
    max = input;

  if (i < 5)
    goto INPUT;

  printf("Max : %d\n", max);

  return EXIT_SUCCESS;
}
```

2. 다음 코드에서 잘못된 부분은 무엇인가?

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nAge = 0;

  scanf("%d", &nAge);

  if (nAge = 20)
    puts("당신은 성인입니다.");

  puts("End");

  return EXIT_SUCCESS;
}
```

```c
  if (nAge == 20)
```

여기만 이렇게 고치면 됩니다.

3. 다음 코드를 작성하고 사용자가 15를 입력했다면 어떤 결과가 출력되는지 쓰세요.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("%d", &nInput);

  if (nInput > 10) {
    int nInput = 20;
    printf("%d\n", nInput);

    if (nInput < 20) {
      int nInput = 30;
      printf("%d\n", nInput);
    }
  }

  printf("%d\n", nInput);
  return EXIT_SUCCESS;
}
```

`15`를 입력하고 `20`을 먼저 출력하고 다음에 `15`를 출력합니다.

## 반복문

반복문은 일정구간의 코드를 연속적으로 반복해 실행하는 제어문입니다.

사람이 할 귀찮은 일을 기계가 대신 실수 없이 반복하는 것이 업무 전산화의 목표 중 하나입니다. 다른 말로 중요합니다.

### while - 조건 기반 반복문

while은 if문과 유사합니다. 하지만 조건이 거짓이 될때까지 계속 실행합니다.

이것은 아주 중요한 특징입니다.

#### 기본구조 조건에 의한 제어

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;

  while ((ch = getchar()) != '\n') {
    putchar(ch);
  }

  return EXIT_SUCCESS;
}
/*TestString*/
/*TestString%*/
```

`ch`는 `getchar`의 반환값을 할당합니다. `getchar`는 버퍼메모리에서 데이터를 꺼내는데 없으면 유저의 표준입력을 받습니다. `while`은 `\n`인 개행문자를 받을 때까지 실행합니다. 여기서는 입력을 받으면 계속 출력하기만 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int input = 0, idx = 0;

  scanf("%d%*c", &input);

  while (idx != input) {
    printf("*");
    idx += 1;
  }
  printf("\n");

  return EXIT_SUCCESS;
}
```

#### 무한루프

스킬이슈

반복을 멈추기위한 조건부터 설계하도록 합니다. 종료조건에 영향을 주는 연산이 반복문 내부에 당연히 있어야합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;

  while (nInput >= 0) {
    nInput + 1;
  }
  printf("%d\n", nInput);

  return EXIT_SUCCESS;
}
```

굳이 실행하지 않을 것입니다.

실제로 CPU 코어 점유율을 보면 100% 금방 도달하는 것을 볼 수 있을 것입니다.

다음은 `int` 오버플로우로 비정상적인 종료가 발생할 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;

  while (nInput >= 0) {
    ++nInput;
  }
  printf("%d\n", nInput);

  return EXIT_SUCCESS;
}
```

`int` 가 최댓값을 초과하고 음수로 오버플로우하게 되면 `while` 조건을 깨는 상태를 충족하게 됩니다.

종료하기는 하지만 의도랑 다르다는 것이 문제입니다. 대부분의 경우 의도가 다를 경우가 많을 것입니다.

#### 반복문 내부에 선언한 자동변수

반복문 내부에서 변수선언하는 행위는 자제해야 합니다. 프로그램이 비효율적이게 동작합니다. 스택영역으로 관리가 필요합니다.

다음은 반복문 내부에 변수 선언을 안한 정상적인 코드입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;
  int nIndex = 0;
  while ((ch = getchar()) != '\n') {
    printf("%02d\t%c\n", nIndex, ch);
    ++nIndex;
  }
  return EXIT_SUCCESS;
}
/*Hello*/
/*00	H*/
/*01	e*/
/*02	l*/
/*03	l*/
/*04	o*/
```

상당히 단순한 코드입니다. 이제는 의도적으로 오류를 만들어보겠습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;

  while ((ch = getchar()) != '\n') {
    int nIndex = 0;

    printf("%02d\t%c\n", nIndex, ch);
    ++nIndex;
  }

  return EXIT_SUCCESS;
}
/*Hello*/
/*00	H*/
/*00	e*/
/*00	l*/
/*00	l*/
/*00	o*/
```

오류를 직접 만든입장에서는 이해가 쉽습니다. 스코프가 닫히면 그 내부에 선언 및 정의된 변수는 사라진다고 했습니다. 지금 같은 경우 특별하게 활용하는 경우가 아니라서 비효율적입니다. 메모리에 계속 데이터를 추가하고 삭제하면서 불필요한 작업을 많이 하게 됩니다.

반복문 내부에서는 변수를 선언 및 정의하지 않습니다.

#### 반복문의 중첩

반복문은 if문을 중첩하는 것처럼 중첩이 가능합니다. 뭐 말해줘야 아는 사람들도 있어서 이야기합니다.

다음은 구구단 출력하는 고전 문제입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 2, j = 1;

  while (i <= 9) {
    j = 1;
    putchar('\n');
    while (j <= 9) {
      printf("%d * %d = %d\n", i, j, i * j);
      j += 1;
    }
    i += 1;
  }

  return EXIT_SUCCESS;
}

/*2 * 1 = 2*/
/*2 * 2 = 4*/
/*2 * 3 = 6*/
/* ... */
/*9 * 9 = 81*/
```

실습문제로 5x5 행렬을 출력하라고 합니다.

```c
#include <stdio.h>
#include <stdlib.h>
int main(void) {
  int i = 0, j = 0;

  while (i < 5) {
    j = 0;
    while (j < 5) {
      j += 1;
      printf("*\t");
    }
    putchar('\n');
    i += 1;
  }

  return EXIT_SUCCESS;
}
/**	*	*	*	*	*/
/**	*	*	*	*	*/
/**	*	*	*	*	*/
/**	*	*	*	*	*/
/**	*	*	*	* */
```

정답지를 본게 아닌가 의심스러울 정도로 같았습니다.

### for 문

while 문은 실수할 가능성이 은근히 있습니다. 스킬 이슈입니다.

for 문은 초기화, 계수기, 증가식 3가지를 한 행에 강제로 기술하게 만듭니다. while 문가 본질은 같지만 실수할 여지가 적습니다. 또 가독성 측면과 관용어구라는 측면에서 장점입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 0;

  for (i = 0; i < 5; ++i) {
    printf("%dth\n", i);
  }

  return EXIT_SUCCESS;
}
/*0th*/
/*1th*/
/*2th*/
/*3th*/
/*4th*/
```

반복문 스코프의 머리부분 한줄로 시작과 끝을 단번에 알수 있다는 장점이 있습니다.

for 문은 생략이 가능합니다. `for(;;)`이라고 표현도 가능합니다. 이렇게 되면 `while(1)`과 같습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int sum = 0;

  for (int i = 1; i <= 10; ++i) {
    sum += i;
  }
  printf("%d\n", sum);

  return EXIT_SUCCESS;
}
/*55*/
```

쉽게 구할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int input = 2;
  scanf("%d%*c", &input);

  if (input < 2 || input > 9) {
    printf("Error\n");
  } else {
    for (int i = 1; i <= 9; ++i) {
      printf("%d * %d = %d\n", input, i, input * i);
    }
  }

  return EXIT_SUCCESS;
}
```

상당히 문제를 쉽게 풀 수 있습니다.

이전에 풀어본 문제를 while 문에서 for 문으로 풀어봅니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 0; i < 5; ++i) {
    for (int j = 0; j < 5; ++j) {
      printf("*\t");
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/**	*	*	*	*	*/
/**	*	*	*	*	*/
/**	*	*	*	*	*/
/**	*	*	*	*	*/
/**	*	*	*	* */
```

논리구조는 상당히 단순합니다. 0에서 출발하는 zero-based index입니다.

자주하는 것들 중 하나는 도형출력 과제합니다.

뭐 처음하면 오래 걸릴 수 있지만 오래 걸리면 안되는 과제들입니다.

본인이 작성하는 본인의 코드에 대해 기초적인 자각능력을 기르기 시작하는 기초 운동입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 1; i <= 5; ++i) {
    for (int j = 0; j < i; ++j) {
      printf("*\t");
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/**	*/
/**	*	*/
/**	*	*	*/
/**	*	*	*	*/
/**	*	*	*	*	*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 1; i <= 5; ++i) {
    for (int j = 1; j <= 5 - i; ++j) {
      printf("\t");
    }
    for (int j = 1; j <= i; ++j) {
      printf("*\t");
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/*
				*
			*	*
		*	*	*
	*	*	*	*
*	*	*	*	*
*/
```

첫 줄 줄바꿈 버그까지 주의해서 작성하도록 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 1; i <= 5; ++i) {

    for (int j = 1; j <= 5 - i; ++j) {
      printf("\t");
    }

    for (int j = 1; j <= 2 * i - 1; ++j) {
      printf("*\t");
    }

    for (int j = 1; j <= 5 - i; ++j) {
      printf("\t");
    }

    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/*
				*
			*	*	*
		*	*	*	*	*
	*	*	*	*	*	*	*
*	*	*	*	*	*	*	*	*
*/
```

피라미드 출력은 쉽습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 0; i < 5; ++i) {

    for (int j = 0; j < 5 + i; ++j) {
      if (i + j >= 4)
        printf("*\t");
      else
        putchar('\t');
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
```

이렇게 풀이하는 것이 더 올바릅니다.

### do while 문

반복 대상 단위 코드를 먼저 한번 실행하고 나중에 조건 비교를 합니다.

적어도 한번은 실행이 필요한 로직에 유용합니다. 뭐 CLI로 게임만들 때 게임루프를 만들기 좋습니다.

조건식을 괄호 뒤에 세미콜론을 붙인다는 점이 특이합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;

  do {

    ch = getchar();
    putchar(ch);
  } while (ch != '\n');

  return EXIT_SUCCESS;
}
/*TestString*/
/*TestString*/
```

입력의 유효함을 확인하고 다시 입력하게 만들 때 자주 활용하는 전략입니다.

범위를 벗어나거 유효하지 않으면 무엇이 안 맞는지 알려주고 루프를 계속 돌게 만들 수 있습니다.

### break와 continue

break는 while, for, do while, switch-case 모두 사용합니다. 흐름을 벗어날 수 있게 해줍니다. continue는 반복문 내부에서 현재 수행을 종료하고 다음 반복문을 수행할 수 있게 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 0;
  for (i = 0; i < 10; ++i) {
    if (i > 4)
      break;

    printf("%dth\n", i);
  }

  printf("END: i == %d\n", i);
  return EXIT_SUCCESS;
}
/*0th*/
/*1th*/
/*2th*/
/*3th*/
/*4th*/
/*END: i == 5*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 0;
  for (i = 0; i < 10; ++i) {
    if (i > 4)
      continue;

    printf("%dth\n", i);
  }

  printf("END: i == %d\n", i);
  return EXIT_SUCCESS;
}
/*0th*/
/*1th*/
/*2th*/
/*3th*/
/*4th*/
/*END: i == 10*/
```

이것으로 알 수 있는 것은 다음으로 순회한다는 사실입니다. 그래서 9까지 순회합니다.

반복문을 안 끝내고 다음으로 넘어갑니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 0, j = 0;
  for (i = 0; i < 5; ++i) {
    printf("i == %d\n", i);
    for (j = 0; j < 5; ++j) {
      if (j > 2)
        break;
      printf("\t%dth\n", j);
    }
    printf("end\n\n");
  }

  return EXIT_SUCCESS;
}
```

1. 1 ~ 100까지 숫자 중에서 4의 배수가 몇개이며, 이들의 총합이 얼마인지 계산해 출력하는 프로그램을 작성하시오.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int count = 0, sum = 0;

  for (int i = 1; i <= 100; ++i) {
    if (i % 4 == 0) {
      count += 1;
      sum += i;
    }
  }

  printf("%d, %d\n", count, sum);

  return EXIT_SUCCESS;
}
/*25, 1300*/
```

2. 다음과 같이 '\*'을 출력하는 프로그램을 작성하세요.

```
                *
            *       *
        *       *       *
    *       *       *       *
*       *       *       *       *
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 1; i <= 5; ++i) {

    for (int j = 1; j <= 5 - i; ++j) {
      putchar('\t');
    }

    for (int j = 1; j <= i; ++j) {
      printf("*\t\t");
    }

    printf("\n");
  }

  return EXIT_SUCCESS;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 1; i <= 5; ++i) {
    for (int j = 0; j < 5; ++j) {
      if (5 - i > j)
        printf("\t");
      else
        printf("*\t\t");
    }
    printf("\n");
  }

  return EXIT_SUCCESS;
}
```

단 하나의 반복문으로 해결하는 방법은 이렇게 할 수 있습니다.

작업 횟수 자체는 동일합니다. 저의 사고 방식이 상당히 약합니다.

3. 다음 코드의 실행결과를 쓰시오.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 0;

  for (i = 0; i < 10; ++i) {
    if (i > 4)
      continue;
    printf("%dth\n", i);
  }

  printf("END: i == %d\n", i);
  return EXIT_SUCCESS;
}
/*0th*/
/*1th*/
/*2th*/
/*3th*/
/*4th*/
/*END: i == 10*/
```

4까지 출력함 마지막은 10을 출력함

4. 다음 코드에서 goto문을 제거하고 반복문을 이용해서 같은 결과를 얻을 수 있도록 프로그램을 변경하시오.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nInput = 0;

INPUT:
  printf("Input number : ");
  scanf("%d", &nInput);

  if (nInput < 0 || nInput > 10)
    goto INPUT;

  puts("End");

  return EXIT_SUCCESS;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;

  do {
    printf("Input number : ");
    scanf("%d", &nInput);
  } while (nInput < 0 || nInput > 10);

  puts("End");
  return EXIT_SUCCESS;
}
```

이렇게 하는 것으로 goto 문을 우회할 수 있습니다.

## 배열

타입이 같은 데이터 여러 개가 모여 새로운 하나를 이룬 형식입니다.

배열이 기존의 변수와 다른 점 중 하나는 배열의 이름은 변수의 이름과 달리 메모리의 주소라는 점입니다.

여러 요소를 대표하는 첫 번째 요소의 메모리 주소에 부여하는 식별자입니다.

다음은 배열이 해결하는 문제를 보고 배울 수 있게 해줍니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int a, b, c, d, e;

  scanf("%d%d%d%d%d", &a, &b, &c, &d, &e);

  printf("%d\n", a);
  printf("%d\n", b);
  printf("%d\n", c);
  printf("%d\n", d);
  printf("%d\n", e);

  return EXIT_SUCCESS;
}
/*1 2 3 4 5*/
/*1*/
/*2*/
/*3*/
/*4*/
/*5*/
```

문법문제는 없습니다. 유지보수 문제가 있습니다.

배열 연산자를 활용하면 됩니다. `배열이름[인덱스]`이 배열 연산자입니다.

인덱스는 0부터 총 개수의 -1개까지입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {0};
  int i = 0;

  for (i = 0; i < 5; ++i) {
    scanf("%d", &aList[i]);
  }
  for (i = 0; i < 5; ++i) {
    printf("%d\n", aList[i]);
  }

  return EXIT_SUCCESS;
}
/*1 2 3 4 5*/
/*1*/
/*2*/
/*3*/
/*4*/
/*5*/
```

이전보다 유지보수하기 쉬워집니다.

C 언어 배열은 zero-based index 입니다. 그래서 0번부터 4까지 인덱스가 지금 존재합니다.

배열요소도 변수를 의미합니다. 그래서 포인터 연산자로 주소를 접근해야 합니다.

### 1차원 배열의 기본 문법

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {10, 20, 30, 40, 50};
  int i = 0;
  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }
  putchar('\n');

  aList[0] = 100;
  aList[3] = 200;

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  return EXIT_SUCCESS;
}
/*10	20	30	40	50	*/
/*100	20	30	200	50	*/
```

배열연산의 결과는 L-value가 될 수 있습니다. 즉 변수가 될 수 있습니다.

대괄호 안에 배열의 요소를 명시한 숫자 `5`를 빼고 `int aList[] = { 10, 20, 30, 40, 50};`라고 기술해도 상관없습니다. 컴파일러가 소스코드에 기술된 초깃값의 개수를 판별한 후 요소의 개수를 자동으로 확정하기 때문입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {10, 20, 30, 40, 50};
  int i = 0;

  aList[0] = aList[4];
  aList[1] += aList[2];
  aList[4] = aList[3] * 2;

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  return EXIT_SUCCESS;
}
/*50	50	30	40	80*/
```

배열을 변수라고 생각하면 상당히 직관적입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {10, 20, 30, 40, 50};
  int aListNew[5] = {0};
  int i = 0;

  aListNew = aList;

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  return EXIT_SUCCESS;
}
```

린트부터 에러를 던집니다.

당연히 좌변이 피연산자가 아니라서 발생하는 문제입니다. 배열의 이름은 주소상수입니다. 상수는 읽기만 가능하고 쓰기를 할 수 없습니다. 즉 l-value가 아닙니다.

배열은 인덱스를 모은 덩어리라고 생각하면 주소를 모아둔 주소입니다. 즉 하나의 주소를 다루는 상황이 아닙니다. 배열 복제는 하나하나 값을 대입하면 됩니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {10, 20, 30, 40, 50};
  int aListNew[5] = {0};
  int i = 0;

  for (i = 0; i < 5; ++i) {
    aListNew[i] = aList[i];
  }

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aListNew[i]);
  }

  putchar('\n');
  return EXIT_SUCCESS;
}
/*10	20	30	40	50*/
```

### 최댓값/최솟값

가장 큰수를 찾는 선형탐색 알고리즘입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, nMax = aList[0];

  for (i = 1; i < 5; ++i) {
    if (aList[i] > nMax)
      nMax = aList[i];
  }

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  printf("MAX: %d\n", nMax);
  return EXIT_SUCCESS;
}
/*30	40	10	50	20	*/
/*MAX: 50*/
```

선형탐색이고 뭐 원포인터 문제라고 생각할 수 있습니다. 초기화를 0으로 하면 습관이 잘못된 것입니다. 불필요한 연산을 하기 때문입니다. 안해도 될 비교를 한번더 하게 되기 때문입니다.

또 1부터시작하는 이유는 이미 첫번째부터 포인터가 찍혀있는데 굳이 비교를 할 필요가 없습니다.

시험문제입니다. 위 코드에서 `nMax`를 사용할 수 없고 추가 변수를 만들 수 없습니다. 

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0;

  // 여기부터 코드를 작성할 수 있습니다.

  // 여기까지 코드를 작성할 수 있습니다.
  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  printf("MAX: %d\n", nMax);
  return EXIT_SUCCESS;
}
/*50	40	10	50	20	*/
/*MAX: 50*/
```

그냥 변수 취급하면 되는데 30분은 오버입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0;

  // 여기부터 코드를 작성할 수 있습니다.
  for (i = 1; i < 5; ++i) {
    if (aList[i] > aList[0])
      aList[0] = aList[i];
  }
  // 여기까지 코드를 작성할 수 있습니다.
  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  printf("MAX: %d\n", aList[0]);
  return EXIT_SUCCESS;
}
```

교환방식으로 최솟값 구하기 과제입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, nTmp = 0;

  // 여기부터 코드를 작성할 수 있습니다.
  
  // 여기까지 코드를 작성할 수 있습니다.
  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  printf("MIN: %d\n", aList[0]);
  return EXIT_SUCCESS;
}
/*10	40	30	50	20	*/
/*MAX: 10*/
```

값의 유실을 막는 것이 중요합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, nTmp = 0;

  // 여기부터 코드를 작성할 수 있습니다.
  for (i = 1; i < 5; ++i) {
    if (aList[i] < aList[0]) {
      nTmp = aList[0];
      aList[0] = aList[i];
      aList[i] = nTmp;
    }
  }
  // 여기까지 코드를 작성할 수 있습니다.
  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  printf("MIN: %d\n", aList[0]);
  return EXIT_SUCCESS;
}
/*10	40	30	50	20	*/
/*MAX: 10*/
```

이번에도 간단합니다.

