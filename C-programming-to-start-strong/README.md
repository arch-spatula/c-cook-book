# 필기

## Chapter 01 C 프로그래밍 입문

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  printf("Hello, World!\n");
  return EXIT_SUCCESS;
}
```

여기서 `#include <stdio.h>`은 전처리기(preprocesser)입니다. 처리는 컴파일 전입니다. `h`는 해더를 의미합니다.

C 언어가 라이브러리 코드를 가져오는 방법입니다. 컴파일 전에 필요한 부분을 가져와 전에 처리하고 기계어로 변환합니다.

프로그래밍은 문법적으로 맞는 것이 전부가 아닙니다. 논리적으로 올바르게 되어 있어야 합니다.

C 언어는 절차지향 프로그래밍 언어로 분류되었있습니다.

프로그램을 실행하면 `main` 함수를 실행하게 됩니다. `int`를 반환해야 합니다. 이 반환과 함께 프로그램은 종료합니다. 즉 `main`에서 시작해서 `main`에서 끝이 납니다.

함수의 목적은 계산과 동작 둘 중 하나 이상의 목적을 가질 수 있습니다.

매개변수와 인자는 컨택스트 구분을 위해서 올바르게 사용해야 합니다. 인자는 호출자가 넣은 값이라 호출자의 컨텍스트에서 논할 때입니다. 매개변수는 함수 정의자의 관점에서 논할 때입니다. 하지만 호출을 해서 넣은 값은 함수 정의 내에서 매개변수이기 때문에 본질적으로는 같습니다.

C 언어는 빌드 즉 컴파일 과정이 있습니다. `c` 확장자는 문서에 불과합니다. 소스코드입니다. 이 소스코드 파일을 목적파일 `obj`를 만듭니다. 이것은 실행파일이 실행할 부품이라고 비유할 수 있습니다. 이 부품들을 조립하는 과정을 보고 링크라고 합니다. 지금은 neovim 환경에서 커맨드라인으로 컴파일하고 있어서 잘 모릅니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  printf("010-1234-5678\n");
  printf("arch-spatula\n");
  return EXIT_SUCCESS;
}
```

ㅇㅇ

## Chapter 02 자료형

컴퓨터에게 모든 것은 본질적으로 수입니다. `0`과 `1` 이 이진수를 옵트코드와 오퍼랜드로 표현하는 어쎔블리에서 현재 하이레벨 언어로 여러 계층 추상화 되어 있는데 본질은 항상 수입니다.

기계는 그져 수를 처리할 수밖에 없습니다.

상수와 변수는 자료의 성격을 의미합니다.

정수와 실수는 자료의 형식을 의미합니다.

자료형은 자료의 구조를 나타내는 형식에 불과합니다.

상수는 2가지가 있습니다. 리터럴과 심볼릭입니다. 주로 변수 선언할 때 상수로 선언할 때는 형한정어를 사용한다고 합니다. 다른 심볼릭은 전처리기에서 제공하는 상수들입니다. 리터럴 상수는 상수 값들입니다.

```c
const int nMax = 100;
```

위는 형한정어를 사용해 정의한 상수입니다.

상수는 값 혹은 주소로 식별합니다. 문자열의 경우 주소로 식별하고 문자자체는 값으로 식별합니다.

변수는 적게 사용할수록 좋습니다. 프로그램을 작성하는 관점과 공간복잡성 관점 모두 해당합니다.

변수는 메모리로 구현됩니다. 변수를 선언하면 그 변수는 어느 메모리주소로 접근할 수 있게 해줍니다.

C 언어의 자료형은 크게 정수형, 실수형, 유도형, 함수형 정도입니다. `char`는 영문자, `int`는 정수, `double`은 실수를 다루기 위해 있습니다. 이정도부터 알아야 합니다.

<!-- @todo: 직접 표 작성하기 -->

컴퓨터는 덧셈과 뺄셈을 구현할 때 하드웨어 구조를 재사용합니다. 덧셈으로 숫자를 더하고 뺄셈도 덧셈 동작방식으로 구현합니다. 컴퓨터는 보수를 더하는 것으로 뺄셈을 구현합니다. 보수란 A라는 숫자가 B가 되기 위해 필요한 수입니다.

$$
\begin{align}

9 - 6 = 3

\end{align}
$$

이것은 일반적인 뺄셈법입니다.

$$
\begin{align}

9 + 3 = 13 = 13 - 10 = 3

\end{align}
$$

컴퓨터는 6이 10이 되기 위해 필요한 4(보수)를 더하는 방법으로 뺄셈을 구현합니다. 그리고 자릿수를 초과한 부분은 사라집니다. 그렇게 3을 구합니다. 즉 오버플로우 언더플로우를 활용합니다.

이것은 이진법으로도 동일하게 적용할 수 있습니다.

1의 보수는 모든 비트를 뒤집는다고 생각하면 됩니다. 2의 보수는 거기에 1을 더하면 됩니다.

$$
\begin{align}

00000001_{(2)}

\end{align}
$$

1에서 시작합니다.

$$
\begin{align}

11111110_{(2)}

\end{align}
$$

숫자 1에 대한 1의 보수입니다.

$$
\begin{align}

11111111_{(2)}

\end{align}
$$

숫자 1에 대한 2의 보수입니다.

여기 있는 2의 보수와 1을 더하면 -1을 빼는 것과 동일한 결과를 같습니다. 그리고 회로판은 덧셈 회로판만 활용하게 됩니다.

절댓값을 더하고 자리올림을 무시함으로 결과적으로 뺄셈을 구현합니다.

부호비트, 자료비트, 표현 범위는 직관적입니다.

부호비트는 MSB(최상위 비트, most significant bit) 보통 가장 왼쪽에 표시합니다. 그리고 남는 부분이 자료비트입니다. 0은 양수 1은 음수를 표현할 수 있게 됩니다.

예를 들어 8비트에 부호 비트를 포함하면 -128($-1 \cdot 2^{7}$)부터 127(2^{7} - 1)까지 표현할 수 있는 범위가 됩니다. 만약에 부호가 없다면 즉 `unsigned`라면 0부터 255($2^{8}-1$)까지 표현할 수 있게 됩니다. (255까지면 보통 컬러를 표현할 때 자주 봤을 것입니다. 컬러는 금융대출처럼 음수를 표현할 필요가 없습니다.)

표현범위를 초과하면 숫자 잘림 현상이 발생해 계산이 틀릴 가능성이 높습니다. 그래서 큰 수를 다룰 때는 주의해야 합니다.

```c
자료형 변수이름 = 초깃값;
int nDate = 10;
```

위 형태를 기억하기 바랍니다. 변수는 식별자입니다.

변수선언에 규칙이 있습니다.

- 영문 대소문자, `_`, 숫자로 만들어야 합니다.
- 첫글자가 숫자가 될 수 없습니다.
- 중간에 공백을 갖을 수 없습니다.
- 예약어로 변수를 사용할 수 없습니다.

| 예약어   | 설명                              | 예시 코드                                    |
| -------- | --------------------------------- | -------------------------------------------- |
| auto     | 지역 변수를 자동으로 저장         | `auto int num = 10;`                         |
| break    | switch 문이나 반복문을 종료       | `break;`                                     |
| case     | switch 문에서 조건을 지정         | `switch(num) { case 1: }`                    |
| char     | 문자 데이터 타입                  | `char ch = 'A';`                             |
| const    | 상수를 정의                       | `const int MAX = 100;`                       |
| continue | 반복문의 현재 반복을 건너뛰기     | `continue;`                                  |
| default  | switch 문에서 기본 동작 정의      | `default: break;`                            |
| do       | do-while 반복문 시작              | `do { } while (condition);`                  |
| double   | 더블형 실수 데이터 타입           | `double pi = 3.14159;`                       |
| else     | if 문의 다른 조건 정의            | `if (condition) { } else { }`                |
| enum     | 열거형 타입 정의                  | `enum Day { MON, TUE };`                     |
| extern   | 외부 변수 또는 함수 선언          | `extern int count;`                          |
| float    | 실수 데이터 타입                  | `float weight = 65.5;`                       |
| for      | 반복문 시작                       | `for (i = 0; i < 10; i++) { }`               |
| goto     | 레이블로 점프                     | `goto label;`                                |
| if       | 조건문 시작                       | `if (condition) { }`                         |
| int      | 정수 데이터 타입                  | `int age = 20;`                              |
| long     | 긴 정수 데이터 타입               | `long population = 5000000;`                 |
| register | 빠른 메모리 저장을 위한 변수 선언 | `register int count;`                        |
| return   | 함수 종료 및 반환                 | `return 0;`                                  |
| short    | 짧은 정수 데이터 타입             | `short num = 5;`                             |
| signed   | 부호 있는 데이터 타입 지정        | `signed int value = -10;`                    |
| sizeof   | 데이터 타입 또는 변수의 크기 반환 | `int size = sizeof(int);`                    |
| static   | 지역 변수를 정적으로 저장         | `static int count = 0;`                      |
| struct   | 구조체 타입 정의                  | `struct Person { char name[20]; int age; };` |
| switch   | 다중 분기 선택문 시작             | `switch(expression) { }`                     |
| typedef  | 사용자 정의 데이터 타입 정의      | `typedef int BOOL;`                          |
| union    | 공용체 타입 정의                  | `union Data { int i; float f; };`            |
| unsigned | 부호 없는 데이터 타입 지정        | `unsigned int score = 100;`                  |
| void     | 함수가 반환하지 않는 타입 지정    | `void func() { }`                            |
| volatile | 최적화 방지를 위한 변수 선언      | `volatile int flag;`                         |
| while    | 반복문 시작                       | `while (condition) { }`                      |

가독성 차원에서 준수해야 할 것들이 있습니다.

- 너무 긴 변수명은 안 좋습니다.
- 변수의 용도에 맞게 명명해야 합니다. 좌표를 `a`, `b`, `c`, 보단 `x`, `y`, `z`가 더 적절합니다.
- 의미없는 이름은 남용하지 않습니다.

컴퓨터에게 문자도 숫자입니다. 컴퓨터는 특정 숫자를 특정 문자로 취급하고 이것을 보고 부호체계라고 부릅니다.

ASCII는 현재 표준입니다. 과거에는 컴퓨터 제조사마다 부호체계가 다 달랐습니다.

7비트 코드 체계였습니다. 거기에 확장 비트 1개를 더해 8비트로 영어 글자 1개를 저장하고 표현했습니다.

내부적으로 컴퓨터에게 문자는 정수에 불과합니다. 문자는 C 언어에서 `char` 타입이고 부호 있는 8비트입니다.

```c
char ch  = 'A';
```

이것은 변수 선언입니다. 메모리 공간 8비트를 확보하고 선언해야 합니다.

`short`, `wchar_t`

`short`은 부호있는 16비트 정수입니다. `unsigned short`으로 선언해서 부호 없이 $0 ~ 2^{16}-1$ 형식으로 표현할 수 없습니다.

`wchar_t`은 문자하나를 저장하는 자료형입니다. 윈도우에서는 `short` 형과 같은 16비트입니다.

```c
short s = 1234;   // 정수는 보편적으로 int로 표현하지만 상수 표현할 때는 int, short을 구분하지 않음
wchar_t w = L'A'; // 문자 상수랑 다르게 앞에 L을 붙여야함
```

구분이 필요 없는 이유는 메모리의 크기와 값만 알면 항상 똑같이 처리하기 때문입니다.

`int`, `long`

`int`는 32비트 정수형입니다. 다루는 비즈니스 및 기술 도메인이 특수하지 않다면 가장 자주 사용하는 자료형입니다. 상수의 경우 접사도 없고 32비트 범위 내면 그냥 `int`입니다.

```c
#include <stdlib.h>
#include <wchar.h>

int main(void) {
	char ch = 'A';
	wchar_t wch = L'A';
	short sData = 10;
	int nData = 10;
	long lData = 10L;
	long int lnData = 10L;
	long long int llnData = 10LL;

	unsigned char byNewData = 0;
	unsigned short sNewData = 65535U;
	unsigned int uNewData = 1U;
	unsigned long int ulNewData = 1UL;
	unsigned long long int ullNewData = 1ULL;

	return EXIT_SUCCESS;
}
```

실수 자료형은 부동 소수점을 표현해야 합니다.

컴퓨터가 정수를 표현하고 비트 단위크기차이는 있어도 해석방법은 같고 숫자는 명확합니다. 정수와 정수 사이 실수는 애매합니다.

실수는 수학적으로 그 사이에 무한하게 존재할 수 있습니다. 이 무한한 표현을 메모리의 유한한 공간에 정확히 표현하기는 어렵습니다. 여기부터 컴퓨터는 일정 수준의 부동 소수점 오차를 전제로 다양한 표현을 합니다. 구체적인 내용 모두 언제가는 알기는 해야 합니다.

하지만 가장 중요한 것은 부동 소수 과련 오차입니다.

컴퓨터는 일정 수준까지만 표현을 확정하고 더 정밀한 숫자는 범위상 가까운 수로 인식하기로 했습니다.

과거에는 컴퓨터 제조사마다 부동 소수점 처리를 각각의 방식으로 했습니다. IEEE 754 스펙이 부동 소수점 표준안입니다.

소수점 표현을 위해 32비트 단정도, 64비트 배정도 및 79비트(80비트 구현) 확장 배정도 형식에 대해 표준을 규정했습니다.

| 크기    | 자료형        | 표현 범위                                                                    |
| ------- | ------------- | ---------------------------------------------------------------------------- |
| 32비트  | `float`       | $1.17 \cdot 10^{-38} ~ 3.4 \cdot 10^{38} $ 유한 자릿수 소수점 이하 6자리     |
| 64비트  | `double`      | $2.22 \cdot 10^{-308} ~ 1.79 \cdot 10^{308} $ 유한 자릿수 소수점 이하 15자리 |
| 128비트 | `long double` | `double` 이상                                                                |

`float`형은 32비트 단정도형입니다. 여기서 단정도라고 하는데 그냥 single을 의미합니다. 소수점은 6번째자리까지 표현합니다. 7번째부터 부정확한 숫자로 활용하지 말아야 합니다.

부호 비트 1비트 + 지수부 8비트 + 기수부 23비트 = 32비트

- 실제 실수형 계산작없을 많이 해야 하면 `double`형을 사용할 것을 권장합니다.
- 실수형은 부호 표기를 무조건 포함하기 때문에 앞에 U가 붙지 않습니다.
- f를 붙이지 않으면 double 형이고 상수로 취급됩니다.

`double`은 일반적인 실수를 의미합니다. 하지만 여전히 한계가 있습니다. 15번째 자리까지 유효합니다. 또 자동 상수로 형변환을 하는데 정확성 때문입니다.

부호 비트 1비트 + 지수부 11비트 + 기수부 52비트 = 64비트

```c
// DoubleRange.c
#include <float.h>
#include <stdio.h>
#include <stdlib.h>

int main(void) {

	double dData = 123.456;

	printf("%f\n", dData);
	printf("%E - %E\n", DBL_MIN, DBL_MAX);

  return EXIT_SUCCESS;
}

// 123.456000
// 2.225074E-308 - 1.797693E+308
```

첫번째 출력은 `float`로 취급해서 소수 6번째 자리까지 보여줍니다.

또 `double`의 최대 최소 범위를 보여주고 있습니다.

C 언어를 배울 사람들이 배웠다고 착각하는 것 중 하나가 문자열입니다. 문자열은 정확히 문자(배)열입니다. 여러 문자 인스턴스의 집합입니다. 문제는 본질이 배열인데 다른 자료형처럼 인스턴스가 1개라는 착각입니다. 가변길이 자료형이라 다른 자료형보다 고려할 것이 많습니다.

배열은 1개의 메모리상 존재하는 인스터가 아니라 여러 메모리 인스턴스를 하나로 묶어둔 것입니다. 개별 인스턴스는 이름이 아니라 주소에 이름이 부여된 것입니다.

```c
#include <stdlib.h>

int main(void) {

  char ch1 = 'A', ch2 = 'B', ch3 = 'C';
  char szData[4] = {'A', 'B', 'C'};
  char szNewData[4] = {"ABC"};

  return EXIT_SUCCESS;
}
```

`ch1`, `ch2`, `ch3`는 3개의 개별문자 상수입니다.

`szData`는 4개의 문자를 담은 배열입니다. 인스턴스 4개를 갖습니다. 또 초깃값(`A`, `B`, `C`)도 명시하고 있습니다. 명시하지 않으면 0이 됩니다.

`szData`는 `szNewData`랑 의미상 같습니다. 물론 메모리 주소는 다릅니다.

왜 4로 선언했는데 3개만 활용하는가? 둘다 문자열 끝에 null 문자(`\0`)가 들어갑니다. 즉 null 문자를 포함해야 합니다. 그래야 문제열이 끝났음을 알려 줄 수 있습니다.

프로그램 소스코드는 그자체로 문서입니다. 사람이 읽기 때문에 가독성이 중요합니다. 가독성 좋은 코드야 말로 진정한 기본기입니다. 또 이름짓기와 주석이야 말로 기본 중 기본입니다.

이름은 다르게 부르면 식별자라고 부르기도 합니다. 변수는 코드의 식별자 ID의 역할을 합니다. 이름으로 목적을 알수 있게 작성해야 합니다. 이름 짓기를 할 때 변수의 목적을 다시 생각하면서 작성하도록 합니다.

주석은 실행하지 않습니다. 개발자의 메모에 불과합니다. 하지만 상당히 중요합니다. 코드만으로 설명이 가능하기는 해야 하지만 그렇지 못한 경우도 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

/*
 * 이 구간의 코드는 모두 주석
 */

int main(void) {

	// 결과를 저장하는 변수
	int nResult = 10;
	char ch = 'A'; // 사용자 입력

	// printf("Hello, World!\n");

	return EXIT_SUCCESS;
}
```

소스코드는 회사 문서입니다. 가독성을 위한 노력이 중요합니다.

1. 변수는 프로그램이 실행하면서 값이 바뀔 수 있는 값을 의미
2. 자료형은 데이터를 표현하는 형식
3. 자료형, 변수명, 초깃값
4. `10`은 음수 부호를 갖을 수 있게 부호 비트 1비트와 자료 비트 7비트를 할당합니다. 하지만 `10U`은 부호가 없음으로 음수표현 지원 없이 자료 비트 8비트로 할당합니다.
5. ASCII
6. `&nData`은 `nData` 변수의 주소를 의미합니다. 즉 우변(RValue 만 있어야 할 자리)에서 좌변(LValue)의 값인 주소를 접근하는 표현입니다.

## Chapter 03 표준 입출력 도구

UX 혹은 HCI는 결국에는 프로그래머 입장에서는 입출력을 기반으로 합니다.

사용자의 입력을 얼마나 의도에 맞게 정확히 전달하는가가 관건입니다.

### 문자 입출력

영문 한 글자는 `char`입니다. 내부적으로 8비트 정수입니다. 8비트 정수라 덧셈 뺄셈도 가능합니다. 이것을 다시 기억하도록 합니다.

`int getchar()`는 인자가 없습니다. 표준입력장치 버퍼 메모리에서 한글자를 읽어오는 함수입니다. 버퍼 메모리가 비어있으면 유저에게 입력을 받아 채운 후 반환합니다. 주의할 점은 `char`을 반환할 것처럼 생겼는데 `int`를 반환합니다. 크기 차이를 제외하면 결국 모두 정수입니다.

`int putchar(int c)` 표준 출력장치인 콘솔에서 영문 한 글자를 출력합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;

  ch = getchar();

  putchar(ch);
  putchar('Z');

  return EXIT_SUCCESS;
}
// h
// hZ%
```

`getchar`는 입력을 받기위해 1번 대기 했습니다. 그리고 `putchar`는 출력에 사용되었습니다. 기존에 입력 받은 것을 출력하고 또 `Z`앞에 저장한 문자열을 출력했습니다.

여기서 `ch` 처음 초기화 했을 때 값은 사라지고 사용자의 입력을 받은 값을 저장 혹은 복사하게 됩니다.

대부분의 함수는 인자로 대입하면 변수 그자체가 아니라 변수의 정보를 매개변수로 전달하게 됩니다.

```c
#include <stdio.h>
#include <stdlib.h>
/*#include <conio.h>*/
/*#include <curses.h>*/

int main(void) {
  char ch = 0;
  printf("아무 키나 누르면 다음으로 넘어갑니다. \n");

	/*ch = getch();*/
  printf("입력한 키는 ");
  putchar(ch);
  printf("입니다.\n");
  return EXIT_SUCCESS;
}
```

위 코드는 동작하지 않을 것입니다. 먼저 `<conio.h>`는 윈도우에서만 제공합니다. 맥에서는 `<curses.h>`을 따로 설치해야 합니다.

[why does this error occur: 'conio.h' file not found](https://stackoverflow.com/questions/67320428/why-does-this-error-occur-conio-h-file-not-found)

위를 보면 그렇습니다.

```sh
brew install ncurses # curses 파일 설치
```

`_getch()` 혹은 `_getche()` 함수는 Non-buffered I/O 합니다. 버퍼를 안 거치고 전달합니다. 어떤 키라도 입력이 있으면 즉시 반환합니다.

### 문자열 입출력

문자열은 문자의 배열입니다. `H`, `e`, `l`, `l`, `o`, `\0` 문자들을 묶는 것이 문자열입니다. 이런 표현은 일일이 입력하기 귀찮습니다. 그래서 `"Hello"`라고 표현합니다. 이렇게 표현해도 문자의 배열로 취급합니다.

문자를 다루는 것과 문자열을 다루는 것의 차이는 한 인스턴스(`char`)를 다루는 것과 인스턴스(`char[n]`)을 묶어서 다루는 것의 차이입니다.

배열의 이름은 일반 변수의 이름과 달리 메모리의 주소에 부여한 식별자입니다. `char szName[32]`은 `char`이 32개인 배열입니다. `szName`은 주소를 접근할 식별자입니다.

배열의 이름은 주소입니다.

주소를 저장하는 변수는 포인터입니다. 배열을 활용하면 포인터도 같이 활용하는 경우가 많습니다.

`char *gets(char *buffer)` / `int puts(const char *string)` 함수는 문자열을 입출력 해주는 함수입니다.

`gets()`는 버퍼 즉 입력받은 문자를 저장할 메모리 주소를 인자로 받습니다. 반환입니다. 에러는 `NULL` 성공은 받은 메모리 주소입니다. 목적은 표준입력장치의 문자열을 받는 함수입니다.

`puts()`는 출력할 문자열이 저장된 메모리의 주소입니다. 반환입니다. 정상이면 음수가 아닌 정수입니다. 에러는 `EOF`입니다. 표준출력장치에 문자열을 출력하는 것이 목적입니다.

`getchar()`, `putchar()`과 다릅니다. 인자가 포인터입니다. `gets()`는 저장될 메모리 주소입니다. `puts()`는 출력할 메모리 주소를 접근하고 화면에 출력합니다.

다음은 가장 전형적인 문자열 입출력 예지입니다. SDL 검사에 주의하기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_BUF_SIZE 32

int main(void) {
  // char 변수 32개가 한 덩어리로 묶인 배열 선언
  char szName[MAX_BUF_SIZE] = {0};

  // 사용자로부터 이름(문자열)을 입력받는다.
  printf("이름을 입력하세요: ");
  /*
   * 사용자가 입력한 문자들을 문자 배열에 모두 저장
   * gets은 보안 결함이 있습니다.
   * gets_s은 윈도우 전용입니다.
   */
  fgets(szName, MAX_BUF_SIZE, stdin);

  // 배열에 저장된 이름을 화면에 출력
  printf("당신의 이름은 ");
  puts(szName);
  puts("입니다.");

  return EXIT_SUCCESS;
}
```

과거에 쓰던 `gets()` 함수는 키보드 입력 버퍼를 검사합니다. 버퍼가 비어있으면 사용자의 문자열을 입력받아 저장합니다. `gets()`는 인자가 1개입니다. 이 인자는 버퍼에서 저장된 문자열을 인자(`szName`)에 복사합니다. 이미 버퍼에 정보가 있었다면 별도로 사용자 입력을 안 받습니다.

`gets` 함수는 보안 결함을 갖고 있습니다. 버퍼로 받은 문자열의 메모리 주소와 문자열이 저장될 메모리의 바이트 단위 크기를 인자로 넣고 제어하는데 문제가 있습니다. 책의 예제는 `gets` 대신에 `gets_s`를 권장했습니다. 저는 `fgets`를 사용했습니다.

`gets`의 문제는 버퍼 오버플로우로 버퍼 오버런 공격이 가능합니다. 이 보안 취약점 등급은 심각한 수준입니다. 허가 받지 않은 원격 사용자가 관리자 권한을 얻는 사고입니다.

```c
#include <stdio.h>
#include <stdlib.h>


int main(void) {
  // char 변수 32개가 한 덩어리로 묶인 배열 선언
  char szName[32] = {0};

  // 사용자로부터 이름(문자열)을 입력받는다.
  printf("이름을 입력하세요: ");
  /*
   * 사용자가 입력한 문자들을 문자 배열에 모두 저장
   * gets은 보안 결함이 있습니다.
   * gets_s은 윈도우 전용입니다.
   */
  fgets(szName, sizeof(szName), stdin);

  // 배열에 저장된 이름을 화면에 출력
  printf("당신의 이름은 ");
  puts(szName);
  puts("입니다.");

  return EXIT_SUCCESS;
}
```

도서의 예제는 `sizeof`를 알려줍니다. 보안 결함이 될 가능성이 있는 행위 즉 배열의 경계를 넘어서 사용이 허가된 메모리 이상을 사용하는 경우입니다. 이 경우 예외를 발생시킵니다. 프로그램이 비정상 종료되는 것 같아도 해킹을 방어할 수 있게 됩니다.

`sizeof`는 메모리의 크기를 측정하는 연사자입니다. 지금은 `char` 32 개를 바이트 단위로 계산하는 경우입니다. `char`는 1 바이트라 총 32바이트에 해당합니다.

`printf`는 콘솔 기반으로 정보 출력할 때 가장 많이 사용하는 함수 중 하나입니다. 문자, 숫자(정수, 실수), 문자열 모두 출력이 가능합니다.

```c
int printf(const char *format [, argument]...);
```

`printf` 시그니쳐를 보면 제대로 활용을 위해 형식 문자열(format string)을 이해해야 합니다. 형식 문자열은 문자열, 형식 문자, 이스케이프 시퀀스로 구성됩니다.

시그니쳐를 잘 보면 가변인자입니다. 인자의 개수가 형식 문자의 개수와 일치해야 합니다.

형식 문자는 출력할 정보의 자료형과 밀접하게 관련되어 있습니다. 형식문자열과 인자를 조합해서 최종 문자열을 만드는 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 10;

  /* 문자상수를 화면에 출력 */
  putchar('B');

  /* '\n'은 개행문자이므로 알파벳 문자가 화면에 보이지 않을 것 */
  putchar('\n');

  /* 개행 문자 출력 이후 A와 개행문제를 출력 */
  printf("%c\n", 'A');

  /* %d라는 형식 문자에 맞춰 변수 x에 담긴 정보 출력 */
  printf("x는 %d 입니다.\n", x);

  return EXIT_SUCCESS;
}
```

`printf`를 사용하면 각종 안내 문구를 조합하고 출력이 가능합니다. `putchar`, `puts`로는 언젠가 비슷한 결과를 만들어도 `int`를 출력할 수 없습니다.

`%d`은 10진수(decimal)를 의미합니다. 단순하지만 자주 사용합니다.

| 형식 문자 | 자료형             | 설명                                               |
| --------- | ------------------ | -------------------------------------------------- |
| `%c`      | `char`             | 문자를 출력 및 입력할 때 사용                      |
| `%d`      | `int`              | 정수를 출력 및 입력할 때 사용                      |
| `%o`      | `int`              | 정수를 8진수로 출력할 때 사용                      |
| `%u`      | `unsigned int`     | 부호 없는 정수를 출력 및 입력할 때 사용            |
| `%x`      |                    | 정수를 16진수로 출력할 때 사용                     |
| `%e`      | `float or double`  | 지수 형식의 실수를 출력할 때 사용                  |
| `%f`      | `float`            | 실수를 출력 및 입력할 때 사용                      |
| `%g`      | `float or double`  | 값에 따라 `%f` 또는 `%e`를 선택하여 출력할 때 사용 |
| `%p`      | `void`             | 포인터의 주소 값을 출력할 때 사용                  |
| `%s`      | `char[]` or `char` | 문자열을 출력 및 입력할 때 사용                    |
| `%a`      | `float or double`  | 16진수 부동소수점을 출력할 때 사용                 |
| `%n`      | `int`              | 출력된 문자의 개수를 저장할 변수를 지정할 때 사용  |

`%s`는 문자열 즉 메모리 주소를 받아 출력하기만 합니다. 자료형 정보와 출력이 올바르게 일치하지 않으면 컴파일러는 어떤 경고도 안해줍니다.

`%`을 출력하고 싶은 경우 `%%`으로 이스케이프 해야 합니다.

문자와 정수 출력

C 언어 정수 표시에 사용하는 자료형은 `char`, `short`, `int`, `long`, `long long int`입니다. `char`, `int`은 `%c`, `%d`으로 나타냅니다.

ASCII 코드 영문 `'A'`는 10진수로 65이고 16진수로 `0x41`입니다. 65는 10진수 정수이고 `int`입니다. `'A'`은 `char`이고 상수입니다. `'A'`의 본질은 10진수 65라 정수인가? 반대로 65가 `char`가 아닌가?

`char`와 `int`는 부호있는 정수라는 점이 같습니다. 길이가 8비트, 32비트만 다릅니다. `%c`과 `%d` 모두 `int` 다루는 것을 원칙으로 합니다. 그냥 `char`가 크기를 작게 다룰 뿐입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // 문자상수를 ASCII 코드 문자형으로 출력
  printf("%c\n", 'A');      // A
  // 문자 'A'의 ASCII 코드값(65)에 1을 더한 값을 문자로 출력
  printf("%c\n", 'A' + 1);  // B
  // 문자상수를 ASCII 코드 문자형으로 출력
  printf("%c\n", 'C');      // C

  // 문자 'A'의 ASCII 코드값을 10진수(%d)로 출력
  printf("%d\n", 'A');      // 65
  // 문자 'A'의 ASCII 코드값에 1을 더하고 10진수(%d)로 출력
  printf("%d\n", 'A' + 1);  // 66
  // 문자상수를 ASCII 코드값을 10진수(%d)로 출력
  printf("%d\n", 'C');      // 67

  // 10진수(정수)를 문자(ASCII)로 출력
  printf("%c\n", 65);       // A
  printf("%c\n", 65 + 1);   // B
  printf("%c\n", 67);       // C

  return EXIT_SUCCESS;
}
```

본질은 `char`, `int`가 모두 부호 있는 정수입니다. 정보의 본질은 달라지는 것이 아니라 출력 형식만 변경하는 것으로 다른 정보로 인식합니다.

`%d` 부호가 있으면 `char`, `short`, `int` 모두 숫자로 출력합니다.

`%u`은 부호가 없으면 32비트로 표시할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // int형 상수 10을 10진 부호가 있는 정수형식으로 출력
	printf("%d\n", 10);
	// 10을 '부호가 없는' 정수형식으로 출력
	printf("%u\n", 10);
	// unsigned int 상수 10U을 %d 형식으로 출력
	printf("%d\n", 10U);
	// unsigned int 상수 10U을 %u 형식으로 출력
	printf("%u\n", 10U);

	// 부호가 있는 32비트 정수로 표현할 수 있는 가장 큰 수
	printf("%d\n", 2147483647);
	// 부호가 있는 32비트 정수로 표현할 수 있는 '범위를 넘어선' 정수를 출력
	printf("%d\n", 2147483648);
	// 부호가 있는 32비트로 정상 출력
	printf("%u\n", 2147483649);

	// -1을 부호있는 10진수로 출력
	printf("%d\n", -1);
	// 같은 값(-1)이지만 부호가 없는 형식으로는 전혀 다른 값 출력
	printf("%u\n", -1);

  return EXIT_SUCCESS;
}
```

이렇게 작성하면 컴파일부터 막힙니다. 비트 오버플로우 비트 언더플로우 문제를 컴파일러가 감지합니다.

32비트 단위로 표현할 수 있는 것을 넘습니다.

부호가 있으면 너무 작습니다. 하지만 부호가 없으면 43억 미만입니다. 물론 통계 프로그램을 작성하는 지금시대에도 작은 단위입니다.

더큰 자료형을 다룰 때는 `long long int`로 해결해야 합니다.

$$
\begin{align}

-2^{63} ~ 2^{63} - 1

\end{align}
$$

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // 부호 있는 64비트 변수 정의
  long long int lldData = 4294967295LL;

  // 64비트 정보를 32비트 문자로 출력
  printf("d\n", lldData);
  printf("u\n", lldData);

  // 32비트로 표현할 수 없는 범위의 정보 출력
  printf("%u\n", lldData + 1);
  printf("%u\n", lldData + 2);
  printf("%u\n", lldData + 3);

  // 64비트 정보를 64비트 형식 문자(%lld)로 출력
  printf("%lld\n", lldData + 1);
  printf("%lld\n", lldData + 2);
  printf("%lld\n", lldData + 3);

  return EXIT_SUCCESS;
}
```

역시나 컴파일에러가 또 발생할 것입니다.

`%ld`와 `%lld`의 차이는 비트 응용프로그램의 차이입니다. 32비트로 응용 프로그램을 운용하는지 64비트로 응용 프로그램을 운용하는지는 다릅니다.

10억 단위 정수를 다룰 때는 `long long int`와 `%lld`를 활용할 것을 권장합니다.

참고로 형식문자는 자릿수, 폭 제한, 왼쪽 정렬 처럼 form을 제어하는 기능을 갖고 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  printf("%d\n", 1234);
  printf("%d, %d\n", 1234, -5678);
  // 부호를 붙여 출력
  // +을 출력하는 것은 아님
  printf("%+d, %+d\n", 1234, -5678);

  // 정수를 8자리로 맞추고 오른쪽 정렬
  printf("%8d\n", 1234);
  // 오른쪽 정렬하고 공백은 0으로 채움
  printf("%08d\n", 1234);
  // 왼쪽 정렬
  printf("%-8d\n", 1234);

  return EXIT_SUCCESS;
}
```

출력을 포맷팅할 수 있습니다.

실수와 지수 출력

자료형에 부동소수점 표현도 다루었는데 출력은 안다루는가? 다룹니다. 컴퓨터의 특성은 우리가 이론적으로만 알고 있는 것입니다.

정수는 부호를 구분했습니다. 실수는 실수 출력과 지수출력을 구별할 수 있습니다. 정수처럼 표현 범위가 달라지거나 부호개념이 사라지는 경우는 없습니다. `%f`, `%e`만 다를 뿐입니다.

`F`붙으면 `float` 실수형이고 없으면 `double`입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // 실수 자료형의 메모리 사이즈 출력
  printf("%d\n", sizeof(123.456F)); // 4
  printf("%d\n", sizeof(123.456));  // 8

  // float 형을 실수형으로 출력
  printf("%f\n", 123.456F); // 123.456001

  // double형을 실수형으로 출력
  printf("%f\n", 123.456);  // 123.456000
  printf("%lf\n", 123.456); // 123.456000

  return EXIT_SUCCESS;
}
```

`%f`는 `float`이고 `%lf`는 `double`에 해당하는 출력 형식입니다. `printf` 함수에서는 구분을 안해도 괜찮습니다.

하지만 `scanf`는 구분해야 합니다. `float`형이라도 부동 소수점 오차는 있습니다. 이 실수단위 연산 혹은 출력에서 부동소수점 오차는 문제입니다.

형식 문자와 가변인자를 잘못연결하는 실수가 없어야 합니다. 실수 출력은 문법만 다룰 것이 아니라 부동소수점 오차도 같이 논해야합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  printf("%f\n", 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F + 0.1F +
                     0.1F);  // 4.999998
  return EXIT_SUCCESS;
}
```

심각한 오류입니다. 0.000002이 부족합니다. 실수 연산은 가능하면 `float`보단 `double`을 활용할 것을 권장합니다. 15번째 정보까지 신뢰할 수 있습니다.

`%f`를 출력할 때 주의할 점은 소수점을 표시하는 것입니다. 더 많이 혹은 덜 표시할 수 있습니다. 자동으로 반올림할지도 모릅니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  double dData = 123.456;
  printf("%f, %f\n", dData, -123.456); /*123.456000, -123.456000*/

  // 소수점 반올림
  printf("%.1f\n", dData); /*123.5*/
  printf("%.2f\n", dData); /*123.46*/
  printf("%.3f\n", dData); /*123.456*/

  printf("%8d\n", dData);  // 컴파일 에러

  // 소수점을 포함해 12자리출력 소수점 4번째에서 반올림하고 3번째자리까지 출력
  printf("%12.3f\n", dData);  /*     123.456*/
  printf("%012.3f\n", dData); /*00000123.456*/

  return EXIT_SUCCESS;
}
```

`%(전체_자리).(소수점_최대길이)f`

위 형식을 따릅니다. 최대길이를 벗어나면 자동으로 반올림처리합니다. 이것은 개발자의 주의해야 합니다.

실수를 다룰 때 다양한 전략이 있는데 먼저 정책으로 정수를 먼저 활용하게 만드는 것입니다. 성적표의 평균을 계산하는 것보다 총점을 합산하는 것이 더 쉬울지도 모릅니다. 현실에서는 시키는데로 해야 하기 때문에 무조건 평균을 활용해야 하면 다른 전략은 곱셈으로 정수단위가 되게 만들어서 계산을 처리하면 됩니다. 단지 성능문제가 발생할 것이 문제입니다.

### `scanf` 함수

```c
int scanf(const char *format [, argument]...);
```

형식 문자열에 맞추어, 표준입력장치(`stdin`)로부터 정보를 읽어들이는 함수입니다. 가변인자는 사용자가 입력한 값이 저장될 메모리의 주소들입니다.

`format`: 형식 문자열이 저장된 메모리 주소
`[, argument]`: 형식 문자열에 대응하는 가변인자

인력할 문자열의 개수를 반환합니다. 유효하게 입력했는지 확인할 때 활용해볼 수 있습니다.

주의해야할 점은 형식 문자에 대응하는 가변인자는 모두 주소입니다.

`scanf` 함수의 가변인자는 모두 메모리 주소가 되어야 합니다. 이것은 `gets` 함수와 동일합니다. 매개변수로 주소를 대입하는 방식은 C 언어에서 자주 등장합니다.

사용자 나이(정수)를 받고 출력하는 예제입니다. 또 보안문제도 있을 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nAge = 0;
  printf("나이를 입력하세요. :");
  scanf("%d", &nAge);
  printf("당신의 나이는 %d세 입니다.\n", nAge);
  return EXIT_SUCCESS;
}

// 정상적인 경우 (정수 입력)
// 나이를 입력하세요. :10
// 당신의 나이는 10세 입니다.
// 비정상적인 경우 (문자열 입력)
// 나이를 입력하세요. :asdf
// 당신의 나이는 0세 입니다.
```

사용자의 입력을 해석할 수 없고 전달된 주소로 식별되는 메모리를 담아주지 않습니다.

오픈북으로 문제를 풀었습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int age = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d", &age);
  while (getchar() != '\n') {
    continue;
  }

  char name[32] = {0};
  printf("\n이름을 입력하세요. : ");
  scanf("%s", name);
  while (getchar() != '\n') {
    continue;
  }

  printf("\n 당신의 나이는 %d살이고 이름은 \'%s\'입니다.\n", age, name);

  return EXIT_SUCCESS;
}
```

문제 풀이해설을 설명하기 전에 풀이 과정을 보여줍니다.

여기서 주의할 점은 기본 입출력이 불가능하면 아무것도 할 수 없습니다.

기본 입출력은 암기라도 해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("%d", nInput);

  printf("Input : %d\n", nInput);
  return EXIT_SUCCESS;
}
```

저는 작성할 때부터 린트가 주소를 넣으라고 알려줬습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("%d\n", &nInput);

  printf("%d\n", nInput);
  return EXIT_SUCCESS;
}
```

여기서 문제는 문자를 입력해야 입력이 종료 됩니다.

`getchar`, `gets`, `scanf` 세 함수 모두 키보드 입력을 완료하기 위해 엔터키를 입력 받아야 합니다. 하지만 `scanf`는 함수의 형식 문자열로 개행문자(`\n`)를 넣는 것은 잘못된 것입니다. 입력을 완료하기 위해 개행문자와 문자가 요구하는 개행문자는 구분할 수 없습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("Input : %d", &nInput);

  printf("Input : %d\n", nInput);
  return EXIT_SUCCESS;
}
```

여기서 입력하면 항상 `0`이 될 것입니다. 하지만 `Input : `을 앞에 붙이면 숫자를 받을 것입니다.

형식문자열로 표준입력에서 받는데 사용자가 입력을 알 수 있게 하는 것이 아닙니다. `printf`랑 `scanf` 함수를 혼동하면 큰일납니다.

지금까지는 입력을 1개만 입력받고자 했습니다. 이번에는 2개를 입력 받아보겠습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0, y = 0;
	printf("두 정수를 입력하세요. : ");

  scanf("%d%d", &x, &y);

  printf("두 수의 합은 %d입니다.\n", x + y);
  return EXIT_SUCCESS;
}
```

공백으로 구분해서 숫자 2개 입력하면 잘 동작할 것입니다. 붙여서 입력하면 이해할 것이라고 착각하는데 아닙니다.

띄어쓰기는 화이트 스페이스(탭, 개행문제, 스페이스바)에 해당합니다. 눈에 안보이고 존재하는 문자입니다. 고려해서 문자열 길이에 포함해야 합니다.

`Hello\n`은 개행문자를 포함해서 6개입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;
  scanf("%c", &ch);
  printf("입력한 문자는 %c 입니다.\n", ch);
  return EXIT_SUCCESS;
}
```

위 코드는 보안취약점을 갖고 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[32] = { 0 };
  scanf("%s", szBuffer);
  printf("%s\n", szBuffer);
  return EXIT_SUCCESS;
}
```

하지만 한계가 있습니다. `%s`은 공백 문자를 포함해서 입력받을 수 없습니다. 뭐 여러개받는 것도 전략이지만 효율적이지 않을 것 같습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBufferLeft[32] = { 0 };
  char szBufferRight[32] = { 0 };
  scanf("%s%s", szBufferLeft, szBufferRight);
  printf("%s %s\n", szBufferLeft, szBufferRight);
  return EXIT_SUCCESS;
}
```

이렇게 여러개 받을 수 있게 변수를 추가합니다. 문제는 변수를 1억개를 추가할 것인가?

공백을 포함하고 싶으면 `gets`를 활용합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szName[32] = {0};
  int nAge = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d", &nAge);

  printf("이름을 입력하세요. : ");
  gets(szName);

  printf("%d, %s\n", nAge, szName);
  return EXIT_SUCCESS;
}
```

보안 문제를 여전히 갖고 있습니다. 나이를 문자로 입력하면 버퍼에 남아있고 `gets`가 접근하는 문제가 있습니다. 그래서 이름 입력을 못하게 됩니다.

참고로 gcc는 컴파일을 못하게 막습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szName[32] = {0};
  int nAge = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d%*c", &nAge);

  printf("이름을 입력하세요. : ");
  fgets(szName, sizeof(szName), stdin);

  printf("%d %s\n", nAge, szName);
  return EXIT_SUCCESS;
}
```

위는 조금더 안전하게 처리하는 방법입니다.

`%*c`이 나중에 추가된 형식 문자입니다. 문자 하나를 입력 버퍼로 읽고 그 후에 버린다는 의미입니다. 그리고 이 방법은 다양한 운영체제 호환성 문제가 없습니다.

동작하는 원리가 `scanf`는 엔터를 입력하면서 개행문자를 보고 입력의 종료로 판단하는데 숫자는 꺼내도 개행문자는 계속 갖고 있습니다. 하지만 `%*c`은 문자에 속한 개행문자를 버리겠다는 의미로 버퍼는 비워지고 `fgets`로 문자열을 입력할 수 있게 됩니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int age = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d%*c", &age);

  char name[32] = {0};
  printf("\n이름을 입력하세요. : ");
  fgets(name, sizeof(name), stdin);

  printf("\n 당신의 나이는 %d살이고 이름은 \'%s\'입니다.\n", age, name);

  return EXIT_SUCCESS;
}
```

정확한 정답은 위와 같아집니다.

1. `getchar()` 함수를 호출하고 사용자 입력을 받는데 4글자 이상 입력 받고 그 중에 두번째 글자만 출력합니다.

요구사항은 3개입니다. 글자 4개이상 받아야 합니다. 그리고 두번째 글자를 접근합니다. 접근할 글자를 출력합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int count = 0;
	char buf = 0;
	printf("입력 : ");
  while (buf != '\n') {
		buf = getchar();
    count += 1;
		if (count == 2) {
			printf("출력 : %c\n", buf);
		}
  }
  if (count < 4) {
    printf("4개 이하 문자를 입력했습니다.\n");
  }
  return EXIT_SUCCESS;
}
```

2. `getchar` 함수와 `_getch` 함수가 내부적으로 다른 점은 무엇이 다른가?

`getchar` 함수는 Buffer IO를 하고 `_getch` 함수는 Non-Buffer IO를 합니다. 버퍼 메모리를 직접 접근하는 것과 입력 여부에 대한 감지가 다릅니다.

3. `gets` 함수는 보안결함이 있습니다. 이 함수를 대체할 수 있는 것들은 무엇인가?

`fgets`로 대체가 가능합니다.

4. 만일 부호가 있는 10진 정수형 표현할 수 있는 가장 큰 양수 범위를 1넘어서면 컴퓨터는 이를 어떤 숫자로 인식하는지 기술하시오.

```c
#include <stdio.h>

int main(void) {
  char num1 = 127;
  char num2 = 128;
  printf("%d\n", num1); // 127
  printf("%d\n", num2); // -128
  return 0;
}
```

위처럼 동작하게 되는 이유입니다.

편의를 위해 8비트 단위로 설명하겠습니다. 8비트면 0부터 2의 8제곱에서 1이 부족한 127까지입니다. 하지만 부호 비트가 있으면 최대 양수는 127까지입니다.

$$
\begin{align}

01111111_{(2)}

\end{align}
$$

127을 이진수로 표현하면 위와 같습니다. 여기서 1을 더하면 오버플로우 현상이 발생해서 양수가 음수가 됩니다.

$$
\begin{align}

10000000_{(2)}

\end{align}
$$

이 오버플로우 현상은 -1이 아닙니다. 가장 낮은 -128입니다. 넘겨진 숫자는 버려지고 회전하게 됩니다. 숫자를 원으로 생각하면 직관적일 것입니다.

5. 부호가 없는 10진 정수 형식과 부호가 있는 10진 정수 형식을 출력하기에 적절한 형식문자는 각각 무엇인가?

```c
printf("부호 없는 10진 정수 %u", 10U);
printf("부호 있는 10진 정수 %d", 10);
```

6. `123.45` 자료형은 무엇인가? 그리고 이 값을 출력하기에 적절한 형식 문자는 무엇인가?

자료형은 `double`입니다.

```c
printf("%d\n", 123.45);
```

7. 형식 문자 `%012.3F`가 의미하는 것은 무엇인지 기술하시오.

총 12자리가 있는 실수표현에서 소수점 3째자리까지 보여주고 4째는 반올립처리하고 왼쪽 정렬을 하는데 0으로 채웁니다.

8. 배열에 담긴 문자열을 출력하려 합니다. 적절한 형식 문자는 무엇인가?

```c
printf("%s\n", i);
```

문자열은 `%s`으로 출력하는데 이것을 뭐 순회해서 출력하는 것을 묻는지 모르겠습니다.

9. `scanf` 함수로 정수를 입력받은 후, 입력 버퍼에 남은 개행문자를 제거하려합니다. 전략은 무엇이 있는가?

```c
scanf("%d%*c", &num);

while (getchar() != '\n') {}
```

10. 만일 `nInput`이 정수형 변수라면 다음 코드는 무엇이 잘못되었는가?

```c
scanf("%d", nInput);
```

두번째 인자로 주소를 대입해야 하는데 값을 대입하고 있습니다.

11. `scanf` 함수로 `double`로 입력받으려고 합니다. 적절한 형식문자는 무엇인가?

```c
double num1 = 123.456;
scanf("%lf\n", &num1);
```

이렇게 처리합니다.

## Chapter 04 연산자 - 기본

자료형과 변수의 저장은 메모리 중 RAM와 관련되어 있습니다. 지금부터 다룰 연산자는 메모리가 아닌 CPU의 작업과 직결됩니다.

프로그래밍의 본격적인 부분은 여기서부터입니다.

연산자와 피연산자 그리고 항입니다. `3 + 4`의 항은 총 3개입니다. 피연산자 3, 4 연산자 `+`으로 모두 개입니다.

피연산자 항만 감안하면 2개입니다. 주로 피연산자를 칭하기 때문에 `+`은 2개의 피연산자가 필요해서 2항 연산자라고 부릅니다.

C 언어는 단항 연산자부터 3항 연산자까지 있습니다.

| 우선순위 | 연산자                                                             | 결합성 |
| -------- | ------------------------------------------------------------------ | ------ |
| 1        | `()`, `.`,`[]`, `->`                                               | →      |
| 2        | `*`, `&`, `!` `++`, `--`, `(datatype)`, `sizeof - `,               | ←      |
| 3        | `*`, `%`, `/`                                                      | →      |
| 4        | `+`, `-`                                                           | →      |
| 5        | `<<`, `>>`                                                         | →      |
| 6        | `<`, `<=`, `>`, `>=`                                               | →      |
| 7        | `==`, `!=`                                                         | →      |
| 8        | `&`                                                                | →      |
| 9        | `^`                                                                | →      |
| 10       | `\|`                                                               | →      |
| 11       | `&&`                                                               | →      |
| 12       | `\|\|`                                                             | →      |
| 13       | `?:`                                                               | ←      |
| 14       | `=`, `+=`, `-=`, `*=`, `%=`, `/=`, `&=`, `\|=`, `^=`, `<<=`, `>>=` | ←      |
| 15       | `,`                                                                | →      |

위는 우선순위입니다. 표전전체를 암기하는 것이 시험문제입니다. 우선순위는 당연히 맞추고 연산자의 순서까지 암기하세요. 우선순위가 같으면 방향으로 결합성 방향 순으로 처리합니다. 하지만 여러분은 상대평가하기 위해서 연산자 순서에 무조건 집중해서 암기하세요.

수학 시간이 아니지만 교환법칙은 알아야 합니다. 덧셈 연산은 교환법칙이 성립합니다. `3 + 4`와 `4 + 3`은 결과가 같습니다. 항의 자리를 교환해도 문제가 없으면 교환법칙이 성립한다고 합니다. 곱셈도 성립합니다. 하지만 성립하지 않는 연산자도 있습니다.

### 산술 연산자

`+`, `-`, `*`, `/`, `%` 뭐 특별한 거 없습니다. 수학이랑 같습니다.

뭐 특별히 알아야 할 것은 연산의 임시결과입니다. 이 임시 결과는 CPU 레지스터에 연산 결과를 저장하고 처리하고 저장한 레지스터를 갱신하고 처리가 끝나면 다시 메모리에 쓰기를 하는 것을 의미합니다. 이런거는 일반인도 교양 다큐나 유튜브에서 다 보는 내용입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nResult = 0;

  nResult = 3 + 4 - 5;

  printf("nResult: %d\n", nResult);
  return EXIT_SUCCESS;
}
```

뭐 결과가 2가 될 거라는 것은 눈으로 보고 알 수 있습니다. 하지만 2가 될 것이라고 처리하는 과정은 CPU가 메모리에서 순서대로 읽고 처리하고 레지스터의 값을 메모리 쓰기하는 문제입니다.

처음에 연산자 우선순위가 같은 덧셈, 뺄셈입니다. 여기서 왼쪽에서 시작에서 오른쪽으로 처리하고 마지막에 할당으로 왼쪽으로 흐릅니다. 피연산자 `3`, `4`를 먼저 레지스터합니다. 그리고 더하기 작업을 수행합니다. 결과로 7을 레지스터에 저장합니다. 다음 `-`은 작업 레지스터 `5`는 오퍼랜드 레지스터에 적재합니다. 작업을 수행하고 `2`로 저장했던 레지스터를 갱신합니다. 마지막으로 `2`를 `nResult`의 주소에 레지스터에 있던 값을 쓰기를 합니다.

뭐 어쎔블리 생각하는 그대로 이해하면 됩니다. 여기서 임시 저장이라고 하는데 CPU가 작업할 대상인 레지스터입니다. 정상적인 프로그래밍을 하려면 이 레지스터에 저장하면서 작업을 수행한다는 것을 알고 있어야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nResult = 0;

  nResult = 3 + 4;

  printf("nResult: %d\n", nResult - 5);
  return EXIT_SUCCESS;
}
```

이거는 화면에 출력 전에 메모리 주소에서 값을 가져오고 연산하고 결과를 보여주는 경우입니다.

C 언어는 수동으로 처리해주는 기본에 충실한 언어입니다. 기계의 특성을 고려한 이론이 기본입니다. 수동으로 처리하는 것 중하나는 이형자료 사이 연산입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  char ch = 'A';
  printf("%c\n", ch);

  printf("%c\n", ch + 1);
  printf("%c\n", 'A' + 1);

  /*printf("%d\n", 5.0 + 2);*/
  printf("%f\n", 5.0 + 2);
  return EXIT_SUCCESS;
}
```

컴파일러 에러 때문에 주석처리했습니다. 하지만 `double`과 `int`를 더하면 `double`로 승격됩니다. 그리고 `char`는 원래 본질은 `int` 인데 지금은 `char`로 출력해서 `char`가 나옵니다. 과거에 시도했던 예제가 이미 이형간 연산이었습니다.

`char`와 `int`를 더할 때 레지스터에는 어떻게 저장하는가? `int`로 저장합니다. 뭐 생각해보면 숫자를 처리하기 더 쉬운데 굳이 어려운 자료형을 사용해야 하는가? 이런 생각을 해볼 수 있습니다. 하지만 이런 원칙을 기준으로 생각하면 됩니다. 임시결과의 자료형은 연산에 참여한 피연산자 중 정보 표현 범위가 더 넓은 자료형으로 변환합니다. 이런 원칙을 기준으로 `int`와 `double` 중 `double`이 되는 것이 말이 됩니다. 추측 해보면 `float`와 `double`을 같이 더하면 `double`이 될 것입니다.

연산의 결과가 피연산자의 자료형보다 표현범위가 넓은 형으로 변환되는 현상을 형승격(type promotion)이라고 부릅니다.

참고로 `int`와 `char` 사이 `int`로 표현범위가 같은데 `int`로 승격되는 것을 것을 integral promotion이라고 부릅니다.

C 언어는 개발자가 모든 것을 알고 있다고 가정합니다. 연산이나 정보 출력에 이런 내부 현상을 고려하는 것은 기본입니다.

곱셈 나눗셈도 크게 다른 것은 작습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int x = 10;
  printf("%d\n", x * 10);       // 100
  /*printf("%d\n", x * 10.0);*/ // 출력 자료형 컴파일 에러
  printf("%d\n", x / 10);       // 1

  printf("%d\n", 5 / 2);        // 2
  /*printf("%f\n", 5 / 2);*/    // 출력 자료형 컴파일 에러
  printf("%f\n", 5.0 / 2);      // 2.500000

  return EXIT_SUCCESS;
}
```

여기서 형승격의 일반적인 원리를 잘 이히해면 됩니다.

나눗셈에서 주의할 점은 정수와 정수로 나누면 정수입니다. 굳이 형승격할 이유가 없습니다. 소수점은 그냥 절사 처리하고 끝냅니다.

수학적으로 당연한 말이지만 0으로 나눌 수 없습니다.

프로그래밍의 기본은 예외처리입니다. 프로그래밍 하루만 배워도 다음과 같은 실수 안 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  printf("정수를 입력하세요. : ");

  scanf("%d", &nInput);

  printf("%d\n", 10 / nInput);
  return EXIT_SUCCESS;
}
// 정수를 입력하세요. : 0
// 0
```

gcc 컴파일러가 내부적으로 안전하게 처리한 것 같습니다. 원래 에러가 발생하고 비정상적인 종료를 할 거라고 예상했는데 아니었지만 0에 대해서 예외처리를 올바르게 했어야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  printf("두 정수를 입력하세요. : ");
  // 입력 10, 20
  int num1 = 0, num2 = 0;
  scanf("%d%d", &num1, &num2);
  // 출력 15.00
  printf("AVG : %.2f\n", (num1 + num2) / 2.0);
  return EXIT_SUCCESS;
}
// 두 정수를 입력하세요. : 10 20
// AVG : 15.00
```

간단한 연습 문제입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0;
  scanf("%d", &x);
  printf("몫: %d\n", x / 3);
  printf("나머지: %d\n", x % 3);
  return EXIT_SUCCESS;
}
/*17*/
/*몫: 5*/
/*나머지: 2*/
```

나머지 연산자에서 주의할 점은 나머지 연산자의 피연산자로 실수를 사용할 없다는 점입니다. `12.3 % 3`, `12.3f % 3` 이런 연산은 허용되지 않습니다.

나머지 연산자는 덧셈, 뻴셈보다는 높고 곱셈, 나눗셈과 같습니다.

프로그래머에게 나머지 연산자는 수학적으로 나머지를 구하는 것말고 공학적으로 문제 해결에 사용하는 훌륭한 도구입니다.

나머지 연산은 제수만큼 경우의 수를 갖습니다. 이것은 문제해결에 유용한 수학적 성질입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int sec = 0;
  scanf("%d", &sec);
  printf("%d초는 %02d시간 %02d분 %02d초 입니다.\n", sec, sec / (60 * 60),
         sec % (60 * 60) / 60, sec % 60);
  return EXIT_SUCCESS;
}
/*4000*/
/*4000초는 01시간 06분 40초 입니다.*/
```

뭐 어려운 문제는 아닙니다.

### 대입 연산자

`=` 이 대입 연산자는 그냥 보면 별거 없습니다. 하지만 내부의 동작 방식을 이해해보면 우변의 있는 변수들의 값을 메모리에서 읽고 연산자들에 따라 처리하고 처리하는 동안 레지스터에 저장하고 있다가 좌변 메모리 주소에 쓰기를 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0, nInput = 0;
  scanf("%d", &nInput);

  x = nInput;

  printf("%d\n", x);
  return EXIT_SUCCESS;
}
```

표준입력으로 정수를 입력하면 정수를 `x` 변수에 저장할 것이라는 것을 알고 있습니다.

지금은 원래 `0`으로 써져있던 메모리 주소에 사용자가 입력한 `10`으로 덮어 써졌다는 것입니다. 쓰기를 위해 L-value이고 좌변입니다. 읽기를 위해 우변에서의 변수를 R-value라고 합니다. 좌변인지 우변인지에 따라 주소를 읽고 값을 접근하는 것인지 레지스터에 저장했던 값을 특정 메모리 주소에 쓰기를 하는 것인지 다릅니다.

L은 Left도 의미하지만 locator(위치 지정자)를 의미하기도 합니다.

정보를 담을 수 없으면 L-value가 아닙니다. 정보를 담는다는 표현에 변수를 보고 상자라고 하는데 여기서 이렇게 비유하는 이유를 바로 알 수 있게 됩니다.

```c
#include <stdlib.h>

int main(void) {

  char szBuffer[32] = {0};

  3 = 4;  // 컴파일 에러

  szBuffer = 'A'; // 컴파일 에러

  return EXIT_SUCCESS;
}
```

딱히 컴파일 할 것은 아니지만 정보를 담을 수 없는 피연산자에 대입연산자를 사용하려고 하고 있습니다.

배열의 이름은 메모리 주소라고 배웠습니다. 즉 L-value가 아닙니다. 상수이고 `szBuffer`에 쓰기를 할 수 없습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 10, y = 20, nTemp = 0;
  printf("Before : x=%d, y=%d\n", x, y);

  nTemp = x;
  x = y;
  y = nTemp;

  printf("After  : x=%d, y=%d\n", x, y);
  return EXIT_SUCCESS;
}
/*Before : x=10, y=20*/
/*After  : x=20, y=10*/
```

메모리 배우면 이런 응용은 바로 가능해야 합니다. 어처구니 없게 설명을 굳이해주면 다음과 같습니다. `x`가 들고 있던 값은 임시 메모리 주소 `nTemp`에 저장합니다. 그러면 지금부터 `x`에 `y`를 할당해도 문제가 없습니다. 그래서 바로 할당합니다. `y`가 갖고 있던 값을 `x`에 저장하면 `y` 변수는 덮어 써도 됩니다. 원래 `x`의 값을 저장했던 `nTemp`의 값을 `y`에 저장합니다. 이렇게 되면 두 변수의 값을 바꿉니다.

이런 거는 처음배우면 바로 할 수 있어야 합니다.

복합 대입 연산자입니다. 그냥 연산자 2개 합친 것입니다. 연산하고 할당하고 2개의 연산을 하는 것입니다. 연산자 표현만 1개입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nResult = 0, nData = 10;

  nResult += 3;
  printf("%d\n", nResult); // 3

  nResult *= nData;
  printf("%d\n", nResult); // 30

  nResult /= 2;
  printf("%d\n", nResult); // 15

  nResult -= 5;
  printf("%d\n", nResult); // 10

  nResult %= 3;
  printf("%d\n", nResult); // 1

  return EXIT_SUCCESS;
}
```

할당하고 그 후에 대입하는 것입니다. 뭐 특별한 것은 없습니다.

연산 우선순위가 낮고 결합성은 오른쪽에서 윈쪽으로 향합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0, y = 0;
  x = y = 10;
  printf("%d, %d\n", x, y); // 10, 10
  return EXIT_SUCCESS;
}
```

꽤나 충격적입니다. 하지만 논리적으로 불만은 없습니다. `10`이라는 값을 `y`에 쓰고 `y`라는 값을 `x`에 쓰기를 하는 것입니다. 이렇게 쓰기를 하는 이유는 직렬로 코드를 일을 때 `x = (y = 10)` 여기서 `y = 10`이고 여기서 `10`이라는 값을 확인하고 `y`에 저장하고 저장한 `y`값을 또 `x`에 쓰기를 하는 것입니다. 결합성의 방향에서 할당을 할 때는 오른쪽에서 왼쪽이고 실행 순서를 결정할 때는 오른쪽을 먼저 올립니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0, nTotal = 0;

  scanf("%d", &nInput);
  nTotal += nInput;

  scanf("%d", &nInput);
  nTotal += nInput;

  scanf("%d", &nInput);
  nTotal += nInput;

  printf("Total :%d\n", nTotal);

  return EXIT_SUCCESS;
}
/*1*/
/*2*/
/*3*/
/*Total :6*/
```

당연한 말이지만 누적 대상이 되는 변수는 `0`으로 초기화해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nResult; // 그냥 0으로 초기화 안하고 컴파일러 에러 발생

  nResult += 10;
  nResult += 10;
  nResult += 10;

  printf("Result :%d\n", nResult);
  return EXIT_SUCCESS;
}
```

gcc가 컴파일 에러를 발생시킵니다.

### 형변환 연산자

형변환(type cast)를 지원하는 연산자들이 있습니다. 연산자들 중 우선순위가 높습니다. 산술연산자(`+`, `-`, `*`, `/`, `%`)과 중첩되면 형변환이 우선입니다.

형변환은 주의해야 하는 행동인데 아무렇지 않게 많이 합니다. 형변환은 강제로 변환을 합니다. 올바른면 큰문제 없겠지만 틀린 형변환을 하면 정보의 손실과 큰 논리적 오류를 만들 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 5;

  printf("%d\n", 5 / 2);           // int / int    -> int
  printf("%f\n", 5.0 / 2);         // double / int -> double
  printf("%f\n", 5 / 2.0);         // int / double -> double
  printf("%f\n", (double)5 / 2);   // double / int -> double
  printf("%f\n", (double)x / 2);   // double / int -> double
  printf("%f\n", x / (double)2);   // int / double -> double
  printf("%f\n", (double)(x / 2)); // double

  return EXIT_SUCCESS;
}
/*2*/
/*2.500000*/
/*2.500000*/
/*2.500000*/
/*2.500000*/
/*2.500000*/
/*2.000000*/
```

타입 승격을 통한 형변환입니다.

당연한 말이지만 실수형을 정수형으로 형변환하면 소수점 이하 정보는 모두 절사됩니다. 표현할 방법도 없고 표현해야 할 이유도 보통 없으니 삭제합니다.

### 단항 증감 연산자

자주 보이는 `++`, `--`을 단항 증감 연산자라고 지칭합니다. 하지만 기본 전제는 당연하지만 피연산자가 L-value 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 10;

  x = x + 1;
  printf("%d\n", x); // 11

  x += 1;
  printf("%d\n", x); // 12

  ++x;
  printf("%d\n", x); // 13

  return EXIT_SUCCESS;
}
```

크게 특별한 것은 없습니다. 그냥 전위연산, 후위연산만 주의하면 됩니다. 전위연산은 우선순위가 높지만 후위연산자는 우선순위가 거의 최하에 가깝습니다. 할당연산자보다 낮은 편입니다.

`++`은 1단위로 누적해서 계수(counting)이라 표현하는 경우가 많습니다.

당연한 말이지만 계수기 역할을 하는 변수는 연산하기 전에 초기화해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 0, nResult = 0;

  ++x;
  printf("%d\n", x);

  x++;
  printf("%d\n", x);

  nResult = ++x;
  printf("%d, %d\n", nResult, x);

  nResult = x--;
  printf("%d, %d\n", nResult, x);

  return EXIT_SUCCESS;
}
// 1
// 2
// 3, 3
// 3, 2
```

후위연산이 할당 보다 느리다는 것을 보면 충격적입니다. 그래서 `nResult`는 `3`이고 `x`는 감산을 해서 `2`가 됩니다. 감산하기 전에 할당하고 할당 뒤에 감산을 처리한 것입니다.

우위연산은 실수할 것이라고 생각이 든다면 사용금지를 컨벤션으로 정하고 전위연산만 하는 방법도 있습니다.

### 비트 연산자

비트 연산자는 일정 길이의 메모리에 담긴 2진수 정보를 말 그대로 비트 단위로 계산하는 연산자입니다.

- C 언어가 제공하는 비트 연산자는 AND(`&`), OR(`|`), NOT(`~`), shift left(`<<`), shift right(`>>`)입니다. 단항 연산자인 NOT(`~`)을 제외하면 모두 이항연산자입니다.

비트 단위 상수를 작성할 때는 보통 16진수를 사용합니다.

다음예시는 비트단위로 변환하고 비교하기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nData = 0x11223344;

  printf("%08x\n", nData & 0x00FFFF00);
  printf("%08x\n", nData | 0x2211FFFF);
  printf("%08x\n", nData ^ 0x2211FFFF);
  printf("%08x\n", ~nData);
  printf("%08x\n", nData >> 8);
  printf("%08x\n", nData << 16);

  return EXIT_SUCCESS;
}
/*00223300*/
/*3333ffff*/
/*3333ccbb*/
/*eeddccbb*/
/*00112233*/
/*33440000*/
```

```
     1    1    2    2    3    3    4    4
  0001 0001 0010 0010 0011 0011 0100 0100
     0    0    f    f    f    f    0    0
& 0000 0000 1111 1111 1111 1111 0000 0000
     0    0    2    2    3    3    0    0
  0000 0000 0010 0010 0011 0011 0000 0000
```

16진수는 1자리당 4자리 이진수로 표현할 수 있습니다. AND 연산을 하면 모두 1이어야 통과 됩니다. 지금 예시 직관적입니다. 가운데 2233만 그대로 전달되고 1144는 0으로 제거 되었습니다.

```
     1    1    2    2    3    3    4    4
  0001 0001 0010 0010 0011 0011 0100 0100
     2    2    1    1    f    f    f    f
| 0010 0010 0001 0001 1111 1111 1111 1111
     3    3    3    3    f    f    f    f
  0011 0011 0011 0011 1111 1111 1111 1111
```

OR는 둘중 1개라도 true(1)이면 true(1)이 됩니다. 상당히 직관적입니다.

```
     1    1    2    2    3    3    4    4
  0001 0001 0010 0010 0011 0011 0100 0100
     2    2    1    1    f    f    f    f
^ 0010 0010 0001 0001 1111 1111 1111 1111
     3    3    3    3    c    c    b    b
  0011 0011 0011 0011 1100 1100 1011 1011
```

XOR는 모두 true(1)이면 false(0)가 됩니다.

```
     1    1    2    2    3    3    4    4
~ 0001 0001 0010 0010 0011 0011 0100 0100
     e    e    d    d    c    c    b    b
  1110 1110 1101 1101 1100 1100 1011 1011
```

NOT은 1을 0으로 0을 1로 뒤집는다고 생각하면 됩니다.

```
     0    0 |    1    1    2    2    3    3 |    4    4
  0000 0000 | 0001 0001 0010 0010 0011 0011 | 0100 0100
     0    0      1    1    2    2    3    3
  0000 0000   0001 0001 0010 0010 0011 0011
```

시프트 연산은 값을 통으로 이동 시키는 것입니다. `>>` 오른쪽으로 8 즉 16진수에서 2자리 2진수에서 8자리를 이동시킨 것입니다. 이동을 위해 `0`으로 채우는데 이것을 보고 패딩이라고 합니다.

```
     1    1    2    2 |    3    3    4    4 |    0    0    0    0
  0001 0001 0010 0010 | 0011 0011 0100 0100 | 0000 0000 0000 0000
                           3    3    4    4      0    0    0    0
                        0011 0011 0100 0100   0000 0000 0000 0000
```

`<<` 왼쪽으로 밀어낸 것입니다. 16진수에서 4자리만큼 2진수에서 16자리 만큼 밀어낸 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nData = 0x11223344;

  printf("%08x\n", nData & 0xFFFF0000);
  printf("%08x\n", nData & 0x00FFFF00);
  printf("%08x\n", nData & 0x0000FFFF);
  printf("%08x\n", nData & 0xFF0000FF);

  return EXIT_SUCCESS;
}

/*11220000*/
/*00223300*/
/*00003344*/
/*11000044*/
```

1. 연산의 중첩에서 연산의 '임시결과'란 무엇을 의미하며, 임시 결과의 가장 중요한 특징은 무엇인가?

임시결과 작업을 처리할 때 CPU 레지스터에 담고 할당을 결정할 때 레지스터에서 메모리에 쓰기를 합니다. 임시 결과의 가장 중요한 특징은 우선순위입니다.

2. `char` 자료형은 `int` 자료형 사이 `+`를 수행하면 임시 결과의 자료형으 무엇인가?

표현 범위가 더 넓은 자료형으로 타입승격이 발생하지만 `char`와 `int`는 표현 범위가 같습니다. 표현 범위가 같은데 `char`와 `int` 사이 연산이 있으면 내부적으로 `char`를 `int`로 타입승격을 시키고 계산을 처리하고 `int`로 저장합니다.

3. 2번 문제는 같은 현상을 부르는 용어는 무엇이며, 이형자료 사이 연산에 임시 결과에 대한 자료형이 결정되는 근거는 무엇인가?

이 현상은 타입승격이라고 부릅니다. 자료형이 다른 것 사이 연산이 있으면 임시 결과는 표현범위가 더 넓은 타입으로 타입 승격을 시키고 처리하고 저장합니다. 타입 승격으로 표현 범위가 더 넓은 자료형으로 변환하는 이유는 정보 손실을 덜하기 때문입니다. 범위가 작으면 정보 손실이 발생합니다. 하지만 넓은 쪽을 선택하면 메모리 공간상 점유량이 늘어납니다.

4. `5 / 2`의 연산 결과의 자료형과 값은 무엇인가?

`int`이고 `2`입니다.

5. 사용자로부터 정수 입력받아 5로 나눈 나머지를 출력하는 프로그램을 작성하시오.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int input = 0;

  scanf("%d%*c", &input);

  input %= 5;

  printf("%d\n", input);

  return EXIT_SUCCESS;
}
```

6. 대입 연산자의 왼쪽 피연산자가 될 수 있는 자격을 갖춘 대상을 부르는 용어는 무엇인지 답하시오.

L-value

Locater value로 위 값인데 여기서 말하는 위치는 메모리 주소입니다.

7. 다음 코드의 실행결과는 무엇니가?

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  printf("%08x\n", 0xFFFFFFFF & 0x00080000);
  printf("%08x\n", 0xAAAABBBB & 0x00080000);
  printf("%08x\n", 0xAABBCCDD & 0x00080000);

  printf("%08x\n", 0xFFFFFFFF | 0x00080000);
  printf("%08x\n", 0x11223344 | 0x00080000);
  printf("%08x\n", 0x00000000 | 0x000F0000);

  return EXIT_SUCCESS;
}
/*00080000*/
/*00080000*/
/*00080000*/
/*ffffffff*/
/*112a3344*/
/*000f0000*/
```

## Chapter 05 연산자 응용

숫자 계산처럼 생겨먹은 거는 아닌데 연산자인 것들이 있습니다. `sizeof`는 컴파일러 수행하고 CPU가 실행하지 않는 특수한 연산합니다. 이번에 다룰 연산자들은 중요하고 반드시 알아야 하고 주의할 점들을 학습니다.

### `sizeof` 연산자

`sizeof`의 피연산자는 자료형입니다. `sizeof(5)`는 `sizeof(int)`입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nData = 10;

  printf("%d, %d, %d\n", sizeof(5), sizeof(nData), sizeof(int));
  printf("%d, %d\n", sizeof('A'), sizeof(char));
  printf("%d, %d\n", sizeof(123.45F), sizeof(123.45));

  printf("%d, %d\n", sizeof(nData + 10), sizeof(++nData));
  printf("%d\n", nData);

  return EXIT_SUCCESS;
}
/*4, 4, 4*/
/*4, 1*/
/*4, 8*/
/*4, 4*/
/*10*/
```

`gcc`에서 컴파일러 경고가 많아 힘들게 컴파일했습니다.

`sizeof(nData + 10)`을 보면 연산식을 계산하고 계산 결과의 타입을 `sizeof`의 피연산자로 활용합니다. 식 전체는 피연산자가 아닙니다. 상당히 당연하지만 컴파일러와 프로그램 관점에서는 아닙니다. 컴파일러가 계산을 처리한다는 것은 프로그램이 실행해야 할 영역을 대신하는 것입니다.

`sizeof` 내에서 전위 단항연산자로 더해도 `nData`는 더해지지 않았습니다. 즉 `sizeof(++nData)`는 실행된 것이 아닙니다.

`sizeof`는 런타임에 실행하지 않고 컴파일 타임에 실행하는 연산자입니다. 그래서 성능 문제가 없습니다. 많이 사용할수록 좋은 연산자입니다. 사용할 때 모미리 사이즈를 정하고 생각하기 좋은 연산자입니다.

### 관계 연산자

관계 연산자는 두 피연산자의 값을 비교해 참(`True`, `1`) 혹은 거짓(`False`, `0`)의 결과를 내는 연산자입니다.

| 연산식   | 분류     | 의미                             |
| -------- | -------- | -------------------------------- |
| `A == B` | 상등연산 | A는 B와 같다(즉, 뻴셈 결과가 0). |
| `A != B` | 부등연산 | A는 B와 같지 않다.               |
| `A > B`  | 비교연산 | A는 B보다 크다.                  |
| `A < B`  | 비교연산 | A는 B보다 작다.                  |
| `A >= B` | 비교연산 | A는 B보다 크거나 같다(B 이상).   |
| `A <= B` | 비교연산 | A는 B보다 작거나 같다(B 이하).   |

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 5, y = 10;

  printf("%d\n", x == y);
  printf("%d\n", x != y);
  printf("%d\n", x > y);
  printf("%d\n", x < y);

  printf("%d\n", y >= 10);
  printf("%d\n", y <= x + 5);

  return EXIT_SUCCESS;
}
/*0*/
/*1*/
/*0*/
/*1*/
/*1*/
/*1*/
```

크게 어려운 것은 없습니다.

비교연산자는 내부적으로 뺄셈을 한다고 생각해볼 수 있습니다. 0인지 아니면 부호가 반대인지 확인하는 것을 응용했을 것이라고 알 수 있습니다.

만약 문자열을 배열에을 비고해야 하면 원소단위로 비교해야 합니다. 이런 비교는 전용함수를 사용해야 합니다. `memcmp()`과 `strcmp()` 함수가 존재합니다.

관계 연산에서 주의해야 할점은 있습니다. 자료형이 같아야 합니다. 정수와 상수를 비교하면 엉뚱한 결과를 얻습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  printf("%d\n", 300 == 299.99999F);
  printf("%d\n", 300 == 299.99999);
  printf("%d\n", 300 == 299.9999);
  printf("%d\n", 300 == 300.00001F);
  return EXIT_SUCCESS;
}
/*1*/
/*0*/
/*0*/
/*1*/
```

모두 당연히 다릅니다. 하지만 일부는 같다고 여기고 있습니다. 실수형이 같다고 간주하고 있습니다.

### 논리 연산자

논리합(OR), 논리곱(AND)는 다른 프로그래밍 언어와 비슷합니다. `||`이 합인데 이 `|` 기호를 보고 pipe이라고 부릅니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nInput = 0, bResult = 0;

  scanf("%d%*c", &nInput);
  bResult = nInput < 4 || nInput >= 60;

  printf("Result : %d (1:True, 0:False)\n", bResult);

  return EXIT_SUCCESS;
}
/*42*/
/*Result : 0 (1:True, 0:False)*/
```

논리합은 하나라도 참이면 모두 참이 됩니다.

하지 않아도 될 연산을 생략하여 논리식의 효율을 높이는 것을 쇼트서킷(short circuit)이라고 합니다. 이 경우 참이 나올 때까지 평가할 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nInput = 0, bResult = 0;

  scanf("%d%*c", &nInput);
  bResult = nInput > 3 && nInput < 20;

  printf("Result : %d (1:True, 0:False)\n", bResult);

  return EXIT_SUCCESS;
}
/*17*/
/*Result : 1 (1:True, 0:False)*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nInput = 0, bResult = 0;

  scanf("%d%*c", &nInput);
  bResult = 3 < nInput < 20;

  printf("Result : %d (1:True, 0:False)\n", bResult);

  return EXIT_SUCCESS;
}
```

린트부터 바로 에러를 알려줍니다. 어떤 값을 입력해도 1은 20보다 작으니 항상 True라고 할 것입니다. 여기서 범위를 표현하고 싶으면 `3 < nInput && nInput < 20`이라고 작성하면 됩니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nInput = 0, bResult = 0;

  scanf("%d%*c", &nInput);
  bResult = !nInput;

  printf("Result : %d (1:True, 0:False)\n", bResult);

  return EXIT_SUCCESS;
}
/*0*/
/*Result : 1 (1:True, 0:False)*/
```

부정은 너무 많이 사용하지 않습니다. 극단적으로 많으면 논리적으로 혼란을 만들 가능성이 많습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nAge = 0, nHeight = 0;

  printf("나이를 입력하세요. : ");
  scanf("%d%*c", &nAge);
  printf("키를 입력하세요. : ");
  scanf("%d%*c", &nHeight);

  printf("결과 : %d (1:합격, 0:불합격)\n",
         nAge >= 20 && nAge <= 30 && nHeight >= 150);

  return EXIT_SUCCESS;
}
/*나이를 입력하세요. : 29*/
/*키를 입력하세요. : 180*/
/*결과 : 1 (1:합격, 0:불합격)*/
```

AND는 `false`를 찾을 때 까지 처리합니다. OR는 반대로 `true`를 찾을 때까지 처리합니다. 모두 왼쪽에서 오른쪽 순서대로 처리합니다.

혼합식 즉 섞여있는 경우 OR와 AND로 한번 묶고 처리합니다.

### 삼항 연산자

`조건식 ? A : B` 이게 끝입니다. C 언어의 유일한 삼항 연산자가 조건 연산자입니다. 항이 모두 3개입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0, nSelect = 0;
  scanf("%d", &nInput);

  nSelect = nInput <= 10 ? 10 : 20;
  printf("%d\n", nSelect);

  return EXIT_SUCCESS;
}
/*5*/
/*10*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0, nSelect = 0;
  scanf("%d", &nInput);

  /*nInput <= 10 ? nSelect = 10 : nSelect = 20; // 컴파일 에러 발생*/
  nInput <= 10 ? (nSelect = 10) : (nSelect = 20);
  printf("%d\n", nSelect);

  return EXIT_SUCCESS;
}
```

`nInput <= 10 ? (nSelect = 10) : (nSelect = 20);`이렇게 작성해도 컴파일 에러가 발생하지 않아 놀랍습니다.

`sizeof` 혹은 주소 연산자(`&`) 처럼 컴파일 타임에 사용되는 연산자가 있고 그 이후에 런타임에는 피연산자는 변수가 아니라 변수 안에 담긴 값입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int input = 0;

  printf("키를 입력하세요. :");
  scanf("%d%*c", &input);
  printf("결과: %s\n", input >= 150 ? "합격" : "불합격");

  return EXIT_SUCCESS;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nMax = 0;
  int a, b, c;

  scanf("%d %d %d", &a, &b, &c);

  a > b ? (nMax = a) : (b > c ? (nMax = b) : (nMax = c));

  printf("MAX: %d\n", nMax);
  return EXIT_SUCCESS;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nMax = 0, nInput = 0;
  scanf("%d", &nInput);
  nMax = nInput;

  scanf("%d", &nInput);
  nMax = nInput > nMax ? nInput : nMax;

  scanf("%d", &nInput);
  nMax = nInput > nMax ? nInput : nMax;

  printf("MAX: %d\n", nMax);
  return EXIT_SUCCESS;
}
```

각각 3번 입력하는 경우입니다. 간단합니다.

여기서 알아야 할 것은 이방식이 유지보수하기 쉽습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nMax = -100, nInput = -100;
  scanf("%d", &nInput);
  nMax = nInput > nMax ? nInput : nMax;

  scanf("%d", &nInput);
  nMax = nInput > nMax ? nInput : nMax;

  scanf("%d", &nInput);
  nMax = nInput > nMax ? nInput : nMax;

  printf("MAX: %d\n", nMax);

  return EXIT_SUCCESS;
}
```

쉽게 풀이할 수 있습니다. 가장 작은 값보다 작을 수 없게 시작하면 됩니다.

어떤 알고리즘이 좋은 알고리즘인가 평가할 때는 당연히 근거입니다. 그 중 하나는 동작횟수 지금의 경우 비교횟수에 해당합니다.

지금 예시의 경우 이전과 크게 다르지 않습니다. 그래서 성능 비교는 무의미합니다.

유지보수와 확장성을 생각해봐야 합니다.

몆출 복붙하는 관점으로 확장한다고 생각하면 당연히 매번 입력 받는 버전이 더 유리합니다.

메모리 사용량을 비교해볼 수 있습니다. 이것은 공간복잡성 문제입니다. 변수의 개수로 생각하면 이번에도 3번 변수로 받으면 변수마다 확보해야 하는 메모리 량이 많아집니다. 하지만 여러번 입력받는 버전은 입력 받을 때마다 새로운 메모리 확보는 안하고 사용했던 메모리를 계속 사용합니다.

1. 다음 코드의 실행 결과 및 원리에 대해 답하세요.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nResult, w = 0, x = -1, y = -1, z = 1;
  nResult = w++ || x++ && ++y || ++z;
  printf("%d %d %d %d %d\n", w, x, y, z, nResult); // 1 0 0 2 1
  return EXIT_SUCCESS;
}
```

표준 컴파일 플래그를 사용하면 소괄호 사용하라고 에러를 던집니다.

여기서 우위 연산은 늦게 동작합니다. 그래서 전위 연산 후위 연산 처리하면 다음과 같은 표현이 가능합니다.

`0 \|\| -1 \&\& 0 \|\| 2` 여기서 이제 왼쪽에서 오른쪽 순서대로 처리하면 됩니다. AND, OR를 참 거짓을 받을 때 까지로 보면 이렇게 처리 될 수 있습니다. 또 논리연산자의 결과는 `0` 또는 `1`입니다.

1. `0 \|\| -1 \&\& 0 \|\| 2` : 시작. OR(`\|\|`)은 `true`를 찾을 때까지 실행
2. `1 \&\& 0 \|\| 2` : `0`은 `false`라 제거. AND(`\&\&`)는 `false`를 찾을 때까지 실행.
3. `0 \|\| 2` : `0`은 `false`라 제거. AND(`\&\&`)는 `false`를 찾을 때까지 실행.
4. `1` : 마지막은 둘 중 하나가 `true`라 결국 `1`이 됨.
5. `1` : 후위연산은 할당이후 실행하기 때문에 `w`, `x`, `y`, `z`는 `1 0 0 2`가 됨

## Chapter 06 기본 제어문

조건문은 다른 언어에서도 배우는 것이입니다. 본격적인 프로그래밍의 부분입니다. 자료형과 연산자는 단어와 숙어와 비슷합니다. 제어문은 문장과 비슷합니다.

### if 문

if 문은 다른 말로 분기문이라고 합니다. 조건을 기준으로 절차상 흐름을 제어합니다. 다른 제어문도 조건문을 기반으로 합니다. 처음 프로그래밍한다면 의식을 많이 하기 바랍니다.

제어문은 연산자가 포함되어 있습니다. 연산에 참여하는 변숫값의 변화를 추적할 수 있어야 합니다.

기본구조는 직관적입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nAge = 0;
  printf("나이를 입력하세요. : ");
  scanf("%d", &nAge);
  if (nAge >= 20) {
    printf("당신의 나이는 %d세 입니다.\n", nAge);
  }
  printf("End");

  return EXIT_SUCCESS;
}
/*나이를 입력하세요. : 20*/
/*당신의 나이는 20세 입니다.*/
/*End%*/
```

여기 예시에서 들여쓰기와 열맞춤에 신경쓰는 습관을 들이기 바랍니다. 안하면 읽기 어렵습니다.

개발자의 소스코드는 문서입니다. 간결하고 가독성 높이는 것이 중요한 개발자의 덕목입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nAge = 0;

  printf("나이를 입력하세요. : ");
  scanf("%d", &nAge);

  if (nAge >= 20) {
    printf("당신의 나이는 %d세 입니다.\n", nAge);
		nAge = 20;
  }
  printf("당신의 나이는 %d세 입니다.\n", nAge);

  return EXIT_SUCCESS;
}
/*나이를 입력하세요. : 30*/
/*당신의 나이는 30세 입니다.*/
/*당신의 나이는 20세 입니다.*/
```

나이 알고리즘이 이렇게 되면 좋겠습니다. 30대가 되어도 강제로 20살이 된다는 것이 행복할 것 같습니다.

블록 스코프(`{}`)는 문법적으로 영역을 만드는 것입니다. 하지만 실행문은 아닙니다.

C 언어는 괄호로 여러 항을 묶어 한 항우로 만들고 블록 스코프로 여러 구문을 묶어 한 구문을 만들 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int max = -100, input = -100;
  scanf("%d", &input);
  if (input > max)
    max = input;
  scanf("%d", &input);
  if (input > max)
    max = input;
  scanf("%d", &input);
  if (input > max)
    max = input;

  printf("MAX : %d\n", max);

  return EXIT_SUCCESS;
}
/*10*/
/*30*/
/*-10*/
/*MAX : 30*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int age = 0, cost = 1000;
  scanf("%d", &age);
  if (age < 20) {
    cost = cost * 75 / 100;
  }

  printf("최종요금: %d원\n", cost);
  return EXIT_SUCCESS;
}
/*17*/
/*최종요금: 750원*/
```

간단하게 해결했습니다.

```c
if (nAge >= 20);
```

여기서 주의할 점은 세미코론(`;`)이 조건식 끝에 붙으면 컴파일러는 그 지점에서 if문이 끝난 것으로 인식합니다.

여러 줄이면 블록 스코프로 묶어야 합니다.

### if else문

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0, nSelect = 0;
  scanf("%d", &nInput);

  if (nInput <= 10)
    nSelect = 10;
  else
    nSelect = 20;
  printf("%d\n", nSelect);
  return EXIT_SUCCESS;
}
/*24*/
/*20*/
```

`else`는 조건이 없습니다. 이전 모든 조건들에서 안 걸리면 실행하는 로직입니다.

상호 배타적인 로직을 실행할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0, nSelect = 0;
  scanf("%d", &nInput);

  if (nInput <= 10) {
    if (nInput < 0)
      nSelect = 0;
    else
      nSelect = 10;
  } else {
    nSelect = 20;
  }

  printf("%d\n", nSelect);
  return EXIT_SUCCESS;
}
/*-10*/
/*0*/
```

뭐 안 어려운 예제입니다.

다음은 학점 분류 계산기입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  char ch = 'A';

  printf("점수를 입력하세요: ");
  scanf("%d", &nInput);

  if (nInput >= 80) {
    if (nInput >= 90)
      ch = 'A';
    else
      ch = 'B';
  } else {
    if (nInput >= 70)
      ch = 'C';
    else
      ch = 'D';

    if (nInput < 60)
      ch = 'F';
  }

  printf("%c\n", ch);
  return EXIT_SUCCESS;
}
/*점수를 입력하세요: 85*/
/*B*/
/*점수를 입력하세요: 59*/
/*F*/
```

조건에 의한 분류와 선택이 중요합니다.

프로그래머는 발생 가능한 경우의 수를 나열한 후, 어떤 조건과 방법으로 하나를 정확히 선택할 수 있는지 기술할 수 있어야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int input = 0, discount = 100;
  scanf("%d", &input);

  if (input <= 13) {
    if (input <= 3)
      discount = 0;
    else
      discount = 50;
  } else {
    if (input <= 19)
      discount = 75;
    else
      discount = 100;
  }

  printf("최종요금: %d원\n", 1000 * discount / 100);
  return EXIT_SUCCESS;
}
```

문제는 간단하게 풀 수 있습니다.

식별자 검색순서

변수의 통용범위는 그 변수를 선언한 블록 스코프로 제한됩니다. 스코프를 벗어나면 변수는 사라집니다. 기본적으로 local 변수이고 auto 변수이기 때문입니다.
외부 스코프에서는 같은 변수선언도 가능합니다. 다음은 식별자 검색 실험입니다. 실무는 이렇게 하면 곤란합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("%d", &nInput);

  if (nInput > 10) {
    int nInput = 20;
    printf("%d\n", nInput);

    if (nInput < 20) {
      int nInput = 30;
      printf("%d\n", nInput);
    }
  }

  printf("%d\n", nInput);

  return EXIT_SUCCESS;
}
/*11*/
/*20*/
/*11*/
```

핵심입니다. 가장 최근에 형성된 스코프가 우선합니다. 스코프가 닫히면 그 내부에 선언된 변수는 소멸합니다. 코드를 복붙하면서 실수로 발생할 가능성이 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  char ch = 'A';

  printf("점수를 입력하세요: ");
  scanf("%d", &nInput);
  if (nInput >= 90)
    ch = 'A';
  else if (nInput >= 80)
    ch = 'B';
  else if (nInput >= 70)
    ch = 'C';
  else if (nInput >= 60)
    ch = 'D';
  else
    ch = 'F';

  printf("점수: %d, 학점: %c\n", nInput, ch);
  return EXIT_SUCCESS;
}
/*점수를 입력하세요: 59*/
/*점수: 59, 학점: F*/
```

경우의 수가 늘어날수록 성능 문제가 있습니다. 2진 탐색과 선형탐색이 성능이 다른 것과 같습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int input = 0, discount = 100;
  scanf("%d", &input);

  if (input <= 3 || input >= 65)
    discount = 0;
  else if (input <= 13)
    discount = 50;
  else if (input <= 19)
    discount = 75;
  else
    discount = 100;

  printf("최종요금: %d원\n", 1000 * discount / 100);
  return EXIT_SUCCESS;
}
```

## switch-case문

정보를 분류하는데 사용하는 제어문입니다. 경우의 수를 선택하지 않고 단 한번의 연산(혹은 변수)으로 특정한 경우 하나를 선택합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char cOperator = 0;
  int x = 0, y = 0, nResult = 0;
  scanf("%d%c%d", &x, &cOperator, &y);

  switch (cOperator) {
  case '+':
    nResult = x + y;
    break;
  case '-':
    nResult = x - y;
    break;
  case '*':
    nResult = x * y;
    break;
  case '/':
    nResult = x / y;
    break;
  default:
    puts("ERROR: 알 수 없는 산술 연산입니다.");
  }

  printf("Result: %d\n", nResult);

  return EXIT_SUCCESS;
}
/*3*2*/
/*Result: 6*/
```

switch 문은 각 경우에 대응하는 값과 기술한 값을 비교하는 상등연산(`==`)을 수행합니다.

case 문 끝에는 세미콜론(`;`)이 아닙니다. C 언어에서 레이블이 존재합니다. 연산식이 아니고 코드의 위치를 기술하는 것입니다. 레이블도 끝이 `:`입니다.

break 문은 연산을 즉시 멈추고 자신이 속한 스코프를 벗어나도록 흐름을 변경합니다.

case 문 내에서는 반드시 작성해야 합니다.

때로는 의도적으로 break 문을 생략할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char chCredit = 'x';
  int nInput = 0;

  printf("점수를 입력하세요. : ");
  scanf("%d", &nInput);

  switch (nInput / 10) {
  case 10:
  case 9:
    chCredit = 'A';
    break;
  case 8:
    chCredit = 'B';
    break;
  case 7:
    chCredit = 'C';
    break;
  case 6:
    chCredit = 'D';
    break;
  default:
    chCredit = 'F';
  }

  printf("학점 : %c\n", chCredit);

  return EXIT_SUCCESS;
}

/*점수를 입력하세요. : 95*/
/*학점 : A*/
```

100점과 90이상인 경우 모두 포함합니다.

## goto 문

goto문은 break 문처럼 특정 위치로 프로그램의 흐름을 '즉시' 변경합니다. break문은 그 대상위치가 문법적으로 제한된 상태입니다. 변경이 불가능합니다.

goto 문은 사용자가 레이블로 명시한 위치면 어디든지 이동할 수 있습니다. 아무 제한 없이 코드의 흐름을 변경할 수 있습니다.

장점같지만 단점이 되기도 합니다. 코드의 흐름이 논리적으로 파악이 어려워 질 수 있습니다. 해결하기 어려운 상태가 될 가능성이 높습니다. 문법은 알아두고 필요한 상황에만 활용합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput;

INPUT:
  printf("Input number : ");
  scanf("%d", &nInput);

  if (nInput < 0 || nInput > 10)
    goto INPUT;

  puts("End");

  return EXIT_SUCCESS;
}
/*Input number : -1*/
/*Input number : 11*/
/*Input number : 5*/
/*End*/
```

goto 문은 오른쪽에 레이블명을 기술합니다. 어디든 맥락에 상관없이 goto 문으로 이동할 수 있습니다. 편리하지만 꼬이면 스파게티코드가 됩니다. 많은 사람들이 goto문을 사악한 코드(evil code)라고 부르고 사용하지 말라고 권합니다.

다익스트라이 주장이 와전된 것입니다.

설계적으로 전혀 관련이 없어야 할 두 대상을 하나로 묶어줄 수 있기 때문에 구조적 결함을 만들 가능송이 높습니다. 유지보수 측면의 효율이 많이 떨어집니다.

1. if문을 사용하여 사용자로부터 정수 5개를 입력받아 그중 가장 큰 수를 출력하는 프로그램을 작성하시오. 사용자는 0 ~ 100 사이 값만 입력하도록 강제합니다. 범위를 벗어난 숫자를 입력할 경우 0 미만은 0으로 100초과는 100으로 조정합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int input = 0, i = 0, max = 0;

INPUT:
  scanf("%d", &input);
  i += 1;

  if (input < 0)
    input = 0;
  if (input > 100)
    input = 100;

  if (input >= max)
    max = input;

  if (i < 5)
    goto INPUT;

  printf("Max : %d\n", max);

  return EXIT_SUCCESS;
}
```

2. 다음 코드에서 잘못된 부분은 무엇인가?

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nAge = 0;

  scanf("%d", &nAge);

  if (nAge = 20)
    puts("당신은 성인입니다.");

  puts("End");

  return EXIT_SUCCESS;
}
```

```c
  if (nAge == 20)
```

여기만 이렇게 고치면 됩니다.

3. 다음 코드를 작성하고 사용자가 15를 입력했다면 어떤 결과가 출력되는지 쓰세요.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("%d", &nInput);

  if (nInput > 10) {
    int nInput = 20;
    printf("%d\n", nInput);

    if (nInput < 20) {
      int nInput = 30;
      printf("%d\n", nInput);
    }
  }

  printf("%d\n", nInput);
  return EXIT_SUCCESS;
}
```

`15`를 입력하고 `20`을 먼저 출력하고 다음에 `15`를 출력합니다.

## 반복문

반복문은 일정구간의 코드를 연속적으로 반복해 실행하는 제어문입니다.

사람이 할 귀찮은 일을 기계가 대신 실수 없이 반복하는 것이 업무 전산화의 목표 중 하나입니다. 다른 말로 중요합니다.

### while - 조건 기반 반복문

while은 if문과 유사합니다. 하지만 조건이 거짓이 될때까지 계속 실행합니다.

이것은 아주 중요한 특징입니다.

#### 기본구조 조건에 의한 제어

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;

  while ((ch = getchar()) != '\n') {
    putchar(ch);
  }

  return EXIT_SUCCESS;
}
/*TestString*/
/*TestString%*/
```

`ch`는 `getchar`의 반환값을 할당합니다. `getchar`는 버퍼메모리에서 데이터를 꺼내는데 없으면 유저의 표준입력을 받습니다. `while`은 `\n`인 개행문자를 받을 때까지 실행합니다. 여기서는 입력을 받으면 계속 출력하기만 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int input = 0, idx = 0;

  scanf("%d%*c", &input);

  while (idx != input) {
    printf("*");
    idx += 1;
  }
  printf("\n");

  return EXIT_SUCCESS;
}
```

#### 무한루프

스킬이슈

반복을 멈추기위한 조건부터 설계하도록 합니다. 종료조건에 영향을 주는 연산이 반복문 내부에 당연히 있어야합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;

  while (nInput >= 0) {
    nInput + 1;
  }
  printf("%d\n", nInput);

  return EXIT_SUCCESS;
}
```

굳이 실행하지 않을 것입니다.

실제로 CPU 코어 점유율을 보면 100% 금방 도달하는 것을 볼 수 있을 것입니다.

다음은 `int` 오버플로우로 비정상적인 종료가 발생할 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;

  while (nInput >= 0) {
    ++nInput;
  }
  printf("%d\n", nInput);

  return EXIT_SUCCESS;
}
```

`int` 가 최댓값을 초과하고 음수로 오버플로우하게 되면 `while` 조건을 깨는 상태를 충족하게 됩니다.

종료하기는 하지만 의도랑 다르다는 것이 문제입니다. 대부분의 경우 의도가 다를 경우가 많을 것입니다.

#### 반복문 내부에 선언한 자동변수

반복문 내부에서 변수선언하는 행위는 자제해야 합니다. 프로그램이 비효율적이게 동작합니다. 스택영역으로 관리가 필요합니다.

다음은 반복문 내부에 변수 선언을 안한 정상적인 코드입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;
  int nIndex = 0;
  while ((ch = getchar()) != '\n') {
    printf("%02d\t%c\n", nIndex, ch);
    ++nIndex;
  }
  return EXIT_SUCCESS;
}
/*Hello*/
/*00	H*/
/*01	e*/
/*02	l*/
/*03	l*/
/*04	o*/
```

상당히 단순한 코드입니다. 이제는 의도적으로 오류를 만들어보겠습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;

  while ((ch = getchar()) != '\n') {
    int nIndex = 0;

    printf("%02d\t%c\n", nIndex, ch);
    ++nIndex;
  }

  return EXIT_SUCCESS;
}
/*Hello*/
/*00	H*/
/*00	e*/
/*00	l*/
/*00	l*/
/*00	o*/
```

오류를 직접 만든입장에서는 이해가 쉽습니다. 스코프가 닫히면 그 내부에 선언 및 정의된 변수는 사라진다고 했습니다. 지금 같은 경우 특별하게 활용하는 경우가 아니라서 비효율적입니다. 메모리에 계속 데이터를 추가하고 삭제하면서 불필요한 작업을 많이 하게 됩니다.

반복문 내부에서는 변수를 선언 및 정의하지 않습니다.

#### 반복문의 중첩

반복문은 if문을 중첩하는 것처럼 중첩이 가능합니다. 뭐 말해줘야 아는 사람들도 있어서 이야기합니다.

다음은 구구단 출력하는 고전 문제입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 2, j = 1;

  while (i <= 9) {
    j = 1;
    putchar('\n');
    while (j <= 9) {
      printf("%d * %d = %d\n", i, j, i * j);
      j += 1;
    }
    i += 1;
  }

  return EXIT_SUCCESS;
}

/*2 * 1 = 2*/
/*2 * 2 = 4*/
/*2 * 3 = 6*/
/* ... */
/*9 * 9 = 81*/
```

실습문제로 5x5 행렬을 출력하라고 합니다.

```c
#include <stdio.h>
#include <stdlib.h>
int main(void) {
  int i = 0, j = 0;

  while (i < 5) {
    j = 0;
    while (j < 5) {
      j += 1;
      printf("*\t");
    }
    putchar('\n');
    i += 1;
  }

  return EXIT_SUCCESS;
}
/**	*	*	*	*	*/
/**	*	*	*	*	*/
/**	*	*	*	*	*/
/**	*	*	*	*	*/
/**	*	*	*	* */
```

정답지를 본게 아닌가 의심스러울 정도로 같았습니다.

### for 문

while 문은 실수할 가능성이 은근히 있습니다. 스킬 이슈입니다.

for 문은 초기화, 계수기, 증가식 3가지를 한 행에 강제로 기술하게 만듭니다. while 문가 본질은 같지만 실수할 여지가 적습니다. 또 가독성 측면과 관용어구라는 측면에서 장점입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 0;

  for (i = 0; i < 5; ++i) {
    printf("%dth\n", i);
  }

  return EXIT_SUCCESS;
}
/*0th*/
/*1th*/
/*2th*/
/*3th*/
/*4th*/
```

반복문 스코프의 머리부분 한줄로 시작과 끝을 단번에 알수 있다는 장점이 있습니다.

for 문은 생략이 가능합니다. `for(;;)`이라고 표현도 가능합니다. 이렇게 되면 `while(1)`과 같습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int sum = 0;

  for (int i = 1; i <= 10; ++i) {
    sum += i;
  }
  printf("%d\n", sum);

  return EXIT_SUCCESS;
}
/*55*/
```

쉽게 구할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int input = 2;
  scanf("%d%*c", &input);

  if (input < 2 || input > 9) {
    printf("Error\n");
  } else {
    for (int i = 1; i <= 9; ++i) {
      printf("%d * %d = %d\n", input, i, input * i);
    }
  }

  return EXIT_SUCCESS;
}
```

상당히 문제를 쉽게 풀 수 있습니다.

이전에 풀어본 문제를 while 문에서 for 문으로 풀어봅니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 0; i < 5; ++i) {
    for (int j = 0; j < 5; ++j) {
      printf("*\t");
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/**	*	*	*	*	*/
/**	*	*	*	*	*/
/**	*	*	*	*	*/
/**	*	*	*	*	*/
/**	*	*	*	* */
```

논리구조는 상당히 단순합니다. 0에서 출발하는 zero-based index입니다.

자주하는 것들 중 하나는 도형출력 과제합니다.

뭐 처음하면 오래 걸릴 수 있지만 오래 걸리면 안되는 과제들입니다.

본인이 작성하는 본인의 코드에 대해 기초적인 자각능력을 기르기 시작하는 기초 운동입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 1; i <= 5; ++i) {
    for (int j = 0; j < i; ++j) {
      printf("*\t");
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/**	*/
/**	*	*/
/**	*	*	*/
/**	*	*	*	*/
/**	*	*	*	*	*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 1; i <= 5; ++i) {
    for (int j = 1; j <= 5 - i; ++j) {
      printf("\t");
    }
    for (int j = 1; j <= i; ++j) {
      printf("*\t");
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/*
				*
			*	*
		*	*	*
	*	*	*	*
*	*	*	*	*
*/
```

첫 줄 줄바꿈 버그까지 주의해서 작성하도록 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 1; i <= 5; ++i) {

    for (int j = 1; j <= 5 - i; ++j) {
      printf("\t");
    }

    for (int j = 1; j <= 2 * i - 1; ++j) {
      printf("*\t");
    }

    for (int j = 1; j <= 5 - i; ++j) {
      printf("\t");
    }

    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/*
				*
			*	*	*
		*	*	*	*	*
	*	*	*	*	*	*	*
*	*	*	*	*	*	*	*	*
*/
```

피라미드 출력은 쉽습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 0; i < 5; ++i) {

    for (int j = 0; j < 5 + i; ++j) {
      if (i + j >= 4)
        printf("*\t");
      else
        putchar('\t');
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
```

이렇게 풀이하는 것이 더 올바릅니다.

### do while 문

반복 대상 단위 코드를 먼저 한번 실행하고 나중에 조건 비교를 합니다.

적어도 한번은 실행이 필요한 로직에 유용합니다. 뭐 CLI로 게임만들 때 게임루프를 만들기 좋습니다.

조건식을 괄호 뒤에 세미콜론을 붙인다는 점이 특이합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 0;

  do {

    ch = getchar();
    putchar(ch);
  } while (ch != '\n');

  return EXIT_SUCCESS;
}
/*TestString*/
/*TestString*/
```

입력의 유효함을 확인하고 다시 입력하게 만들 때 자주 활용하는 전략입니다.

범위를 벗어나거 유효하지 않으면 무엇이 안 맞는지 알려주고 루프를 계속 돌게 만들 수 있습니다.

### break와 continue

break는 while, for, do while, switch-case 모두 사용합니다. 흐름을 벗어날 수 있게 해줍니다. continue는 반복문 내부에서 현재 수행을 종료하고 다음 반복문을 수행할 수 있게 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 0;
  for (i = 0; i < 10; ++i) {
    if (i > 4)
      break;

    printf("%dth\n", i);
  }

  printf("END: i == %d\n", i);
  return EXIT_SUCCESS;
}
/*0th*/
/*1th*/
/*2th*/
/*3th*/
/*4th*/
/*END: i == 5*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 0;
  for (i = 0; i < 10; ++i) {
    if (i > 4)
      continue;

    printf("%dth\n", i);
  }

  printf("END: i == %d\n", i);
  return EXIT_SUCCESS;
}
/*0th*/
/*1th*/
/*2th*/
/*3th*/
/*4th*/
/*END: i == 10*/
```

이것으로 알 수 있는 것은 다음으로 순회한다는 사실입니다. 그래서 9까지 순회합니다.

반복문을 안 끝내고 다음으로 넘어갑니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 0, j = 0;
  for (i = 0; i < 5; ++i) {
    printf("i == %d\n", i);
    for (j = 0; j < 5; ++j) {
      if (j > 2)
        break;
      printf("\t%dth\n", j);
    }
    printf("end\n\n");
  }

  return EXIT_SUCCESS;
}
```

1. 1 ~ 100까지 숫자 중에서 4의 배수가 몇개이며, 이들의 총합이 얼마인지 계산해 출력하는 프로그램을 작성하시오.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int count = 0, sum = 0;

  for (int i = 1; i <= 100; ++i) {
    if (i % 4 == 0) {
      count += 1;
      sum += i;
    }
  }

  printf("%d, %d\n", count, sum);

  return EXIT_SUCCESS;
}
/*25, 1300*/
```

2. 다음과 같이 '\*'을 출력하는 프로그램을 작성하세요.

```
                *
            *       *
        *       *       *
    *       *       *       *
*       *       *       *       *
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 1; i <= 5; ++i) {

    for (int j = 1; j <= 5 - i; ++j) {
      putchar('\t');
    }

    for (int j = 1; j <= i; ++j) {
      printf("*\t\t");
    }

    printf("\n");
  }

  return EXIT_SUCCESS;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  for (int i = 1; i <= 5; ++i) {
    for (int j = 0; j < 5; ++j) {
      if (5 - i > j)
        printf("\t");
      else
        printf("*\t\t");
    }
    printf("\n");
  }

  return EXIT_SUCCESS;
}
```

단 하나의 반복문으로 해결하는 방법은 이렇게 할 수 있습니다.

작업 횟수 자체는 동일합니다. 저의 사고 방식이 상당히 약합니다.

3. 다음 코드의 실행결과를 쓰시오.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 0;

  for (i = 0; i < 10; ++i) {
    if (i > 4)
      continue;
    printf("%dth\n", i);
  }

  printf("END: i == %d\n", i);
  return EXIT_SUCCESS;
}
/*0th*/
/*1th*/
/*2th*/
/*3th*/
/*4th*/
/*END: i == 10*/
```

4까지 출력함 마지막은 10을 출력함

4. 다음 코드에서 goto문을 제거하고 반복문을 이용해서 같은 결과를 얻을 수 있도록 프로그램을 변경하시오.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  int nInput = 0;

INPUT:
  printf("Input number : ");
  scanf("%d", &nInput);

  if (nInput < 0 || nInput > 10)
    goto INPUT;

  puts("End");

  return EXIT_SUCCESS;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;

  do {
    printf("Input number : ");
    scanf("%d", &nInput);
  } while (nInput < 0 || nInput > 10);

  puts("End");
  return EXIT_SUCCESS;
}
```

이렇게 하는 것으로 goto 문을 우회할 수 있습니다.

## 배열

타입이 같은 데이터 여러 개가 모여 새로운 하나를 이룬 형식입니다.

배열이 기존의 변수와 다른 점 중 하나는 배열의 이름은 변수의 이름과 달리 메모리의 주소라는 점입니다.

여러 요소를 대표하는 첫 번째 요소의 메모리 주소에 부여하는 식별자입니다.

다음은 배열이 해결하는 문제를 보고 배울 수 있게 해줍니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int a, b, c, d, e;

  scanf("%d%d%d%d%d", &a, &b, &c, &d, &e);

  printf("%d\n", a);
  printf("%d\n", b);
  printf("%d\n", c);
  printf("%d\n", d);
  printf("%d\n", e);

  return EXIT_SUCCESS;
}
/*1 2 3 4 5*/
/*1*/
/*2*/
/*3*/
/*4*/
/*5*/
```

문법문제는 없습니다. 유지보수 문제가 있습니다.

배열 연산자를 활용하면 됩니다. `배열이름[인덱스]`이 배열 연산자입니다.

인덱스는 0부터 총 개수의 -1개까지입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {0};
  int i = 0;

  for (i = 0; i < 5; ++i) {
    scanf("%d", &aList[i]);
  }
  for (i = 0; i < 5; ++i) {
    printf("%d\n", aList[i]);
  }

  return EXIT_SUCCESS;
}
/*1 2 3 4 5*/
/*1*/
/*2*/
/*3*/
/*4*/
/*5*/
```

이전보다 유지보수하기 쉬워집니다.

C 언어 배열은 zero-based index 입니다. 그래서 0번부터 4까지 인덱스가 지금 존재합니다.

배열요소도 변수를 의미합니다. 그래서 포인터 연산자로 주소를 접근해야 합니다.

### 1차원 배열의 기본 문법

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {10, 20, 30, 40, 50};
  int i = 0;
  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }
  putchar('\n');

  aList[0] = 100;
  aList[3] = 200;

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  return EXIT_SUCCESS;
}
/*10	20	30	40	50	*/
/*100	20	30	200	50	*/
```

배열연산의 결과는 L-value가 될 수 있습니다. 즉 변수가 될 수 있습니다.

대괄호 안에 배열의 요소를 명시한 숫자 `5`를 빼고 `int aList[] = { 10, 20, 30, 40, 50};`라고 기술해도 상관없습니다. 컴파일러가 소스코드에 기술된 초깃값의 개수를 판별한 후 요소의 개수를 자동으로 확정하기 때문입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {10, 20, 30, 40, 50};
  int i = 0;

  aList[0] = aList[4];
  aList[1] += aList[2];
  aList[4] = aList[3] * 2;

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  return EXIT_SUCCESS;
}
/*50	50	30	40	80*/
```

배열을 변수라고 생각하면 상당히 직관적입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {10, 20, 30, 40, 50};
  int aListNew[5] = {0};
  int i = 0;

  aListNew = aList;

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  return EXIT_SUCCESS;
}
```

린트부터 에러를 던집니다.

당연히 좌변이 피연산자가 아니라서 발생하는 문제입니다. 배열의 이름은 주소상수입니다. 상수는 읽기만 가능하고 쓰기를 할 수 없습니다. 즉 l-value가 아닙니다.

배열은 인덱스를 모은 덩어리라고 생각하면 주소를 모아둔 주소입니다. 즉 하나의 주소를 다루는 상황이 아닙니다. 배열 복제는 하나하나 값을 대입하면 됩니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {10, 20, 30, 40, 50};
  int aListNew[5] = {0};
  int i = 0;

  for (i = 0; i < 5; ++i) {
    aListNew[i] = aList[i];
  }

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aListNew[i]);
  }

  putchar('\n');
  return EXIT_SUCCESS;
}
/*10	20	30	40	50*/
```

### 최댓값/최솟값

가장 큰수를 찾는 선형탐색 알고리즘입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, nMax = aList[0];

  for (i = 1; i < 5; ++i) {
    if (aList[i] > nMax)
      nMax = aList[i];
  }

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  printf("MAX: %d\n", nMax);
  return EXIT_SUCCESS;
}
/*30	40	10	50	20	*/
/*MAX: 50*/
```

선형탐색이고 뭐 원포인터 문제라고 생각할 수 있습니다. 초기화를 0으로 하면 습관이 잘못된 것입니다. 불필요한 연산을 하기 때문입니다. 안해도 될 비교를 한번더 하게 되기 때문입니다.

또 1부터시작하는 이유는 이미 첫번째부터 포인터가 찍혀있는데 굳이 비교를 할 필요가 없습니다.

시험문제입니다. 위 코드에서 `nMax`를 사용할 수 없고 추가 변수를 만들 수 없습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0;

  // 여기부터 코드를 작성할 수 있습니다.

  // 여기까지 코드를 작성할 수 있습니다.
  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  printf("MAX: %d\n", nMax);
  return EXIT_SUCCESS;
}
/*50	40	10	50	20	*/
/*MAX: 50*/
```

그냥 변수 취급하면 되는데 30분은 오버입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0;

  // 여기부터 코드를 작성할 수 있습니다.
  for (i = 1; i < 5; ++i) {
    if (aList[i] > aList[0])
      aList[0] = aList[i];
  }
  // 여기까지 코드를 작성할 수 있습니다.
  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  printf("MAX: %d\n", aList[0]);
  return EXIT_SUCCESS;
}
```

교환방식으로 최솟값 구하기 과제입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, nTmp = 0;

  // 여기부터 코드를 작성할 수 있습니다.

  // 여기까지 코드를 작성할 수 있습니다.
  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  printf("MIN: %d\n", aList[0]);
  return EXIT_SUCCESS;
}
/*10	40	30	50	20	*/
/*MAX: 10*/
```

값의 유실을 막는 것이 중요합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, nTmp = 0;

  // 여기부터 코드를 작성할 수 있습니다.
  for (i = 1; i < 5; ++i) {
    if (aList[i] < aList[0]) {
      nTmp = aList[0];
      aList[0] = aList[i];
      aList[i] = nTmp;
    }
  }
  // 여기까지 코드를 작성할 수 있습니다.
  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');
  printf("MIN: %d\n", aList[0]);
  return EXIT_SUCCESS;
}
/*10	40	30	50	20	*/
/*MAX: 10*/
```

이번에도 간단합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  /*int aList[5] = {30, 40, 10, 50, 20};*/
  char szBuffer[6] = {'H', 'e', 'l', 'l', 'o', '\0'};

  char szData[8] = {"Hello"};

  char *pszBuffer = "Hello";

  puts(szBuffer);
  puts(szData);
  puts(pszBuffer);

  return EXIT_SUCCESS;
}
/*Hello*/
/*Hello*/
/*Hello*/
```

자주 사용하는 문자열 배열 선언은 `szData` 방식입니다. 하지만 내부적으로는 `szBuffer`입니다. 보편적인 `szData`는 표현할 때 Null 문자를 생략한다는 점을 볼 필요가 있습니다.

`Hello`라는 문자열 표기를 풀어보면 `'H'`, `'e'`, `'l'`, `'l'`, `'o'`, `'\0'`입니다. 문자상수 하나하나 일일이 표기하기에는 번거롭습니다. 보통 문자열을 표기할 할 때 `\0`을 생략해도 괜찮습니다. 문자배열은 명시하지 않으면 0으로 초기화합니다. 이렇게 되면`szData`는 `'H'`, `'e'`, `'l'`, `'l'`, `'o'`, `'\n'`, `'0'`, `'0'`이 될 것입니다.

포인터 변수의 선언은 기존 배열과 다릅니다. 포인터 변수라는 것은 메모리의 주소를 저장하기 위한 전용변수입니다. 동작원리를 생각하면 직관적입니다. `"Hello"`는 문자의 배열이고 배열은 주소로 식별합니다. 이 주소로 식별하는 것을 포인터 변수의 초깃값으로 명시한 것입니다.

문자열의 끝이 `\0`인 이유는 무엇인가?

암기로 알고 있는 것중 하나는 문자열의 끝은 `\0`이라는 것입니다. 이론자체는 어려운 것이 아닙니다. 하지만 눈에 안보여서 실수할 여지가 많습니다. 문제점을 인식하고 있어서도 먼저 이유를 알아야 합니다.

이런것은 C 언어의 설계와 철학의 문제입니다. 데니스 리치에게 직접 인터뷰나와 말해줬으면 하는 것입니다. 다음은 영어 이름을 입력받아 문자열의 길이를 출력하는 프로그램입니다. 문자열의 길이를 `\0`이 나올 때까지 반복해서 확인하는 방법입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[32] = {0};
  int nLenght = 0;

  printf("Input your name : ");
  fgets(szBuffer, sizeof(szBuffer), stdin);

  while (szBuffer[nLenght] != '\0') {
		nLenght += 1;
  }

  printf("Your name is %s(%d).\n", szBuffer, nLenght);
  return EXIT_SUCCESS;
}
/*Input your name : arch-spatula*/
/*Your name is arch-spatula*/
/*(13).*/
```

문자열의 길이를 측정하는 방식은 단순 무식해보입니다. 문자열의 길이를 측정하는 것은 실망스로운데 만일 배열원소 처음부터 `\0`이면 논리적 오류입니다. 또 만약에 배열 요소 안에 `\0`이 없으면 무한루프에 빠집니다.

표준입력을 받기위해 32바이트를 확보해야 합니다. 사용자의 입력은 동적인데 메모리에 확보하는 사이즈는 고정적입니다. 지금의 경우 오른쪽은 활용을 못한 경우입니다. 사용중 영역과 사용하지 않는 영역을 구분할 때도 `\0`을 활용할 수 있습니다.

### 다차원 배열

1차원 배열은 메모리가 1차원 선형구조입니다. 이 선형구조를 쌓으면 2차원인 면이 됩니다. 다차원 배열은 메모리의 실제 모습과 상관없이 논리적 구조입니다. 자료의 접근방법에 한정된 것입니다.

2차원 배열을 행렬입니다. 관습상 `자료형 배열이름[row][col]` 이런식으로 부릅니다. 초깃값 정의도 약간 다릅니다. 예시를 보면 잘 이해될 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[3][4] = {{10, 20, 30, 40}, {50, 60, 70, 80}, {90, 100, 110, 120}};
  int i = 0, j = 0;

  for (i = 0; i < 3; ++i) {
    for (j = 0; j < 4; ++j) {
      printf("%d\t", aList[i][j]);
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/*10	20	30	40	*/
/*50	60	70	80	*/
/*90	100	110	120	*/
```

다른 언어로 프로그래밍 경험이 있으면 크게 어려울 것은 없습니다.

배열연산을 한번만 수행하면 이것은 주소를 의미하는 r-value입니다. 수소가 상수라 편집이 불가능합니다. 다음은 정의할 때말고 순회하면서 채우는 예시를 보여주겠습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[3][4] = {0};
  int i = 0, j = 0, nCounter = 0;

  for (i = 0; i < 3; ++i) {
    for (j = 0; j < 4; ++j) {
      aList[i][j] = ++nCounter;
    }
  }

  for (i = 0; i < 3; ++i) {
    for (j = 0; j < 4; ++j) {
      printf("%d\t", aList[i][j]);
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/*1	2	3	4	*/
/*5	6	7	8	*/
/*9	10	11	12*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[3][4] = {
      {10, 20, 30},
      {40, 50, 60},
  };
  int i = 0, j = 0;

	// 여기에 코드가 들어감

  for (i = 0; i < 3; ++i) {
    for (j = 0; j < 4; ++j) {
      printf("%d\t", aList[i][j]);
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/*10	20	30	60	*/
/*40	50	60	150	*/
/*50	70	90	210*/
```

위 출력을 만족하게 만들면 됩니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[3][4] = {
      {10, 20, 30},
      {40, 50, 60},
  };
  int i = 0, j = 0;

  for (i = 0; i < 3; ++i) {
    for (j = 0; j < 4; ++j) {
      if (j < 3) {
        aList[i][3] += aList[i][j];
        if (i < 2) {
          aList[2][j] += aList[i][j];
        }
      }
    }
  }

  for (i = 0; i < 3; ++i) {
    for (j = 0; j < 4; ++j) {
      printf("%d\t", aList[i][j]);
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/*10	20	30	60	*/
/*40	50	60	150	*/
/*50	70	90	210*/
```

어려운 로직은 아닌데 스스로 작성하면 오래걸리는 과제입니다. 입문자는 범위초과 오류를 많이 경험하게 됩니다. 문제는 컴파일러가 에러가 있을 것임에도 불구하고 막지 않습니다. 잘못된 접근으로 엉뚱한 인접 원소의 값을 변경하는 현상이 자주 발생합니다.

다음은 0부터 시작한다는 것을 몰라 발생할 수 있는 버그입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[3][4] = {
      {10, 20, 30, 40},
      {50, 60, 70, 80},
      {90, 100, 110, 120},
  };

  int i = 0, j = 0;

  aList[0][4] = 300;

  for (i = 0; i < 3; ++i) {
    for (j = 0; j < 4; ++j) {
      printf("%d\t", aList[i][j]);
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
```

저는 린트를 띄웠습니다. 거기에 다가 GCC가 컴파일 경고를 해줘서 문제는 없습니다.

논리적으로는 2차원이지만 물리적으로는 1차원 비슷하다고 생각할 수 잇습니다. 메모리 공간이 연속되어 있습니다. 원래 컴파일 에러가 없으면 `aList[1][0]`에 `300`이 할당 될 것입니다.

연속된 공간에서 다음 공간에 할당하기 때문에 `[0][4]`와 `[1][0]`은 같습니다. 이런거는 GCC를 사용할 수 있는 환경이면 괜찮은데 아닌 환경이 훨씬더 많습니다.

3차원 배열도 존재합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[4][2][3] = {0};
  int i = 0, j = 0, k = 0, nCounter = 0;

  for (i = 0; i < 4; ++i) {
    printf("Plane number : %d\n", i);
    for (j = 0; j < 2; ++j) {
      for (k = 0; k < 3; ++k) {
        aList[i][j][k] = ++nCounter;
        printf("%d\t", aList[i][j][k]);
      }
      putchar('\n');
    }
    printf("\n\n");
  }

  return EXIT_SUCCESS;
}
/*Plane number : 0*/
/*1	2	3	*/
/*4	5	6	*/

/*Plane number : 1*/
/*7	8	9	*/
/*10	11	12	*/

/*Plane number : 2*/
/*13	14	15	*/
/*16	17	18	*/

/*Plane number : 3*/
/*19	20	21	*/
/*22	23	24	*/
```

3차원 배열은 2차원 배열을 여러 개 다룬다는 생각으로 접근합니다. 크게 어려울 것은 없습니다.

논리구조를 그대로 코드로 옮기는 행위는 어렵습니다. 말과 설명은 쉬워도 그대로 코드로 작성하는 것은 생각보다 어렵습니다.

1. 원소의 자료형이 `int`이고 길이가 5인 배열을 선언한 후, 사용자가 입력한 다섯 개의 정수로 초기화합니다. 그리고 그중에서 가장 큰수와 가장 작은수를 출력하는 프로그램을 작성합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int num[5] = {0};
  int i = 0, min = 0, max = 0;

  for (i = 0; i < 5; ++i) {
    scanf("%d", &num[i]);
  }

  min = num[0];
  max = num[0];

  for (i = 1; i < 5; ++i) {
    if (num[i] > max)
      max = num[i];
    if (num[i] < min)
      min = num[i];
  }

  printf("MIN: %d, MAX: %d\n", min, max);
  return EXIT_SUCCESS;
}
/*1 2 3 4 5*/
/*MIN: 1, MAX: 5*/
```

2. 사용자로부터 문자열을 입력받은 후 문자열의 길이를 출력하는 프로그램을 작성합니다. 단, 입력되는 문자열이 한글이라고 가정하고 한글 문자의 개수를 출력해야 합니다. 사용자가 영문, 숫자 입력은 고려할 필요 없습니다. 글자 사이 공백, 탭도 없는 것으로 간주합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[32] = {0};
  int nLenght = 0;

  scanf("%s%*c", szBuffer);

  while (szBuffer[nLenght] != '\0') {
    nLenght += 1;
  }

	nLenght /= 3;

  printf("한글 문자의 개수는 %d자 입니다.\n", szBuffer, nLenght);
  return EXIT_SUCCESS;
}
```

우아하지 않지만 해결했습니다. 한글은 1자당 2바이트를 확보해야 합니다. 하지만 3배수로 버퍼에 저장합니다.

## 배열을 활용한 프로그래밍 기법

C 언어의 문법보단 프로그래밍 기법들에 가깝습니다.

### 배열 요소의 정렬

정렬 알고리즘에 기본 학습용 정렬은 2개 있습니다. 선택정렬, 버블정렬입니다. 쉬워서 가르칩니다. 초보자에게도 쉽습니다. 이론도 쉽습니다. 코드도 쉽게 나와야 합니다. 그냥 선형탐색 응용한 것에 불과합니다.

#### 선택정렬로 알려진 버블 정렬

모두 정렬될 때까지 최솟값을 구하는 알고리즘입니다. 하나의 포인터를 잡고 다음을 순회합니다. 보다 더 크면 자리를 교환합니다. 가장 작은 값이 앞으로 버블링(더 정확히 싱킹)하면서 정렬되는 알고리즘입니다.

```
 v  v
30 40 10 50 20
```

무시합니다.

```
 v     v
30 40 10 50 20
```

이럴 때는 교환합니다.

```
 v     v
10 40 30 50 20
```

```
 v     v
10 40 30 50 20
```

하지만 여기서 앞의 비유적인 포인터를 유지하고 뒤를 계속 순회합니다.

```
 v           v
10 40 30 50 20
```

여기까지 순회해도 새로운 교환은 발생하지 않습니다. 이럴 때는 앞의 비유적인 포인터를 찍고 그 다음을 순회합니다.

```
    v  v
10 40 30 50 20
```

앞이 더 작으니까 교환합니다.

```
    v  v
10 30 40 50 20
```

여기서 부터 이어서 마지막까지 순회해봅니다.

```
    v        v
10 30 40 50 20
```

30 보다 작으니까 교환합니다.

```
    v        v
10 20 40 50 30
```

앞에 2번째 즉 1번인덱스까지는 정렬되어 있습니다. 선택정렬로 알려져 있습니다. 하지만 버블 정렬입니다. 이런 교환은 버블링입니다. 큰값이 뒤로 모이고 작은 값이 교환하면서 앞으로 모입니다. 각항을 비교하고 값이 작은 것을 확인될 때마다 즉시 교환하기 때문입니다.

- 실제 스택정렬은 각 항을 비교하지만 더 작은 값이 발견되면 즉시 값을 교환하지 않고 더 작은 값이 저장된 배열의 인덱스를 따로 저장했다가 안쪽 반복문이 끝난 뒤 한번만 두 항의 값을 교환하는 방식으로 구현합니다. 즉 선택을 하고 작은지 확인하고 교환합니다. 버블정렬은 매번 교환합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, j = 0, nTmp = 0;

	// 여기서부터
	// 여기까지만

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }
  putchar('\n');

  return EXIT_SUCCESS;
}
/*10 20 30 40 50*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, j = 0, nTmp = 0;

  for (i = 0; i < 5; ++i) {
    for (j = i + 1; j < 5; ++j) {
      if (aList[i] > aList[j]) {
        nTmp = aList[i];
        aList[i] = aList[j];
        aList[j] = nTmp;
      }
    }
  }

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }

  putchar('\n');

  return EXIT_SUCCESS;
}
/*10 20 30 40 50*/
```

금방 구현합니다.

이번에는 버블 정렬입니다. 이것도 나름 재미있을 것입니다.

버블정렬은 서로 연접한 두 항을 계속해서 비교하는 방식입니다. 비교하고 즉시 정렬합니다. 선택정렬과 버블정렬은 효율이 같습니다. 인덱스가 1개 작습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, j = 0, nTmp = 0;

	// 여기서부터
	// 여기까지만

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }
  putchar('\n');

  return EXIT_SUCCESS;
}
/*10 20 30 40 50*/
```

시작하는 템플릿은 같습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, j = 0, nTmp = 0;

  for (i = 0; i < 5; ++i) {
    for (j = 0; j < 4; ++j) {
      // 앞 aList[j] 뒤 aList[j + 1]
      if (aList[j] > aList[j + 1]) {
        nTmp = aList[j];
        aList[j] = aList[j + 1];
        aList[j + 1] = nTmp;
      }
    }
  }

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }
  putchar('\n');

  return EXIT_SUCCESS;
}
```

틀린구현을 했습니다. 불필요하게 많은 순회를 하고 있습니다. 가장 큰게 뒤에 모입니다. 그래서 올바르게 고쳐야 합니다. 상위 반복문은 이전보다 1인덱스식 줄여줘야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, j = 0, nTmp = 0;

	// 4 3 2 1
  for (i = 4; i > 0; --i) {
    for (j = 0; j < i; ++j) {
      // 앞 aList[j] 뒤 aList[j + 1]
      if (aList[j] > aList[j + 1]) {
        nTmp = aList[j];
        aList[j] = aList[j + 1];
        aList[j + 1] = nTmp;
      }
    }
  }

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }
  putchar('\n');

  return EXIT_SUCCESS;
}
```

성능까지 올바르게 구현해야 올바른 구현입니다. 상위 윈도우가 줄어들면서 다음순회할 때마다 순회해야 하는 대상이 작아집니다. 우리가 매번 순회할 때 가장 큰 값이 제일 뒤에 있을 것이라는 것을 보장할 수 있습니다. 이래서 버블정렬이라고 부릅니다.

이번에는 선택정렬을 구현합니다. 이전 선택정렬은 계속 여러변 교환했습니다. 하지만 선택정렬은 내부 루프가 끝나면 1번만 교환합니다. 작은 값을 저장하는 것이 아니라 인덱스를 저장합니다. 그리고 이 인덱스를 활용해서 자리를 바꿉니다.

```
 v  v
30 40 10 50 20
```

무시합니다.

```
 v     v
30 40 10 50 20
```

값을 변경하지 않습니다. 기준으로 하는 인덱스를 더 작은 값으로 합니다.

```
       v  v
30 40 10 50 20
```

더 큰 값을 확인합니다.

```
       v     v
30 40 10 50 20
```

더 큰것을 확인합니다. 하지만 10이 제일 작습니다.

```
 v     v
10 40 30 50 20
```

큰 순회를 하고 난 다음에 제일 작은 곳을 고르고 자리를 교환합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, j = 0, nMinIndex = 0, nTmp = 0;

  // 여기서부터
  // 여기까지만
  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }
  putchar('\n');

  return EXIT_SUCCESS;
}
```

여기서 시작합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, j = 0, nMinIndex = 0, nTmp = 0;

  for (i = 0; i < 5; ++i) {
    // 가장 작은 값을 순회할 때 시작하는 곳에 둠
    nMinIndex = i;
    for (j = i + 1; j < 5; ++j) {
      // 더 작은 값이 있으면 갱신
      if (aList[nMinIndex] > aList[j]) {
        nMinIndex = j;
      }
    }

    // 같은 값에 메모리 쓰기는 불필요하게 동작횟수로 성능을 낭비함
    if (i != nMinIndex) {
      // 가장 작은 인덱스를 기준으로 교환
      nTmp = aList[i];
      aList[i] = aList[nMinIndex];
      aList[nMinIndex] = nTmp;
    }
  }

  for (i = 0; i < 5; ++i) {
    printf("%d\t", aList[i]);
  }
  putchar('\n');

  return EXIT_SUCCESS;
}
```

이번에는 배열을 교차구현합니다. 순방향 역방향으로 돌아가면서 채우면 됩니다.

```
01 02 03 04 05
10 09 08 07 06
11 12 13 14 15
20 19 18 17 16
21 22 23 24 25
```

- 이렇게 채우면 됩니다. 정답을 다양하게 인정하고 싶지만 대부분 대학교 시험문제라고 생각하면 10점 만점에 5점만 줄 것입니다. 기존 템플릿을 최대한 활용하고 중첩 for 문을 통해서 구현해야 합니다. 추가 변수는 금지입니다. 구현되고 성능도 같지만 비즈니스 요구사항에서 10개 중 9개만 된 것이라면 가치가 50%가 감소합니다. 당신은 개발자입니다. 배로 키우���� 것은 없어도 깎아먹는 짓거리를 하는데 돈받아 먹고 싶으면 깎아먹는 짓거리 하지 말라고 이렇게 할 것입니다.

하지만 오답들도 학습 리소스입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {30, 40, 10, 50, 20};
  int i = 0, j = 0, nMinIndex = 0, nTmp = 0;

  // 여기서부터
  for (i = 0; i < 5; ++i) {
    for (j = 0; j < 5; ++j) {
    }
  }
  // 여기까지만
  for (i = 0; i < 5; ++i) {
    for (j = 0; j < 5; ++j) {
      printf("%d\t", aList[i][j]);
    }
    putchar('\n');
  }
  return EXIT_SUCCESS;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5][5] = {0};
  int i = 0, j = 0;

  for (i = 0; i < 5; ++i) {
    for (j = 0; j < 5; ++j) {
      if (i % 2 == 0)
        aList[i][j] = i * 5 + j + 1;
      if (i % 2 != 0)
        aList[i][j] = i * 5 - j + 5;
    }
  }

  for (i = 0; i < 5; ++i) {
    for (j = 0; j < 5; ++j) {
      printf("%d\t", aList[i][j]);
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
/*1	2	3	4	5	*/
/*10	9	8	7	6	*/
/*11	12	13	14	15	*/
/*20	19	18	17	16	*/
/*21	22	23	24	25*/
```

대단한거 하나 없이 그냥 조건문 사용하면 됩니다. 하지만 다음은 틀렸지만 접근은 학습할 가치가 있어서 공유합니다. 무조건 틀린 것입니다. 90% 맞다는 것은 틀리다는 것입니다. 100% 맞을 때 맞다고 하는 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5][5] = {0};
  int i = 0, j = 0, nCounter = 0;

  for (i = 0; i < 5; ++i) {
    if (i % 2 == 0)
      for (j = 0; j < 5; ++j)
        aList[i][j] = ++nCounter;
    else
      for (j = 0; j < 5; ++j)
        aList[i][4 - j] = ++nCounter;
  }

  for (i = 0; i < 5; ++i) {
    for (j = 0; j < 5; ++j) {
      printf("%d\t", aList[i][j]);
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
```

순회할 반복문을 쪼갠 것입니다.

이런 분기처리가 나쁘다는 것은 아닙니다. 이것은 인덱스를 뒤에서 부터 채우는 것입니다. 인덱스를 순회할 때 홀수는 뒤에서 빼면서 접근합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5][5] = {0};
  int i = 0, j = 0, nCounter = 0, nOffset = 1;

  for (i = 0; i < 5; ++i) {
    if (i % 2 == 0)
      nCounter = i * 5;
    else
      nCounter = (i + 1) * 5 + 1;

    for (j = 0; j < 5; ++j) {
			nCounter += nOffset;
      aList[i][j] = nCounter;
    }
		nOffset = -nOffset;
  }

  for (i = 0; i < 5; ++i) {
    for (j = 0; j < 5; ++j) {
      printf("%d\t", aList[i][j]);
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
```

아까보단 정답에 가깝지만 변수가 2개나 더 필요합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5][5] = {0};
  int i = 0, j = 0, nCounter = 0, nFlag = 1;

  for (i = 0; i < 5; ++i) {
    if (nFlag) {
      for (j = 0; j < 5; ++j) {
        aList[i][j] = ++nCounter;
      }
      nFlag = 0;
    } else {
      for (j = 0; j < 5; ++j) {
        aList[i][4 - j] = ++nCounter;
      }
      nFlag = 1;
    }
  }

  for (i = 0; i < 5; ++i) {
    for (j = 0; j < 5; ++j) {
      printf("%d\t", aList[i][j]);
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
```

플래그를 활용하면서 이전보다 가동성은 약간더 좋습니다. 물론 이전 코드도 쉽게 읽혀야 합니다.

### 달팽이 배열 채우기

이전은 아주 쉽습니다. 지금도 쉬울 것입니다. 시계방향 달팽이 배열입니다.

```
01 02 03 04 05
16 17 18 19 06
15 24 25 20 07
13 23 22 21 08
14 12 11 10 09
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5][5] = {0};
  int i = 0, j = 0, nCounter = 0, nFlag = 1;
  // 여기서부터
  for (i = 0; i < 5; ++i) {
    for (j = 0; j < 5; ++j) {
    }
  }
  // 여기까지만

  for (i = 0; i < 5; ++i) {
    for (j = 0; j < 5; ++j) {
      printf("%d\t", aList[i][j]);
    }
    putchar('\n');
  }

  return EXIT_SUCCESS;
}
```

반복문은 4개이상 사용은 금지입니다.

남은 예제는 쉽고 사실 작성하다가 날려서 생략하겠습니다.

또 달팽이 탐색은 학습해야 하는 중요한 개념입니다. 나중에 2차원 배열 그래프 순회할 때 활용될 개념이라 복습겸 남겨 두겠습니다.

Lookup 개념도 있는데 그렇게 가치있는 개념은 아닙니다. 그냥 중간에 읽기용으로 배열인덱스를 확인하고 조회하는 용도입니다.

## 함수에 대한 기본 이론

지금부터 다루는 것은 사용자 정의 함수입니다. 기존에는 라이브러리 함수를 호출하고 있던 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int Add(int a, int b) {
  int nData = 0;
  nData = a + b;
  return nData;
}

int main(void) {
  int nResutl = 0;

  nResutl = Add(3, 4);
  printf("Result: %d\n", nResutl);

  return EXIT_SUCCESS;
}
/*Result : 7*/
```

크게 어려운 것은 없습니다.

프로그램의 시작은 언제나 `main()` 함수입니다.

#### 매개변수

함수의 매개변수는 호출자와 피호출자 함수를 연결해주는 매개체입니다. 파라미터라는 말을 더 자주 사용합니다.

모든 호출자 함수는 피호출자 함수 매개변수의 초깃값을 '실인수'로 명시할 의무가 있습니다. 매개변수는 변수입니다. 호출자 입장에서는 지역변수입니다. 같은 이름은 함수 몸 스코프에서 공존할 수 없습니다.

```c
int Add(int a, int b) {
  int nData = 0, a;
  nData = a + b;
  return nData;
}
```

린트부터 에러를 던져 줄 것입니다.

#### 반환 자료형

함수의 반환 자료형은 호출자 함수가 피호출자 함수를 호출해서 얻을 수 있는 정보의 형식입니다.

반환값은 다시 받아 저장하지 않으면 잃습니다. 당연합니다. 사용하고 싶으면 변수에 대입해서 보관하면 됩니다.

```c
#include <stdio.h>
#include <stdlib.h>

int GetMax(int a, int b, int c) {

  int nMax = a;
  if (b > nMax)
    nMax = b;
  if (c > nMax)
    nMax = c;

  return nMax;
}

int main(void) {
  int nResutl = 0;

  printf("MAX: %d\n", GetMax(1, 2, 3));
  printf("MAX: %d\n", GetMax(2, 3, 1) * 2);
  printf("MAX: %d\n", nResutl = GetMax(3, 1, 3));

  return EXIT_SUCCESS;
}
/*MAX: 3*/
/*MAX: 6*/
/*MAX: 3*/
```

`printf("MAX: %d\n", nResutl = GetMax(3, 1, 3));` 이렇게 작성하는 경우는 거의 없습니다. 별도 구분으로 분리하는 방식이 일반적입니다. 보통 컨벤션에 어긋나는 것이지 큰 결함을 만드는 것은 아닙니다.

### 두 가지 함수 설계 원칙

C 언어는 여러 항을 구문으로 작성하고, 여러 구문을 함수단위로 구성합니다.

C 언어 프로그래머가 해야할 고민은 무엇을(어떤 기능을 수행하는) 함수로 만들어야 하는가입니다. 이런 고민은 설계에 대한 고민입니다.

공학적으로 접근하기보다는 개인경험을 근거로 몇 가지 규칙을 다음과 같이 제안하고자 합니다.

- 사용자 인터페이스(겉으로 드러나는 외형)와 내부기능은 반드시 분리할 것
- 하나의 단위기능으로 규정할 수 있는 대상은 함수로 만들 것

#### UI와 기능의 분리

프로그램의 사용자 인터페이스는 인간과 기계가 상호작용할 수 있도록 연결되는 형식을 말합니다. 인간은 명령하고 기계는 출력합니다.

인터페이스가 없는 프로그램이 아니라면 모든 프로그램은 UI와 기능으로 나눌 수 있습니다. 함수 단위에서 이 2가지는 분리되어야 합니다. 이것은 C 언어만 해당하지 않습니다.

다음은 팩토리얼 함수입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int GetFactorial(int nParam) {
  int nResult = 1, i = 0;
  if (nParam < 1 || nParam > 10) {
    puts("ERROR: 1 ~ 10 사이의 정수를 입력하세요.");
    return EXIT_FAILURE;
  }

  for (i = 1; i <= nParam; ++i) {
    nResult *= i;
  }

  return nResult;
}

int main(void) {

  printf("MAX: %d\n", GetFactorial(1));
  printf("MAX: %d\n", GetFactorial(5));
  printf("MAX: %d\n", GetFactorial(11));
  printf("MAX: %d\n", GetFactorial(10));

  return EXIT_SUCCESS;
}

/*MAX: 1*/
/*MAX: 120*/
/*ERROR: 1 ~ 10 사이의 정수를 입력하세요.*/
/*MAX: 1*/
/*MAX: 3628800*/
```

반환값은 지금은 오류인지 판단하기 어렵습니다.

기능 함수 내부에서 사용자 인터페이스 영역에서 해야 할 일을 처리하는 것은 생각해볼 문제입니다. 지금 프로그램에서 인터페이스 역할을 하는 함수는 `main`입니다. 오류메시지 출력의 책임은 `main`에게 부여하는 것이 더 바람직합니다.

지금은 호출하는 부분부터 잘못되었습니다. 그래서 일반적인 상황은 아닙니다.

```c
#include <stdio.h>
#include <stdlib.h>

int GetFactorial(int nParam) {
  int nResult = 1, i = 0;

  if (nParam < 1 || nParam > 10)
    return 0;

  for (i = 1; i <= nParam; ++i) {
    nResult *= i;
  }

  return nResult;
}

int main(void) {
  int nResult = 0, nInput = 0;
  printf("팩토리얼을 구할 정수(1 ~ 10)를 입력하세요. :  ");
  scanf("%d", &nInput);

  nResult = GetFactorial(nInput);

  if (nResult == 0) {
    puts("ERROR: 1 ~ 10 사이의 정수를 입력하세요.");
    return EXIT_FAILURE;
  }

  printf("Result: %d\n", nResult);

  return EXIT_SUCCESS;
}
/*팩토리얼을 구할 정수(1 ~ 10)를 입력하세요. :  5*/
/*Result: 120*/
```

기능과 UI 분리가 명확합니다. 적절한 입력을 유도하고 처리까지 고려했습니다.

이번에는 UI에서 성적을 입력받고 학점을 출력하는 부분으로 분리되어 있습니다. 계산도 별도로 분리되어 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int GetResult(void) {
  int nResult = 0;
  printf("성적(0~100)을 입력하세요. : ");
  scanf("%d", &nResult);
  return nResult;
}

char GetGrade(int nScore) {
  if (nScore >= 90)
    return 'A';
  else if (nScore >= 80)
    return 'B';
  else if (nScore >= 70)
    return 'C';
  else if (nScore >= 60)
    return 'D';

  return 'F';
}

int main(void) {
  int nResult = 0;
  nResult = GetResult();

  printf("당신의 학점은 '%c'(%d)입니다.\n", GetGrade(nResult), nResult);

  return EXIT_SUCCESS;
}
/*성적(0~100)을 입력하세요. : 90*/
/*당신의 학점은 'A'(90)입니다.*/
```

UI와 기능은 분리를 어설프게 했습니다. 방어적으로 범위를 파악하고 반환 값을 확인하는 부분이 없습니다. 다음은 UI만 존재하는 프로그램입니다.

메뉴 이벤트 루프 구현

```c
#include <stdio.h>
#include <stdlib.h>

int PrintMenu(void) {
  int nInput = 0;

  system("clear"); // windows 운영체제는 cls
  printf("[1]New\t[2]Search\t[3]Print\t[4]Remove\t[0]Exit\n:");
  scanf("%d", &nInput);

  return nInput;
}

int main(void) {
  int nMenu = 0;

  while ((nMenu = PrintMenu()) != 0) {
    switch (nMenu) {
    case 1:
      puts("새 항목을 추가합니다.");
      break;
    case 2:
      puts("기존 항목에서 검색합니다.");
      break;
    case 3:
      puts("전체 내용을 출력합니다.");
      break;
    case 4:
      puts("기존 항목을 삭제합니다.");
      break;
    default:
      puts("알 수 없는 명령입니다.");
      break;
    }
    getchar();
  }

  puts("Bye~~!");

  return EXIT_SUCCESS;
}
```

`0`을 받으면 종료하고 다른 입력을 받을 때마다 계속 처리합니다. GUI도 같은 구조를 같습니다.

이런 반복구조를 이벤트 루프라고 부릅니다.

#### 재사용 가능한 단위 기능의 구현

반복하는 코드는 함수로 만드는 것이 당연히 좋습니다.

프로그램이 제공하는 여러 기능 각각을 하나의 함수로 만들어버리면 코드관리하기 좋고 구조도 깔끔해집니다.

```c
#include <stdio.h>
#include <stdlib.h>

int GetFee(int nAge) {
  int nFee = 1000;
  if (nAge < 20)
    nFee /= 2;
  return nFee;
}

int PrintMenu(void) {
  int nInput = 0;

  system("clear"); // windows 운영체제는 cls
  printf("[1]New\t[2]Search\t[3]Print\t[4]Remove\t[0]Exit\n:");
  scanf("%d", &nInput);

  return nInput;
}

int GetAge(void) {
  int nAge = 0;
  printf("나이를 입력하세요. :");
  scanf("%d", &nAge);
  return nAge;
}

int main(void) {
  int nMenu = 0, nAge = 0;

  while ((nMenu = PrintMenu()) != 0) {
    if (nMenu == 1) {
      nAge = GetAge();
      printf("요금은 %d원 입니다.\n", GetFee(nAge));
    }
    getchar();
  }

  puts("Bye~~!");

  return EXIT_SUCCESS;
}
```

나이를 받는 부분과 받아서 처리하는 부분이 다릅니다. 다른 부분에서도 요금 계산 기능이 필요할 수 있습니다. 소스코드에서 요금계산 코드만 따로 찾아내기 좋습니다.

함수설계 원칙보다 더 큰 범위의 설계 원칙으로 DRY 원칙이 있습니다. 실용주의 프로그래머 도서에서 등장하는 프로그래밍 원칙입니다.

같은 일을 수행하는 코드가 중복(여러 곳에 존재)되지 않도록 하라입니다. 논리적 오류 방지와 유지보수 편의성 때문에 그렇습니다. 소프트웨어는 수시로 바뀝니다. 한국은 하드웨어도 바뀌지만 한국이 아닌 국가에서는 변화가 느린 편입니다. 변화하는 현경에 능동적으로 적응하기 위해서 유용한 원칙입니다.

변경해야 하는 곳을 1곳만 변경하는 점에서 유지보수하기 유리합니다.

### 코드 분할

UI와 기능을 분리하는 것, 단위 기능을 분리하는 것말고 또 분리할 이유가 있습니다. 코드 분할이라는 이유도 있습니다. 덩치가 너무 큰 코드는 변화에 대응하기 어렵습니다. 유지보수하기 어렵습니다.

너무 큰 코드라고 판단되면 일정 수준으로 크기를 줄여 여러 함수로 코드를 나누는 것이 좋습니다. 분할은 근거가 있어야 합니다. 무엇을 주의할지 파악해야 합니다. 코드 분할 고려사항입니다.

- 함수의 이름에서 기능이 무엇인지 직관적으로 알 수 있어야 합니다.
- 분할 된 코드가 들어 있는 호출 함수에 반드시 전달되어야 할 정보는 무엇인지 확정(매개변수)해야 합니다.
- 호출자 함수는 피호출 함수를 호출하는 것으로 끝나는 것인지 아니면 반드시 어떤 정보를 반환받아야 하는지 확정(반환 타입)해야 합니다.

매개변수와 반환 타입은 두 함수가 서로 만나는 접점입니다. 타입으로 어떻게 주고 받을지 결정해야 합니다.

매개변수와 반환 자료형을 명확히 선언할 수 있는 능력은 기본입니다. 다양한 코드를 보는 것이 유용합니다. 잘 짜인 코드는 많이 접하고 경험을 늘려야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[3] = {0};
  int nMax = -9999, i = 0;

  for (i = 0; i < 3; ++i) {
    printf("정수를 입력하세요. : ");
    scanf("%d", &aList[i]);
  }

  nMax = aList[0];
  for (i = 1; i < 3; ++i) {
    if (aList[i] > nMax) {
      nMax = aList[i];
    }
  }

  printf("%d, %d, %d 중 가장 큰 수는 %d 입니다.\n", aList[0], aList[1],
         aList[2], nMax);

  return EXIT_SUCCESS;
}

/*정수를 입력하세요. : 3*/
/*정수를 입력하세요. : 2*/
/*정수를 입력하세요. : 1*/
/*3, 2, 1 중 가장 큰 수는 3 입니다.*/
```

`main()`함수를 다음처럼 수정해도 결과 같게 만들어주세요.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[3] = {0};
  int nMax = -9999, i = 0;

  for (i = 0; i < 3; ++i) {
    printf("정수를 입력하세요. : ");
    aList[i] = GetData();
  }

  nMax = GetMax(aList[0], aList[1], aList[2]);

  printf("%d, %d, %d 중 가장 큰 수는 %d 입니다.\n", aList[0], aList[1],
         aList[2], nMax);

  return EXIT_SUCCESS;
}
```

이렇게 때로 분리한 함수를 작성하기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

int GetData(void) {
  int input = 0;
  scanf("%d", &input);
  return input;
}

int GetMax(int a, int b, int c) {
  int max = a;
  if (b > max)
    max = b;
  if (c > max)
    max = c;
  return max;
}

int main(void) {
  int aList[3] = {0};
  int nMax = -9999, i = 0;

  for (i = 0; i < 3; ++i) {
    printf("정수를 입력하세요. : ");
    aList[i] = GetData();
  }

  nMax = GetMax(aList[0], aList[1], aList[2]);

  printf("%d, %d, %d 중 가장 큰 수는 %d 입니다.\n", aList[0], aList[1],
         aList[2], nMax);

  return EXIT_SUCCESS;
}
```

간단합니다.

변수와 함수는 문법적으로 선언과 정의는 분리될 수 있습니다. 변수는 선언으로 끝날 수 있습니다. 하지만 함수는 선언과 정의를 분리할 수 있습니다.

함수 정의보다 함수 호출하는 코드가 먼저 등장하는 경우 원형(prototype)을 상단에 선언하는 것으로 컴파일러에게 존자한다고 알려줍니다.

```c
#include <stdio.h>
#include <stdlib.h>

int Add(int, int);

int main(void) {

  printf("%d\n", Add(3, 4));
  return EXIT_SUCCESS;
}
/*7*/

int Add(int x, int y) { return x + y; }
```

컴파일러 에러가 없습니다. 경고도 없습니다. 선언을 하는 것으로 아직 정의되기 전에 존재하지도 않는 함수를 호출하고 있습니다. 오류가 발생하지 않는 이유는 선언 및 정의가 되어 있기 때문입니다.

하지만 여전히 컴파일러 오류는 발생할 수 있습니다. 더 정확히 링크 오류입니다. 있어야 할 정의가 없거나 하나만 있어야 할 정의에 여러 개가 있는 경우 발생합니다.

#### 전역변수

```c
#include <stdio.h>
#include <stdlib.h>

int g_nCounter = 0;

void InitCounter(int nData) { g_nCounter = nData; }

void IncreaseCounter(void) { ++g_nCounter; }

int main(void) {
  InitCounter(10);
  printf("%d\n", g_nCounter);
  IncreaseCounter();
  printf("%d\n", g_nCounter);
  IncreaseCounter();
  printf("%d\n", g_nCounter);

  return EXIT_SUCCESS;
}
/*10*/
/*11*/
/*12*/
```

거의 소스코드 전체에서 접근이 가능합니다.

전역변수를 남용하면 서로 독립적으로 둘 전역변수를 매개로 묶어 버릴 수 있습니다.

다음은 나쁜 예시입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int g_aList[5] = {0};

void initList(void) {
  int i = 0;
  for (i = 0; i < 5; ++i) {
    printf("정수를 입력하세요. : ");
    scanf("%d", &g_aList[i]);
  }
}

void SortList(void) {
  int i = 0, j = 0, nTmp = 0;
  for (i = 0; i < 4; ++i) {
    for (j = i + 1; j < 5; ++j) {
      if (g_aList[j] < g_aList[i]) {
        nTmp = g_aList[j];
        g_aList[j] = g_aList[i];
        g_aList[i] = nTmp;
      }
    }
  }
}

void PrintList(void) {
  int i = 0;
  for (i = 0; i < 5; ++i) {
    printf("%d\t", g_aList[i]);
  }
}

int main(void) {
  initList();
  SortList();
  PrintList();
  return EXIT_SUCCESS;
}
/*정수를 입력하세요. : 20*/
/*정수를 입력하세요. : 40*/
/*정수를 입력하세요. : 30*/
/*정수를 입력하세요. : 10*/
/*정수를 입력하세요. : 50*/
/*10	20	30	40	50	%*/
```

이것은 사실상 한덩어리의 코드입니다. 만약에 전역변수의 배열크기를 10으로 바꾸면 다른 함수 모두 영향을 받습니다.

좋은 설계 중 하나는 서로 변화에 대해서 갖는 의존성을 최대한 낮추는 것입니다.

다음은 더 좋은 설계 예시입니다.

```c
#include <stdio.h>
#include <stdlib.h>

void initList(int *pList, int nSize) {
  int i = 0;
  for (i = 0; i < nSize; ++i) {
    printf("정수를 입력하세요. : ");
    scanf("%d", &pList[i]);
  }
}

void SortList(int *pList, int nSize) {
  int i = 0, j = 0, nTmp = 0;
  for (i = 0; i < nSize - 1; ++i) {
    for (j = i + 1; j < 5; ++j) {
      if (pList[j] < pList[i]) {
        nTmp = pList[j];
        pList[j] = pList[i];
        pList[i] = nTmp;
      }
    }
  }
}

void PrintList(int *pList, int nSize) {
  int i = 0;
  for (i = 0; i < nSize; ++i) {
    printf("%d\t", pList[i]);
  }
}

int main(void) {
  int aList[5] = {0};
  initList(aList, 5);
  SortList(aList, 5);
  PrintList(aList, 5);

  return EXIT_SUCCESS;
}
/*정수를 입력하세요. : 20*/
/*정수를 입력하세요. : 40*/
/*정수를 입력하세요. : 30*/
/*정수를 입력하세요. : 10*/
/*정수를 입력하세요. : 50*/
/*10	20	30	40	50	%*/
```

당연한 말이지만 C 언어도 식별자의 스코프 체이닝을 지원합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int nInput = 100;

void TestFunc(void) { printf("TestFunc() : %d\n", nInput); }

int main(void) {
  int nInput = 0;
  printf("%d\n", nInput);
  {

    int nInput = 20;
    printf("%d\n", nInput);
  }

  TestFunc();
  return EXIT_SUCCESS;
}
/*0*/
/*20*/
/*TestFunc() : 100*/
```

스코프 체이닝 더 정확히 식별자를 검색하는 순서는 당연히 알아야 할 개념입니다.

1. 매개변수로 `int` 타입 자료 4개를 받아 그중 가장 작은 숫자를 반환하는 `GetMin` 함수를 작성하세요.

```c
#include <stdio.h>
#include <stdlib.h>

int GetMin(int a, int b, int c, int d) {
  int max = a;
  if (max < b)
    max = b;
  if (max < c)
    max = c;
  if (max < d)
    max = d;
  return max;
}

int main(void) {
  int a = 0, b = 0, c = 0, d = 0;
  scanf("%d%d%d%d", &a, &b, &c, &d);
  printf("%d\n", GetMin(a, b, c, d));
  return EXIT_SUCCESS;
}
/*1 2 3 4*/
/*4*/
```

2. 다음 코드는 팩토리얼을 계산하는 `GetFactorial` 함수의 예를 보인 것입니다. 설계 원칙상 이 코드의 문제점으로 지적할 수 있는 부분은 무엇이며, 그 문제점을 수정하려면 `GetFactorial` 함수의 코드는 어떻게 수정되어야 하는지 기술하세요.

```c
#include <stdio.h>
#include <stdlib.h>

int getfactorial(int nParam) {
  int nResult = 1, i = 0;
  if (nParam < 1 || nParam > 10) {
    puts("ERROR: 1 ~ 10 사이의 정수를 입력하세요.");
    return 0;
  }

  for (i = 1; i <= nParam; ++i) {
    nResult *= i;
  }

  return nResult;
}

int main(void) {

  printf("MAX: %d\n", GetFactorial(1));
  printf("MAX: %d\n", GetFactorial(5));
  printf("MAX: %d\n", GetFactorial(11));
  printf("MAX: %d\n", GetFactorial(10));

  return EXIT_SUCCESS;
}

/*MAX: 1*/
/*MAX: 120*/
/*ERROR: 1 ~ 10 사이의 정수를 입력하세요.*/
/*MAX: 1*/
/*MAX: 3628800*/
```

UI와 기능이 결합되어 있습니다. 입력을 받아 예외에 해당해서 처리를 중단할 것과 처리하는 부분이 공존합니다.

puts로 에러츨 출력하고 에러에 해당하는 부분인지 확인하는 부분은 main에 들어와야 합니다. 예외를 수동으로 입력은 상황에 따라 남겨둬도 가능한 제거합니다.

표준 입력을 받고 범위를 초과하면 로직을 중단하게 만들어야 합니다.

3. 기본요금과 나이를 매개변수로 받아서 나이에 따른 최종요금을 계산해 반환하는 `GetFee` 함수를 작성하세요. 단 나이별 할인률은 다음과 같습니다.

00 ~ 03 : 100% (무료)
04 ~ 13 : 50%
14 ~ 19 : 75%
20이상 : 0%

```c
#include <stdio.h>
#include <stdlib.h>

int GetFee(int price, int age) {
  if (age > 19)
    return price;
  if (age > 13)
    return price * 75 / 100;
  if (age > 3)
    return price * 50 / 100;
  return 0;
}

int main(void) {
  int price = 0, age = 0;

  printf("요금을 입력하세요. : ");
  scanf("%d", &price);

  printf("나이를 입력하세요. : ");
  scanf("%d", &age);

  printf("최종요금 : %d원\n", GetFee(price, age));

  return EXIT_SUCCESS;
}
```

4. 함수의 원형 선언이 필요한 이유를 설명하세요.

선언과 정의는 C 언어에서 별개의 것입니다. `main`을 상단에 두고 프로토타입을 선언해줘야 정의 전에 위치한 함수가 나중에 접근할 수 있다고 컴파일러에게 알려줘야 합니다.

5. 다음 코드를 작성하고 실행하여 `11`을 입력한다면 어떤 결과가 출력되는지 쓰세요.

```c
#include <stdio.h>
#include <stdlib.h>

int nInput = 100;

void TestFunc(void) { printf("%d\n", nInput); }

int main(void) {
  int nInput = 0;
  scanf("%d", &nInput);
  if (nInput > 10) {
    int nInput = 20;
    printf("%d\n", nInput);

    TestFunc();
    if (nInput >= 100) {
      printf("%d\n", nInput);
    }
  }

  printf("%d\n", nInput);
  return EXIT_SUCCESS;
}
/*20*/
/*100*/
```

20이 출력되고 100이 다음에 출력됩니다.

## 메모리와 포인터

연산자, 함수, 제어문 같은 내용은 컴퓨터 기계와 직접 연결되는 내용을 덜 다루었습니다.

프로그래밍은 하드웨어적 이해를 기반으로 반드시 해야 합니다. 안하고 이런저런 것들을 해도 결국 코드 멍키에 불과합니다.

C 언어는 운영체제, 하드웨어 제어처럼 일상적으로 작성하는 프로그램에 좋습니다. 메모리를 직접다루는 것은 큰 축복입니다. 코드와 기계를 결합하는 프로그램이 정상적인 프로그램입니다.

이번에는 가능하면 디버거를 활용해서 메모리의 변화를 추적할 수 있어야 합니다.

### 컴퓨터와 메모리

변수의 본질은 메모리이며 모든 메모리는 자신의 위치를 식별하기 위한 근거로 일렬번호를 갖는데 이 번호를 메모리의 주소라고 부릅니다.

32비트 App에서 1바이트 단위 메모리에 부여된 일렬 번호는 부호 없는 32비트 정수입니다. 보통 16진수로 표기합니다.

주소로 메모리를 식별하는 것은 low-level 특성 중 하나입니다. high-level은 변수명 같은 식별자로 식별합니다. 변수 선언과 정의는 메모리 확보를 의미합니다.

이전에 배운것과 마찬가지로 변수를 이류는 3가지 요소가 있습니다.

1. 이름이 부여된 메모리
2. 그 안에 담긴 정보
3. 메모리의 주소

기본적인 연산은 변수에 저장된 정보가 연산에 참여합니다. 하지만 메모리 자체가 관심인 경우도 많습니다. 대표적인 경우가 주소 연산자입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nData = 10;

  printf("%s\n", "nData");
  printf("%d\n", nData);
  printf("%p\n", (void *)(&nData));

  return EXIT_SUCCESS;
}
/*nData*/
/*10*/
/*0x16dc670f8*/
```

> 이름이 nData인 부호 있는 64비트 정수형 메모리의 실제 주소는 0x16dc670f8이고, 그안에 저장된 정보를 해석하면 10진 정수인 10이다.

뭐 그냥 본인 CPU 아키텍쳐에서 변수하나 말한 것입니다.

메모리의 종류

메모리는 용도에 따라 스택, 힙, 데이터 영역, 텍스트 영역 등으로 나눕니다.

- 스택: 자동변수이고 지역변수인 변수가 사용하는 메모리 영역이며, 임시 메모리의 성격을 가진다. 크기가 작고(기본 설정을 기준으로 최대 1MB) 관리(할당 및 반환)가 자동으로 이루어지는 장점이 있다.
- 힙: 동적 할당할 수 있는 자유 메모리 영역이며, 개발자 스스로 직접 관리(수동)해야 한다. 32 App의 경우 대략 1xGB 정도를 사용할 수 있다. 따라서 대량의 메모리가 필요하거나 필요한 메모리의 크기를 미리 알 수 없을 때 사용한다.
- PE image (Protable Executable, 실행파일) 영역
  - Text Section: C 언어의 소스코드가 번역된 기계어가 저장된 메모리 영역이며, 기본적으로는 읽기전용 메모리이다. 어떤 식으로든 이 영역의 메모리를 변조하면, 해킹이라 할 수 있다.
  - Data Section 영역
    - Read Only: 상수 형태로 기술하는 문자열(예: `Hello`)이 저장된 메모리 영역이며, Text 영역처럼 읽기는 가능하나 쓰기는 허용되지 않는다.
    - Read/Write: 정적변수나 전역변수들이 사용하는 메모리 영역이며, 별도로 초기화하지 않아도 0으로 초기화된다. 관리는 자동이라서 힙 영역 메모리처럼 할당 및 해제를 신경 쓸 필요는 없다.

포인터 변수의 선언 및 정의

포인터 변수는 메모리의 주소를 저장하기 위한 전용 변수입니다. 포인터라는 것도 "주소가 적힌 메모지"로 생각할 수 있습니다. 짬질방 라커룸과 상당히 유사합니다.

바이트 단위 메모리는 고유한 번호가 붙어 잇습니다. 이 번호는 주소라고 부르지만 위치정보라고 생각할 수 있는 찜질방 사물함과 같습니다.

비유가 꽤 괜찮은게 사물함은 연속됩니다. 100번이 있고 101번이 있고 그옆에 또 102번이 있습니다. 우리가 100번을 사람이름을 붙이는 것은 변수명이 붙는 것과 유사합니다.

메모리의 주소를 세세하게 의식하지 않고 코드를 작성할 수 있게 컴파일러가 추리해줍니다. 메모리에 대해 기술적인 정보를 몰라도 메모리를 사용할수 있게 됩니다. 그렇다고 해도 메모리를 직접 다루어야 하는 경우가 많습니다. 이럴 때는 컴파일러에 주소를 물어봐야 합니다.

컴파일러는 메모리주소를 알려줄 것입니다. 그 방법은 바로 단항 연산자인 주소 포인터 연산자입니다. 식별자의 실제 메모리주소를 의미합니다. 연산이 문법적으로 잘못되지 않았다면 컴파일러는 주소를 알려주지 않는 경우는 없습니다.

주소 연산과 정반대되는 개념은 연산자를 바로 간접지정 연산자(`*`)입니다. 지정이라는 말은 대상 메모리에 대한 길이와 해석방법을 즉 자료형을 지정한다는 의미입니다. 예를들어, 4바이트를 한 세트로 보고 `int`형으로 취급하겠다는 것과 같습니다.

> 일정 크기의 메모리에 저장된 정보를 해석하는 방법

이 말을 정확히 이해하기 바랍니다. 직접지정자와 간접지정자가 있는데 직접지정은 4바이트 int형으로 확정하는 것입니다. 간접지정은 변경될 수 있는 임의의 기준주소로 상대적인 주소를 식별하는 방식입니다.

예시 코드를 보면 이해가 쉬울 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int x = 10;
  int *pnData = &x;

  printf("x : %d\n", x);

  *pnData = 20;

  printf("x : %d\n", x);

  return EXIT_SUCCESS;
}
/*x : 10*/
/*x : 20*/
```

변수에 주소자체를 저장합니다. 주소자체가 저정된 변수에 지금은 `20`으로 정보를 갱신한 것입니다.

지금의 경우가 바로 간접 지정에 해당합니다.

`int *pnData`은 주소를 받겠다는 의미고 `int` 타입을 갖는 변수의 주소를 받겠다는 것입니다. 그리고 `*pnData = 20`으로 좌변에 주소가 `x`변수의 주소에 `20`을 쓰기하겠다는 것입니다.

#### 포인터와 배열

배열의 이름은 0번 주소고 전체 배열을 대표하는 식별자입니다. 포인터 변수는 주소를 저장하기 위한 변수입니다. 이 둘을 조합해 다음을 추론할 수 있습니다. "배열의 이름이 주소이므로, 포인터 변수에 저장할 수 있다."입니다. `int` 포인터는 `int` 형 변수의 주소만 담을 수 있는 것이 아니라 `int`배열 이름도 담을 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int aList[5] = {0};
  int *pnData = aList;

  printf("aList[0] : %d\n", aList[0]);

  *pnData = 20;

  printf("aList[0] : %d\n", aList[0]);

  return EXIT_SUCCESS;
}
/*aList[0] : 0*/
/*aList[0] : 20*/
```

문제가 전혀 없습니다. 초기화할 때 `0`으로 초기화 했습니다.

간접지정 연산자는 단항 연산자이고 `pnData` 포인터이고 저장된 주소의 메모리를 `int` 변수로 보겠다는 의미입니다. 주소가 직접 기술되는 형식이 아니고 변수에 담긴 주소를 통해 간접적인 방법으로 지정했으니 간접지정입니다.

`*(pnData + 0)`을 의미합니다. 포인터 변수 `pnData`에 저장된 주소를 기준으로 오른쪽으로 `int 0`개 떨어진 위치의 메모리를 `int` 변수로 지정한다는 것입니다.

이번에는 문자열을 다룹니다. 하지만 끝이 `\0`인 확인하는 방법과 다릅니다. 배열인덱스말고 포인터 변수에 저장된 주솟값을 계속 증가시키는 방법으로 배열의 처음부터 `\0`이 저장된 메모리가 나올 때까지 차례로 접근합니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szBuffer[16] = {"Hello"};
  char *pszData = szBuffer;
  int nLength = 0;
  while (*pszData != '\0') {
    pszData++;
    nLength++;
  }

  printf("Length : %d\n", nLength);
  printf("Length : %lu\n", strlen(szBuffer));
  printf("Length : %lu\n", strlen("World"));

  return EXIT_SUCCESS;
}
/*Length : 5*/
/*Length : 5*/
/*Length : 5*/
```

오른쪽으로 `char` 타입 크기만큼 한 칸식 이동(주소 증가)했기 때문입니다. 이것은 주소 차이를 이용해 문자열의 길이를 측정하는 예시입니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szBuffer[16] = {"Hello"};
  char *pszData = szBuffer;

  while (*pszData != '\0') {
    pszData++;
  }

  printf("Length : %ld\n", pszData - szBuffer);

  return EXIT_SUCCESS;
}
/*Length : 5*/
```

곰곰히 생각해보면 직관적입니다. 임의로 주소를 부여해도 결국에는 시작주소와 크기만큼 순회한 주소의 차이를 구한 것입니다. 인덱스는 문자열 길이랑 일치할 수 밖에 없습니다.

상대주소에서 기준주소를 빼 역으로 인덱스를 계산하는 방법입니다.

### 메모리 동적 할당 및 관리

`malloc`, `free`를 다룹니다. 동적할당과 해제하는 함수입니다. 메모리를 할당하고 다시 운영체제 반환하는 일렬의 과정은 크게 할 것은 없습니다. 지금까지 배운 예제는 모두 자동변수입니다.

메모리의 동적 할당 및 해제는 다릅니다. 이전까지는 어린이 코딩수업과 비슷합니다. 다 알아서 해줍니다. 이번에는 어른들을 위한 코딩 수업입니다. 우리가 알아서 해줘야 합니다. "자유에 대한 책임이 따르는 메모리 사용법"이라고 생각할 수 있습니다.

자유롭게 메모리 할당이 가능하게 때문에 유연하지만 반드시 해제해줘야 합니다.

```c
void *malloc (size_t size);
```

인자는 할당받을 메모리의 바이트 단위 크기입니다.

반환 값은 힙 영역에 할당된 첫번째 바이트 메모리 주소입니다. 에러가 발생하면 `NULL`입니다.

할당받은 메모리는 반드시 `free` 함수를 이용해 반환해야 합니다. 메모리를 초기화하려면 `memset`함수를 이용해야 합니다. 기본적으로 쓰레기 값이 들어 있습니다.

```c
void free(void *memblock);
```

인자는 반환할 메모리이 주소입니다. 반환 값은 없습니다. 동적으로 할당받은 메모리를 운영체제에 반환하는 함수입니다.

`malloc`은 주소를 반환합니다. 이 주소를 사용해서 접근할 수 있습니다. 사용이 끝나면 반드시 `free` 함수를 해용해 메모리를 운영체제에 반환해야 합니다. `free` 함수의 인자는 `malloc`의 반환 기준 주소를 명시해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int *pList = NULL, i = 0;

  pList = (int *)malloc(sizeof(int) * 3); // 정수 3개 만큼 공간 확보

  pList[0] = 10;
  pList[1] = 20;
  pList[2] = 30;

  for (i = 0; i < 3; ++i) {
    printf("%d\n", pList[i]);
  }

  free(pList);
  return EXIT_SUCCESS;
}
/*10*/
/*20*/
/*30*/
```

`(int *)`은 void 포인터를 int 포인터로 형변환한 것입니다. 이것은 C++에서 강력하게 문제지적을 합니다. 코드 호환성을 유지하기 위해 형변한 연산을 추가하는 것이 일반적입니다.

void 포인터는 길이도 해석방법도 없습니다. 본질이 포인터인 것은 맞지만 이 주소가 가리키는 대상 메모리를 어떤 타입으로 해석할지 아직 결정되지 않음을 의미합니다. void는 인스턴스화를 허용하지 않습니다. 논리적으로 불가능한 것입니다.

`free`를 호출하고 `pList`를 인자로 대입했는데 결과나는 안 바뀝니다. 하지만 반환하지 않으면 메모리를 사용할 수 없기 때문에 메모리 누수라고 부릅니다.

이 코드는 `*(pList + 0) = 10; *(pList + 1) = 20;` 이렇게 바꿔도 상관 없습니다.

#### 메모리 초기화 및 사용(배열)

변수를 선언 했을 때 기본적으로 0으로 초기화 되었을 것이라고 많이 생각합니다. 일부 운영체제는 그렇지만 모든 운영체제가 그런 것은 아닙니다. 그게 아닌 경우 무슨 값이 있는지 모릅니다. 이런 이유로 사용자가 그냥 0으로 초기화하는 것을 명시하는 것이 좋습니다.

다음 예제를 참고하기 바랍니다.

```c
#include <stdlib.h>
#include <string.h>

int main(void) {
  int *pList = NULL, *pNewList = NULL;
  /*int aList[3] = {0};*/

  pList = (int *)malloc(sizeof(int) * 3);
  memset(pList, 0, sizeof(int) * 3);

  pNewList = (int *)calloc(3, sizeof(int));

  free(pList);
  free(pNewList);

  return EXIT_SUCCESS;
}
```

코드는 크게 3구간입니다. `aList`는 사용 안해서 주석 처리했습니다. `malloc` 함수는 동적할당을 하고 `memset` 함수로 0으로 초기화합니다. 마지막은 `calloc`은 초기화하고 모두 0으로 동적 할당방법처럼 보입니다.

```c
void *memset(void *dest, int c, size_t count);
```

- `dest`는 초기화할 대상 메모리 주소입니다. `c`는 초깃값입니다. `count`는 초기화할 메모리의 바이트 단위 크기입니다.
- 반환값은 대상 메모리 주소입니다.
- 동적으로 할당 받은 메모리에 쓰레기 값이 있으므로 일반적으로 0으로 치가화하여 사용한다.

경험 많은 C 프로그래머는 `memset`을 이렇게만 사용하고 그외 사용 예시가 기억에 없을 정도로 일반적인 사용법입니다.

```c
void *calloc(size_t num, size_t size);
```

- 인자 `num`은 요수의 개수를 받습니다. `size` 각 요소의 바이트 단위 크기입니다.
- 힙 영역에 할당된 메모리 덩어리 중 첫 번째 바이트 주소를 반환합니다.
  - 할당된 메모리 크기는 `num` 인자와 `size` 인자의 값을 곱한 크기
  - 에러가 발생하면 `NULL`을 반환

배열 선언과 비슷하게 요소의 크기와 개수를 받습니다. 의도적으로 12 대신에 `sizeof` 연산자를 이용하면 의도를 더 잘 들어낼 수 있기 때문입니다.

동적 할당한 메모리를 사용할 때 배열처럼 다루듯 처리할 수 있다는 사실은 이미 확인했습니다. 다음 예제는 6바이트 메모리를 동적으로 할당하고 `char` 타입 배열처럼 사용한 예시입니다. 기존과 약간 다른 방식으로 배열 선언 및 데이터 영역에 저장된 문자열에 대한 포인터를 다루는 방법을 비교해서 설명한 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szBuffer[] = {"Hello"};
  char *pszBuffer = "Hello";
  char *pszData = NULL;

  pszData = (char *)malloc(sizeof(char) * 6);
  pszData[0] = 'H';
  pszData[1] = 'e';
  pszData[2] = 'l';
  pszData[3] = 'l';
  pszData[4] = 'o';
  pszData[5] = '\0';

  puts(szBuffer);
  puts(pszBuffer);
  puts(pszData);

  free(pszData);

  return EXIT_SUCCESS;
}
/*Hello*/
/*Hello*/
/*Hello*/
```

`char szBuffer[] = {"Hello"};` 이렇게 선언하는 것은 문법적으로 문제가 되지 않습니다. 컴파일 단계에서 사이즈를 보고 처리하면 되기 때문입니다. 이렇게 선언하면 여전히 스텍에 할당됩니다.

`char *pszBuffer = "Hello";` 이렇게 정의하면 그냥 포인터를 할당한 것입니다. 이렇게 선언하면 읽기 전용에 저장하고 메모리 주소를 통해 접근해서 읽기를 하는 것입니다. 포인터가 가리키는 대상이라 r-value입니다.

`malloc`을 통해 선언한 경우가 동적할 당에 해당합니다. 또 일반배열처럼 사용할 수 있습니다. l-value처럼 사용할 수 있습니다.

```c
#include <malloc/malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char *pszData = NULL;

  pszData = (char *)malloc(sizeof(char) * 6);
  if (pszData == NULL) {
    perror("Failed to allocate memory");
    return EXIT_FAILURE;
  }

  printf("Allocated memory size: %zu\n", malloc_size(pszData));
  printf("Usable memory size: %zu\n", malloc_good_size(sizeof(char) * 6));

  free(pszData);
  return EXIT_SUCCESS;
}
```

메모리 사이즈를 알려준다고 했는데 C 언어에서 약간의 저혼자 경험하는 난제를 발견했네요.

#### 메모리 복사

배열은 여러 인스턴스가 뭉쳐진 경우엔 절대로 단순 대입으로 r-value를 l-value로 복사할 수 없습니다. 배열 문법 배울 때 이미 다루었습니다.

- 다음은 메모리 복사를 다루는 예제입니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szBuffer[12] = {"HelloWorld"};
  char szNewBuffer[12] = {0};

  memcpy(szNewBuffer, szBuffer, 4);
  puts(szNewBuffer);

  memcpy(szNewBuffer, szBuffer, 6);
  puts(szNewBuffer);

  memcpy(szNewBuffer, szBuffer, sizeof(szBuffer));
  puts(szNewBuffer);

  return EXIT_SUCCESS;
}
/*Hell*/
/*HelloW*/
/*HelloWorld*/
```

배열 식별자는 주소상수입니다. 그래서 메모리상 쓰기를 직접할 수 없습니다. 배열 식별자에 직접 할당 연산(`szNewBuffer = szBuffer`)이 허용되지 않습니다. 이런 이유로 전에는 배열의 인덱스를 알아내고 요소별로 할당을 수행하고 복사를 했습니다. 이런 것은 `memcpy`로 이제 대체할 수 있게 됩니다.

```c
void *memcpy(void *dest, const void *src, size_t count);
```

- dest는 복사하고 붙여넣기 할 메모리 주소입니다. src는 복하기 위한 원본 메모리 주소입니다. count는 복사할 메모리의 크기입니다.
- 반환 값은 복하고 붙여 넣은 메모리 주소입니다.
- 특정 메모리 주소로 시작하는 메모리 주소에서 복하려는 사이즈 만큼 그대로 복사해줍니다.

문자열 끝에 `\0`은 그래도 유지됩니다.

연습 문제입니다. 2가지 심각한 오류 및 결함을 찾고 수정하세요.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[12] = {"HelloWorld"};
  char *pszData = NULL;

  pszData = (char *)malloc(sizeof(char) * 12);
  pszData = szBuffer;
  puts(pszData);

  return EXIT_SUCCESS;
}
/*HelloWorld*/
```

위 코드입니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szBuffer[12] = {"HelloWorld"};
  char pszData[sizeof(szBuffer)] = {0};

  memcpy(pszData, szBuffer, sizeof(szBuffer));
  puts(pszData);

  return EXIT_SUCCESS;
}
/*HelloWorld*/
```

이렇게 수정할 수 있습니다. 문제를 엉뚱하게 다루었습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[12] = {"HelloWorld"};
  char *pszData = NULL;

  pszData = (char *)malloc(sizeof(char) * 12);
  pszData = szBuffer;
  puts(pszData);

  return EXIT_SUCCESS;
}
/*HelloWorld*/
```

여기서 문제가 되는부분은 `free`입니다. 할당을 하면 해제를 해줘야 합니다. 배열을 할당 연산으로 복사하려는 것이 잘못되는 것도 맞기는 하지만 해제가 더 큰 문제입니다.

`pszData = szBuffer;` 이렇게 되면 복사가 아닙니다. 배열에 담긴 내용이 동적 할당한 메모리로 복사되는 것이 아니라 `pzsData` 포인터 변수에 `szBuffer` 라는 메모리 주소만 넣은 것입니다. 그래서 저장된 메모리 주소의 값을 출력하지만 복사는 아닙니다.

`pszData`를 담겨 있던 정보가 단순 대입연산으로 유실됩니다. 점유하는 메모리를 해제할 방법이 없어집니다. 할당을 받아도 반환 방법이 없고 메모리 누수가 발생할 것입니다. 복사를 할 때는 주소를 복사하지 말고 내용을 복사해야 합니다. 즉 깊은 복사를 수행해야 합니다.

2개의 메모리 주소가 접근할 수 있어야 합니다. 독립적인 동일한 내용을 복사하는 것을 보고 깊은 복사라고 부릅니다.

지금의 주소만 복사하는 것은 얕은 복사라고 합니다. 포인터는 주소만 담는 경우도 있습니다. 하지만 지금은 적절하지 않습니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szBuffer[12] = {"HelloWorld"};
  char *pszData = NULL;

  pszData = (char *)malloc(sizeof(char) * 12);
  strcpy(pszData, szBuffer);

  puts(pszData);
  free(pszData);
  return EXIT_SUCCESS;
}
```

`strcpy`를 이용해 메모리에 저장된 문자열을 깊은 복사를 할 수 있도록 함수입니다. `memcpy`를 사용해도 문제 없습니다. 그냥 더 편한 것 뿐입니다. 메모리를 헤제하는 부분까지 포함해야 정답입니다.

```c
void *strcpy(char *strDestination, const char *strSource);
```

```c
void *strncpy(char *strDestination, const char *strSource, size_t count);
```

`strcpy`는 `memcpy`와 비슷합니다. 두 함수는 메모리 내용을 복사합니다. `strcpy`는 메모리의 내용이 모두 문자열이라고 간주합니다. 복사해야 할 메모리의 크기는 함수 스스로 결정합니다. `memcpy`처럼 복사할 크기를 명시할 필요가 없습니다. `strncpy`는 크기를 명시해야 합니다. 바이트 단위가 아니고 문자열 단위입니다.

`strcpy`는 깊은 복사 때문에 자주 사용될 수 밖에 없습니다. 잘 알아둬야 할 점은 보안 결함이 있는 함수입니다. 윈도우는 `strcpy_s`을 사용하고 리눅스 계열은 `strncpy`를 대체함수로 사용합니다. 문제의 정답은 결국에는 틀린 것입니다.

#### 메모리 비교 `memcmp`, `strcmp`

```c
void *memcmp(const void *buf1, const void *buf2, size_t count);
```

- `buf1`은 원본 메모리 주소입니다. `buf2`는 비교 대상 메모리 주소입니다. `const`는 비교할 메모리의 바이트 단위 크기입니다.
- 반환 값은 `0`이면 같은 것입니다. 논리적으로 `buf1 - buf2`로 같은지 알아냅니다. unsigned char처럼 음수가 언더 플로우 현상이 발생해 제일 큰 숫자라 될 수 있습니다. 핵심은 `0`이면 같은 것입니다.
- 주어진 길이만큼 두 메모리 주소를 비교하는 함수입니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szBuffer[12] = {"TestString"};
  char *pszData = "TestString";

  printf("%d\n", memcmp(szBuffer, pszData, 10));
  printf("%d\n", memcmp("testString", pszData, 10));
  printf("%d\n", memcmp("DataString", pszData, 10));

  return EXIT_SUCCESS;
}
/*0*/
/*1*/
/*-1*/
```

이 코드를 제대로 이해하려면 우선 `szBuffer` 배열과 `pszData`가 가리키는 메모리의 내용이 어떻게 다른지 생각해볼 필요가 있습니다. `memcmp` 함수는 두 메모리가 저장된 정보를 일정 단위로 잘라서 감산 연산한 결과가 0인 동안 계속 반복하기 때문입니다.

10번 비교해서 10개 항이 모두 결과가 0이면 같은 것입니다. 하나라도 다르면 아니라고 결론을 내려야 합니다. 결국에는 문자열은 숫자입니다. 이숫자를 비교하면 됩니다. 아스키 표를 보고 비교를 하면 됩니다. 지금의 경우 소문자(지금 예시에서 `t`)가 큰 경우 양수가 되고 더 작은 `D`의 경우 음수가 나온 것입니다. 이 원리를 충실하게 따르고 있습니다.

다음은 문자열 비교에 논리적으로 심각한 결함이 있습니다. 입문자에게 자주 있는 실수입니다. 기억하기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[12] = {"TestString"};
  char *pszData = "TestString";

  printf("%d\n", szBuffer == pszData);
  printf("%d\n", "TestString" == pszData);
  printf("%d\n", "DataString" == pszData);

  return EXIT_SUCCESS;
}
```

일단 린트에러부터 발생합니다. 그리고 컴파일에러도 발생하고 있습니다. 배열의 이름은 주소사숭입니다. 포인터 변수에 저장된 정보는 메모리의 주소입니다. 주소가 같은 주소인지 비교하는 것에 불과합니다. 수소가 같은지 확인하는 것이 아니라 문자열 정보가 같은지 비교하려는 의도였으면 당연히 틀렸습니다. 주소 말고 내용으로 비교해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szBuffer[12] = {"TestString"};
  char *pszData = "TestString";

  printf("%d\n", strcmp(szBuffer, pszData));
  printf("%d\n", strcmp("TestString", pszData));
  printf("%d\n", strcmp("DataString", pszData));

  return EXIT_SUCCESS;
}
/*0*/
/*0*/
/*-1*/
```

이렇게 해야 올바른 비교가 됩니다. `strcmp`는 `memcmp`와 비슷합니다. 특히 뻴셈 연산으로 정보 비교하는 원리는 같습니다. 하지만 비교 대상을 문자열로 가정하고 실행합니다. 메모리 길이를 받지 않습니다. `memcmp`는 함수는 같지만 문자열의 경우 길이가 다를 수 있습니다.

길이가 다르면 일단 둘다 다른 문자열입니다.

문자열을 비교했을 때 어느 문자열의 값이 더 큰지 비교하는 방법은 사전을 검색하는 방법과 일치합니다. `strncmp`함수를 이용하면 문자열의 앞에서 일정 길이만 비교할 수 있습니다.

#### 문자열 검색

```c
void *strstr(const char *string, const char *strCharSet);
```

- 첫번째 인자는 검색 대상이 되는 문자열이 저장된 메모리 주소입니다. 주번째 인자는 검색할 문자가 저정된 메모리 주소입니다.
- 문자열을 찾으면 해당 문자열이 저장된 메모리 주소를 반환합니다. 없으면 `NULL`을 반환합니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szBuffer[32] = {"I am a boy."};
  printf("%p\n", (void *)(szBuffer));

  printf("%p\n", (void *)(strstr(szBuffer, "am")));
  printf("%p\n", (void *)(strstr(szBuffer, "boy")));

  printf("index : %ld\n", strstr(szBuffer, "am") - szBuffer);
  printf("index : %ld\n", strstr(szBuffer, "boy") - szBuffer);
  return EXIT_SUCCESS;
}
/*0x16d5030b0*/
/*0x16d5030b2*/
/*0x16d5030b7*/
/*index : 2*/
/*index : 7*/
```

인덱스를 찾거나 직접 주소를 찾거나 가능합니다. 이 정보를 활용하면 메모리 주소의 연속된 구조를 생각해볼 수 있습니다. 메모리 주소의 마지막 위치만 보면 인덱스를 그대로 출력하고 있습니다.

`strstr` 함수가 검색에 성공했을 때 반환하는 메모리의 주소는 첫번째 인수로 절달된 메모리의 주소보다 값이 더 큰 숫자입니다. 더 큰 줏자에서 기준이 되는 주소를 빼면 바로 인덱스가 나옵니다.

#### 배열 연산자 풀어쓰기

1차원 배열 포인터 관점입니다. 기준주소에서 일정 인덱스만큼 떨어진 상대주소를 배열의 원소의 변수로 지정하는 연산이라고 할 수 있습니다.

`*(기준주소 + 인덱스)` 혹은 `기준주소[인덱스]`과 같은 의미입니다. 내부원리는 명확히 파악하기 어려워도 반드시 알아야 합니다. 간접지정 연산자를 활용하면 이해가 수월합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[32] = {"You are a girl."};
  printf("%c\n", szBuffer[0]);
  printf("%c\n", *szBuffer);
  printf("%c\n", *(szBuffer + 0));

  printf("%c\n", szBuffer[5]);
  printf("%c\n", *(szBuffer + 5));

  printf("%s\n", &szBuffer[4]);
  printf("%s\n", &*(szBuffer + 4));
  printf("%s\n", szBuffer + 4);

  return EXIT_SUCCESS;
}
/*Y*/
/*Y*/
/*Y*/
/*r*/
/*r*/
/*are a girl.*/
/*are a girl.*/
/*are a girl.*/
```

`*(szBuffer + 0)`은 `szBuffer[0]`을 풀어 쓴 것입니다. `0`은 안 더해도 상관없습니다. 배열을 이루고 있는 요소의 자료형이 char 타입입니다. 간접 지정 연산의 결과 모두 char 타입 l-value입니다.

어려우면 `%s`는 배열의 이름과 대응되면 된다고 생각하면 됩니다.

마지막은 인덱스가 모두 4인 원소의 주소입니다. 그이후부터 문자열끝까지 하나로 묶어서 출력합니다.

이해가 어렵다면 그림을 그려보고 DAP을 활성화해보기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[32] = {"You are a girl."};
  char *pszData = szBuffer + 4;

  printf("%c\n", szBuffer[0]);
  printf("%c\n", pszData[0]);
  printf("%c\n", pszData[6]);

  printf("%s\n", szBuffer + 4);
  printf("%s\n", pszData);
  printf("%s\n", pszData + 4);

  return EXIT_SUCCESS;
}
/*Y*/
/*a*/
/*g*/
/*are a girl.*/
/*are a girl.*/
/*a girl.*/
```

`szBuffer[0]`은 직관적입니다. 첫번째 문자을 바로 보여줍니다. `pszData[0]`은 4만큼 인덱스를 이동한 주소입니다. 이 주소의 시작 문자를 출력합니다. 시작하는 인덱스에서 6인덱스만 큼이동한 것입니다.

`szBuffer + 4`은 문자열 주소를 받는데 거기서 인덱스를 4만큼 이동하고 거기서부터 읽기 시작한 것입니다. `pszData + 4`은 정의할 때부터 4만큼 이동했는데 4를 또 이동한만큼 출력한 것입니다.

```c
void *realloc(void *memblock, size_t size);
```

- `memblock` 기존에 동적할당된 메모리 주소
  - 만일 이 주소가 `NULL` 이면 `malloc` 함수와 동일하게 동작
- `size` 다시 할당받을 메모리의 바이트 단위 크기
- 다시 할당된 메모리 덩어리 중 첫번째 바이트의 메모리 주소
  - 재할당에 실패하면 NULL 반환
    - 재할당 실패할 경우 첫번째 인자로 전달된 메모리를 수동으로 해제해야 함
- 이미 할당된 메모리를 이름처럼 재할당하는 함수입니다.

```c
void *sprintf(char *buffer, const char *format [, argument]...);
```

- `buffer` 출력 문자열이 저장된 메모리 주소
- `format` 형식 문자열이 저장된 메모리 주소
- `[, argument]` 형식 문자열에 대응되는 가변 인자들
- 출력된 문자열의 개수를 반환
- 형식 문자열에 맞추어 특정 메모리에 문자열을 저장하는 함수

문자열이 콘솔 화면에 출력되는 것이 아니라 특정 주소의 메모리에 출력합니다. 형식 문자열을 조합할 수 있었어 편리합니다.

```c
#include <malloc/malloc.h>
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  char *pszBuffer = NULL, *pszNewBuffer = NULL;

  pszBuffer = (char *)malloc(12);
  sprintf(pszBuffer, "%s", "TestString");
  printf("[%p] %ld %s\n", (void *)pszBuffer, malloc_size(pszBuffer), pszBuffer);

  pszNewBuffer = (char *)realloc(pszBuffer, 32);
  if (pszNewBuffer == NULL) {
    free(pszBuffer);
  }
  sprintf(pszNewBuffer, "%s", "TestStringData");
  printf("[%p] %ld %s\n", (void *)pszNewBuffer, malloc_size(pszNewBuffer),
         pszNewBuffer);
  free(pszNewBuffer);

  return EXIT_SUCCESS;
}
/*[0x600003220020] 16 TestString*/
/*[0x600003025240] 32 TestStringData*/
```

메모리 패딩 현상이 발생해서 12를 16으로 채운 것 같습니다.

최초로 할당받은 메모리가 32바이트로 늘리는데 성공했습니다. 확장에 실패하면 다른 주소를 반환 할 것입니다. 중요한 것은 `realloc`이 실패할 수 있는 경우입니다. 너무 큰 크기의 메모리로 확장을 시도하면 운영체제가 못늘려줄 수 있습니다. `realloc`이 `NULL`을 반환하고 첫번째 인자를 메모리를 해제해주지도 않습니다.

동적 할당하는 메모리가 내부적으로는 일정 크기의 덩어리로 관리되기 때문입니다. 덩어리가 지금은 16입니다. 그래서 12를 해도 12 단위로 소비하게 됩니다.

`malloc`과 `realloc`은 메모리 소매상으로 생각할 수 있습니다. 운영체제를 메모리 공장으로 비유하면 사용자는 메모리 소비자입니다. 소매상은 공장에서 꽤 큰 덩어리의 메모리를 가져와 일정 크기로 잘라 소비자에게 전달합니다.

#### 잘못된 메모리 접근

C/C++ 개발을 할 때 경계 검사는 영원한 숙제입니다. 다음은 배열의 경계문제를 보여주는 예시입니다.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_BUF_SIZE 32

int main(void) {
  char *pszBuffer = NULL;
  pszBuffer = (char *)malloc(MAX_BUF_SIZE);
  fgets(pszBuffer, sizeof(pszBuffer), stdin);
  puts(pszBuffer);

  free(pszBuffer);

  return EXIT_SUCCESS;
}
/*Hong gildong*/
/*Hong gi*/
```

- 경계를 초가하면 동적 할당된 메모리 단편이 훼손됩니다. 그 훼손 사실이 확인되는 것은 메모리가 반환될 때입니다.

- 먼저 `fgets`를 사용해야 컴파일러 에러를 통과할 수 있습니다.

- 문자열이 깨졌다라는 말이 가끔 있습니다. 문��열 입출력 과정에서 메모리를 잘못 사용한 것입니다. 가장 흔한 실수는 메모리의 경계를 넘긴 입/출력을 수행한 것입니다. 자신에게 할당된 메모리가 아니라 엉뚱한 메모리에 대해 입출력을 수행한 경우입니다. 이런 오류를 해결할 때는 메모리를 그림으로 그려보고 디버거를 사용하기 바랍니다.

### 포인터의 배열과 다중 포인터

포인터는 변수 자체의 주소와 변수에 저장된 주소, 이렇게 2개의 주소가 공존합니다.

다중 포인터라는 것도 사실은 단순히 일반 포인터와 다를 것이 없습니다. 포인터가 가리키는 것이 포인터 변수일뿐입니다. `int` 타입에 대한 포인터는 `int *`으로 기술하고 그에 대한 포인터는 `int **`으로 기술합니다. 선언된 포인터 변수에 대해 간접지정 연산을 수행한 결과는 포인터의 대상 자료형에 `*` 하나 지운것과 같습니다.

다중 포인터를 배우기 전에 포인터도 변수라는 사실과 간접지정 연산결과의 자료형이 무엇인지 명확히 알 수 있어야 이해력을 높일 수 있습니다.

| 포인터 자료형 | 간접지정 연산결과       | 코드 예                                 |
| ------------- | ----------------------- | --------------------------------------- |
| `char *`      | `*(char *) == char`     | `int nData = 10; int *pnData = &nData;` |
| `char **`     | `*(char **) == char*`   | `int* *ppnData = &pnData;`              |
| `char ***`    | `*(char ***) == char**` | `int** *pppnData = &ppnData;`           |

#### `char*`의 배열

다중 포인터가 등장하는 흔한 이유는 '포인터의 배열' 때문입니다. 포인터 배열이란 배열의 원소가 포인터 변수인 경우를 말합니다.

배열(`char[5]`)을 이루고 있는 원소 자료형(`char`)에 대한 포인터(`char*`)에 담습니다.

`%s` 형식문자는 자료형이 `char*`에 대응해야 하며, `%c`는 `char` 타입에 대응해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char *astrList[3] = {"Hello", "World", "String"};

  printf("%s\n", astrList[0]);
  printf("%s\n", astrList[1]);
  printf("%s\n", astrList[2]);

  printf("%s\n", astrList[0] + 1);
  printf("%s\n", astrList[1] + 2);
  printf("%s\n", astrList[2] + 3);

  printf("%c\n", astrList[0][3]);
  printf("%c\n", astrList[1][3]);
  printf("%c\n", astrList[2][3]);

  return EXIT_SUCCESS;
}
/*Hello*/
/*World*/
/*String*/
/*ello*/
/*rld*/
/*ing*/
/*l*/
/*l*/
/*i*/
```

1차원 구조의 자료형 두 종류(포인터 배열과 문자 배열)가 묶여서 논리적인 2차원 구조를 만들었습니다.

배열 속에는 문자배열의 주소만 있는 것입니다.

`*` 표시가 붙어있으면 보통 따라가라고 생각할 수 있습니다.

`astrList[0] + 1`을 보면 `*(astrList + 인덱스)`로 생각할 수 있습니다. 기준주소에서 인덱스만큼 이동한 상대 주소를 지정한다는 의미로 생각할 수 있습니다.

`*(배열요소에 대한 포인터 + 인덱스)`로 생각하는 것도 가능합니다. `*(char** + int)` 이런식으로 생각하는 것도 가능합니다.

`astrList[1][3]`을 풀어서 생각하면 `*(*(astrList + 1) + 3)`이 됩니다. 간접지정 연산 두번 수행한 것에 불과합니다. ~~책 오타인지 모르겠습니다.~~

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
  int i = 0;
  for (i = 0; i < argc; ++i) {
    puts(argv[i]);
  }

  puts("End");
  return EXIT_SUCCESS;
}
```

`main`의 원형입니다. 첫번째 매개변수는 커맨드 개수이고 두번째 매개변수는 개별 커맨드입니다.

매개변수를 출력하는 예제입니다. 배열 다중 포인터의 해당하는 경우입니다.

#### 다중 포인터

포인터에 대한 포인터 변수를 선언 및 정의한 다중 포인터 예제입니다. 3중 포인터도 자주 사용합니다. 문법으로 사용하는 방법을 익히는 것은 당연합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch = 'A';
  char *pData = &ch;
  char **ppData = &pData;
  char ***pppData = &ppData;

  printf("%c\n", ch);
  printf("%c\n", *pData);
  printf("%c\n", **ppData);
  printf("%c\n", ***pppData);

  return EXIT_SUCCESS;
}
/*A*/
/*A*/
/*A*/
/*A*/
```

생각조금 하면 단순한 예제입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char *astrList[3] = {"Hello", "World", "String"};
  char **ppstrList = astrList;
  char ***pppstrList = &ppstrList;

  puts(ppstrList[0]);
  puts(ppstrList[1]);
  puts(ppstrList[2]);

  puts(*pppstrList[0]);
  puts(*(*(pppstrList + 0) + 1));

  return EXIT_SUCCESS;
}
/*Hello*/
/*World*/
/*String*/
/*Hello*/
/*World*/
```

#### 다차원 배열에 대한 포인터

2차원 배열은 원소가 배열인 배일입니다. 배열의 식별자인 주소를 저장할 수 있는 포인터 변수는 배열 원소의 자료형에 대한 포인터입니다.

`char[3][16]`은 `char[16]`이 3개인 배열입니다. 이 주소를 답을 변수 `char[16]*`입니다. 하지만 이렇게 표현하면 문법오류입니다. 한 단계 더 처리해야 합니다. 다차원 배열에 대한 포인터 변수를 선언할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char astrList[2][12] = {"Hello", "World"};
  char(*pstrList)[12] = astrList;

  puts(pstrList[0]);
  puts(pstrList[1]);
  return EXIT_SUCCESS;
}
/*Hello*/
/*World*/
```

문법적으로 바른 표현이 되려면 위처럼 작성해야 합니다. `char (*) [12]`으로 표현해야 합니다. 사람들은 `char[12] *`로 선언해야 할 것이라고 많이 착각합니다. 이렇게 되면 문법 오류입니다.

배열의 요소 타입에 대한 포인터를 담는다고 해야 합니다. 이렇게 되면 생각이 조금 쉬워집니다. 영상처리에는 다차원 배열 포인터를 자주 사용합니다. 눈으로 볼 수 있는 이미지는 논리적으로 2차원 배열입니다.

### 변수와 메모리

변수의 본질은 메모리입니다. 스택, 힙, 텍스트, 데이터 영역 메모리를 주로 사용할 수 있습니다. 변수를 선언하는 것은 함수 내부에 속한 지역 변수이고 지역 변수는 4종류 메모리 중에도 스택에 할당합니다. 스택 구조는 메모리는 관리가 자동으로 처리합니다. 사용하는 변수를 자동변수라고 부릅니다.

아무런 언급이 없는 지역변수는 컴파일러가 알아서 모두 자종변수로 처리합니다. 이런 이유로 특별히 명시한 것은 아닙니다. 메모리 부류 지정자를 앞으로 다룰 것입니다.

C 언어는 지정자로 기술 할 수 있는 예약어에 `extern`, `auto`, `static`, `register` 등이 있습니다. 여기서 레지스터는 메모리가 아니라 진짜 CPU 레지스터를 의미합니다. 가장 빠른 메모리에 해당합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  auto int aList[3] = {10, 20, 30};
  auto int i = 0;

  for (i = 0; i < 3; ++i) {
    printf("%d\t", aList[i]);
  }

  return EXIT_SUCCESS;
}
/*10	20	30*/
```

스코프 내부에서는 메모리 지정자를 생략하면 모두 `auto`로 간주합니다. 하지만 C++ 11부터 `auto`의 의미가 달라졌습니다. 그래서 이 설명은 C++에 적용되지 않습니다.

전역변수 정적변수가 사용하는 데이터 영역 메모리는 프로그램이 시작될 때 확보되어 정료까지 유지합니다. 함수가 호출되어 스코프가 열리고 닫혀도 사라지는 것이 아닙니다.

#### 정적변수 static

```c
#include <stdio.h>
#include <stdlib.h>

int TestFunc(void) {
  static int nData = 10;
  ++nData;
  return nData;
}

int main(void) {
  printf("%d\n", TestFunc());
  printf("%d\n", TestFunc());
  printf("%d\n", TestFunc());

  return EXIT_SUCCESS;
}
/*11*/
/*12*/
/*13*/
```

static 변수는 전역변수처럼 선언될 때 단 한번만 초기화합니다.

함수가 반환해(메모리가 사라지지 않으므로) `nData` 변수는 전역변수처럼 그대로 존재합니다.

- 기술적으로 전역변수나 정적변수는 ������ 동시성을 지원하가 어렵습니다. 멀티 스레드를 넘어 물리적으로 CPU 코어 개수가 여러 개인 지금 동시성, 병렬처리랑 직결되고 병렬처리를 다시 성능과 직결됩니다.

#### 레지스터 변수 register

레지스터 변수는 CPU 레지스터를 사용하기 위한 것입니다. 지금도 레지스터 변수를 다루는 일은 있을 것입니다. 임베디드 운영체제는 한국에서 자주 제작하기 때문에 가끔은 따질 필요가 있습니다. 문법상 주의할 것이 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  register int i = 0;
  printf("%d\n", i);
  /*printf("%d\n", &i);*/

  return EXIT_SUCCESS;
}
/*0*/
```

레티스터 변수는 CPU의 일부이므로 별도로 주소거 없습니다.

CPU의 일부인 레지스터는 일반 메모리와 달리 주소가 아니라 고유명사로 식별됩니다. 저마다 고유한 기능과 이름이 붙어있습니다. 범용 레지스터라는 것이 존재하기는 하지만 그 레지스터들도 자기 이름이 있습니다.

레지스터 변수에 대해 일반 변수처럼 주소 연산을 수행할 수 없습니다. 그 외에 사용방법은 일반 자동변수랑 다르지 않습니다.

1. `int` 형 변수 `nData`가 선언되었다고 가정한다면, 소스코드에 기술된 `nData`와 `&nData`의 차이점이 무엇인지 기술하세요.

`nData`는 주소에 있는 값을 접근합니다. `&nData`는 변수의 주소를 접근합니다.

2. 매개변수로 `char *` 타입을 받아서 문자열의 길이를 계산해 반환하는 함수를 작성하세요. 함수의 이름은 `GetLength()`입니다.

```c
#include <stdio.h>
#include <stdlib.h>

/*
 * 매개변수로 `char *` 타입을 받아서 문자열의 길이를 계산해 반환하는 함수를
 * 작성하세요. 함수의 이름은 `GetLength()`입니다.
 */
int GetLength(char *str) {
  char *startRef = str;

  while (*startRef != '\0') {
    startRef++;
  }

  return startRef - str;
}

int main(void) {
  char szBuffer[16] = {"Hello"};

  printf("%d\n", GetLength(szBuffer));

  return EXIT_SUCCESS;
}
/*5*/
```

3. 다음 코드의 논리적 오류 2가지는 무엇이고 어떻게 수정해야 하는지 기술하시오.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[12] = {"HelloWorld"};
  char *pszData = NULL;

  pszData = (char *)malloc(sizeof(char) * 12);
  pszData = szBuffer;
  puts(pszData);

  return EXIT_SUCCESS;
}
```

`malloc`이 있으면 `free`가 필요합니다. 힙할당을 하면 나중에 해제를 해줘야 합니다.

`pszData`은 포인터 변수입니다. 문자열을 받기위한 포인터입니다. 하지만 지금은

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[12] = {"HelloWorld"};
  char *pszData = NULL;

  pszData = (char *)malloc(sizeof(char) * 12);
  sprintf(pszData, "%s", szBuffer);
  puts(pszData);
  free(pszData);
  return EXIT_SUCCESS;
}
```

출력하고 해제하면 됩니다. 그리고 복사용 함수를 사용해서 문자열 복사를 하면 됩니다.

4. 인터넷에서 `strrev()` 함수의 사용법에 대해 찾아보고 이 함수와 동일한 기능을 수행할 수 있는 `MyStrrev()` 함수를 작성하세요.

```c
#include <malloc/malloc.h>
#include <stdio.h>
#include <stdlib.h>

int GetLength(char *str) {
  char *startRef = str;

  while (*startRef != '\0') {
    startRef++;
  }

  return startRef - str;
}

char *MyStrrev(char *str) {
  // 처음부터 가운데까지 순회
  char temp = '\0';
  int i = 0, length = GetLength(str);
  for (i = 0; i < length / 2; ++i) {
    if (i == length - i - 1)
      break;
    // 양끝을 고르기
    // 자리를 교환
    temp = str[i];
    str[i] = str[length - i - 1];
    str[length - i - 1] = temp;
  }

  return str;
}

int main(void) {
  char *pszData = NULL;
  pszData = (char *)malloc(sizeof(char) * 16);
  sprintf(pszData, "%s", "HelloWorld"); // 힙 할당
  puts(pszData);

  MyStrrev(pszData);
  puts(pszData);
  free(pszData);
  return EXIT_SUCCESS;
}
/*HelloWorld*/
/*dlroWolleH*/
```

문자열 뒤집는 예제였습니다. 새로운 힙할당을 할 필요는 없고 주소를 전달하면 주소에 있는 값을 갱신하는 것이었습니다.

5. 사용자로부터 입력받은 첫 번째 문자열을 동적 할당된 메모리에 저장한 후 화면에 출력하고, 두 번째로 입력 받은 문자열을 첫 번째로 동적 할당된 메모리에 덧붙여 출력하는 프로그램을 작성합니다. 이때, 메모리가 부족해서 문제가 발생하지 않도록 메모리의 크기를 조정합니다. 기존에 할당받은 메모리의 크기를 늘려도 좋고 다시 할당받아도 좋습니다. 혹은 두 경우를 모두 구현하는 것도 좋습니다.

```c
#include <malloc/malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUF_UNIT 16 * sizeof(char)

/*
 * 사용자로부터 입력받은 첫 번째 문자열을 동적 할당된 메모리에 저장한 후 화면에
 * 출력하고, 두 번째로 입력 받은 문자열을 첫 번째로 동적 할당된 메모리에 덧붙여
 * 출력하는 프로그램을 작성합니다. 이때, 메모리가 부족해서 문제가 발생하지
 * 않도록 메모리의 크기를 조정합니다. 기존에 할당받은 메모리의 크기를 늘려도
 * 좋고 다시 할당받아도 좋습니다. 혹은 두 경우를 모두 구현하는 것도 좋습니다.
 */
int main(void) {
  printf("%ld글자 이하로 입력하세요. : ", BUF_UNIT);
  char *firstInput = NULL;
  firstInput = (char *)malloc(BUF_UNIT);             // 힙에 저장
  fgets(firstInput, malloc_size(firstInput), stdin); // 사용자로부터 입력
  puts(firstInput);

  // 개행문자 제거
  firstInput[strlen(firstInput)-1] = 0;

  printf("%ld글자 이하로 입력하세요. : ", BUF_UNIT);
  char *secondInput = NULL;
  secondInput = (char *)malloc(BUF_UNIT);              // 힙에 저장
  fgets(secondInput, malloc_size(secondInput), stdin); // 사용자로부터 입력

  if (strlen(firstInput) + strlen(secondInput) + 1 >= BUF_UNIT) {
    printf("메모리 확장\n");
    firstInput = (char *)realloc(firstInput, BUF_UNIT * 2); // 공간 확장
    if (firstInput == NULL) {
      free(firstInput);
      free(secondInput);
      return EXIT_FAILURE;
    }
  }

  strcat(firstInput, secondInput);
  printf("붙인 문자열: %s\n", firstInput);

  free(firstInput);
  free(secondInput);
  return EXIT_SUCCESS;
}
```

교훈 `\0`을 만나면 형식문자는 더이상 출력을 하지 않습니다. `\0`이 붙은 상태로 이어 붙인 것이었습니다.

6. 정수를 입력받고, 그 개수만큼 `char *`를 여러 개 저장할 수 있는 메모리를 동적 할당합니다. 그리고 입력할 문자열의 최대 길이를 입력받고, 최대 길이의 문자열을 저장할 수 있는 크기의 메모리를 동적 할당하여 입력받은 문자열을 저장한 후 출력하는 프로그램을 작성합니다.

```c
#include <malloc/malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * 정수를 입력받고, 그 개수만큼 `char *`를 여러 개 저장할 수 있는 메모리를 동적
 * 할당합니다. 그리고 입력할 문자열의 최대 길이를 입력받고, 최대 길이의 문자열을
 * 저장할 수 있는 크기의 메모리를 동적 할당하여 입력받은 문자열을 저장한 후
 * 출력하는 프로그램을 작성합니다.
 */
int main(void) {
  int inputNum = 0, bufSize = 0, i = 0;
  unsigned long max = 0;
  printf("비교할 문자열의 개수를 정해주세요 : ");
  scanf("%d%*c", &inputNum);
  printf("최대 문자열의 길이를 정해주세요 : ");
  scanf("%d%*c", &bufSize);
  bufSize = sizeof(char) * bufSize;

  if (inputNum <= 0 || bufSize <= 0) {
    return EXIT_FAILURE;
  }

  // 배열의 원소는 포인터
  char *(inputArray)[inputNum];

  for (i = 0; i < inputNum; ++i) {
    inputArray[i] = malloc(bufSize);
    fgets(inputArray[i], bufSize, stdin);
  }

  for (i = 0; i < inputNum; ++i) {
    printf("%s\n", inputArray[i]);
    if (strlen(inputArray[i]) > max)
      max = strlen(inputArray[i]);
    free(inputArray[i]);
  }
  printf("max: %ld\n", max);
  return EXIT_SUCCESS;
}
```

## 함수 응용

기본 이론은 포인터를 배우기 전과 후로 나눕니다. C 언어에서 함수를 제대로 활용하려면 반드시 포인터를 알아야 합니다.

지금부터는 기본적인 함수 관련 문법, 메모리의 동적 할당 및 해제에 대해 알고 있다고 가정합니다.

가장 실질적인 포인터, 함수활용 사례가 담긴 것은 바로 이번 장도 해당합니다. 실무에서 가장 많이 등장할 가능성이 높은 형식들을 설명한다고 생각해도 좋습니다.

### 매개변수 전달 방법

호출자 정의자의 관계를 묶는 것은 바인딩입니다. 두 함수가 서로 연결되는 인터페이스는 바로 매개변수와 반환 타입입니다. 매개변수로 전달하는 정보가 무엇이냐에 따라 매개변수 전달방법이 달라집니다. 기본적으로 Call by Value, Call by Reference로 나누어집니다.

```c
#include <stdio.h>
#include <stdlib.h>

int add(int a, int b) { return a + b; }

int main(void) {
  printf("%d\n", add(3, 4));
  return EXIT_SUCCESS;
}
/*7*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int add(int *a, int *b) { return *a + *b; }

int main(void) {
  int a = 3, b = 4;
  printf("%d\n", add(&a, &b));
  return EXIT_SUCCESS;
}
/*7*/
```

핵심은 매개변수가 포인터라는 점입니다. 호출자는 주소를 인자로 대입해야 합니다. 주소를 받은 매개변수는 주소가 가리키는 값을 활용해서 계산을 처리합니다.

이런 것의 장점은 배열처럼 큰 메모리를 매개변수로 전달할 수 있다는 점입니다.

```c
#include <stdio.h>
#include <stdlib.h>

void initList(int *pList, int nSize) {
  int i = 0;
  for (i = 0; i < nSize; ++i) {
    printf("정수를 입력하세요. : ");
    scanf("%d", &pList[i]);
  }
}

void SortList(int *pList, int nSize) {
  int i = 0, j = 0, nTmp = 0;
  for (i = 0; i < nSize - 1; ++i) {
    for (j = i + 1; j < 5; ++j) {
      if (pList[j] < pList[i]) {
        nTmp = pList[j];
        pList[j] = pList[i];
        pList[i] = nTmp;
      }
    }
  }
}

void PrintList(int *pList, int nSize) {
  int i = 0;
  for (i = 0; i < nSize; ++i) {
    printf("%d\t", pList[i]);
  }
}

int main(void) {
  int aList[5] = {0};
  initList(aList, 5);
  SortList(aList, 5);
  PrintList(aList, 5);

  return EXIT_SUCCESS;
}
/*정수를 입력하세요. : 20*/
/*정수를 입력하세요. : 40*/
/*정수를 입력하세요. : 30*/
/*정수를 입력하세요. : 10*/
/*정수를 입력하세요. : 50*/
/*10	20	30	40	50	%*/
```

이전에 봤던 예시이고 포인터를 이해하고 있었지만 뭐 알 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

void GetName(char *pszName, int nSize) {
  printf("이름을 입력하세요. : ");
  fgets(pszName, nSize, stdin);
}

int main(void) {
  char szName[32] = {0};
  GetName(szName, sizeof(szName));
  printf("당신의 이름은 %s입니다.\n", szName);
  return EXIT_SUCCESS;
}
/*이름을 입력하세요. : asdf*/
/*당신의 이름은 asdf*/
/*입니다.*/
```

포인터의 가장 큰 문제는 가리키는 대상의 실제 크기를 포인터 자체만으로는 알 수 없다는 점입니다.

`char *pszName`을 `char pszName[]`으로 정의했으면 더 명시적이었을 것입니다.

다음은 조금 변형한 예시입니다. 피 호출자 함수가 동적으로 할당한 메모리를 호출자 함수에서 해제하는 특징이 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

char *GetName(void) {
  char *pszName = NULL;
  pszName = (char *)calloc(32, sizeof(char));
  printf("이름을 입력하세요. : ");
  fgets(pszName, sizeof(char) * 32, stdin);
  return pszName;
}

int main(void) {
  char *pszName = NULL;
  pszName = GetName();
  printf("당신의 이름은 %s입니다.\n", pszName);
  free(pszName);
  return EXIT_SUCCESS;
}
/*이름을 입력하세요. : asdf*/
/*당신의 이름은 asdf*/
/*입니다.*/
```

`pszName`은 이름은 같지만 속한 스코프가 다릅니다. 당연히 다른 변수입니다. 각자 메모리 주소가 다를 것입니다. `calloc` 함수가 반환한 주소가 동적 할당한 메모리 주소입니다.

메모리를 할당하는 함수와 해제하는 함수가 달라질 수 있는 예시도 사용한다는 것을 기억하기 바랍니다. 정의자가 할당하고 호출자가 해제해야 하는 방식으로 작성하는 경우가 있습니다.

개발자는 변화를 하나하나 추적하는 것처럼 작성해서 오류를 해결해야 합니다. 메모리 혹은 변수를 추적할 수 없으면 개발자가 되려는 의지가 없는 것입니다.

다음은 Call By Reference로 자주 사용하는 예시입니다. 이해력이 부족하면 암기라도 하기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

void swap(int *pLeft, int *pRight) {
  int temp = *pLeft;
  *pLeft = *pRight;
  *pRight = temp;
}

int main(void) {
  int x = 10, y = 20;
  printf("x : %d, y : %d\n", x, y);
  swap(&x, &y);
  printf("x : %d, y : %d\n", x, y);
  return EXIT_SUCCESS;
}
/*x : 10, y : 20*/
/*x : 20, y : 10*/
```

포인터 변수를 받아 교환합니다.

다음은 문자열 길이를 측정하는 기능을 함수로 구현하는 것입니다. 문자열 길이를 측정하는 함수들은 많지만 이것도 그 중 하나입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int getLength(const char *pszParam) {

  int nLength = 0;
  while (pszParam[nLength] != '\0') {
    nLength += 1;
  }
  return nLength;
}

int main(void) {
  char *pszData = "Hello";
  printf("%d\n", getLength("Hi"));
  printf("%d\n", getLength(pszData));

  return EXIT_SUCCESS;
}
/*2*/
/*5*/
```

`const` 타입한정어입니다. 상수로 간주한다는 의미입니다. 이렇게 되면 읽기만 가능하고 쓰기를 할 수 없습니다.

이번에는 연습 문제입니다. 문자열 복사하는 함수를 만들기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBufferSrc[12] = {"TestString"};
  char szBufferDst[12] = {0};

  MyStrcpy(szBufferDst, sizeof(szBufferDst), szBufferSrc);
  puts(szBufferDst);
  return EXIT_SUCCESS;
}
```

위 `MyStrcpy`를 함수를 정의하기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

void MyStrcpy(char *dist, int size, char *target) {
  int nLength = 0;
  while (target[nLength] != '\0' && nLength <= size) {
    dist[nLength] = target[nLength];
    nLength += 1;
  }
}

int main(void) {
  char szBufferSrc[12] = {"TestString"};
  char szBufferDst[12] = {0};

  MyStrcpy(szBufferDst, sizeof(szBufferDst), szBufferSrc);
  puts(szBufferDst);
  return EXIT_SUCCESS;
}
```

저는 이렇게 해결 했습니다. 정답지는 예외처리가 추가되어 있습니다.

다음은 잘못된 주소 전달입니다.

정의자 함수가 포인터를 반환하는 경우 정의자 함수가 반환한 주소가 가리키는 대상 메모리 주소는 반드시 유효해야 합니다. 운영체제에 반환했거나 곧 사라질 메모리에 대한 주소를 반환하는 일은 없어야 합니다.

다음 예제처럼 주소를 반환하면 심각한 문제를 만들 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int *TestFunc(void) {
  int nData = 10;
  return &nData;
}

int main(void) {
  int *pnResult = NULL;
  pnResult = TestFunc();
  printf("%d\n", *pnResult);

  return EXIT_SUCCESS;
}
```

린트부터 경고 표시합니다. 스텍에 저장하는데 반환시도 하는 것이 잘못되었다고 알여줍니다. 함수 내부에 선언된 자동변수의 주소를 반환하는 것입니다. 정적 할당된 메모리도 아니고 정적 변수도 아닙니다.

스택은 스코프가 닫히면 그 내부에서 선언된 것들이 사실상 사라집니다. 사라질 자동변수의 주소를 반환하고 있습니다. 다행이 컴파일에러도 발생할 것입니다.

흥미로운 이유는 플래그를 꺼두고 컴파일하고 실행하면 사라진 대상 메모리에 간접지정 연산으로 접근해도 별다른 문제가 없어 보입니다. 이런 현상은 스택 메모리가 사라지거나 해제한 것이 아니라 가용메모리 범위가 줄어든 것(지정해제)에 불과합니다.

왜 작동하는가?

심각한 문제가 있음에도 제대로 값을 출력하면 심각한 문제입니다. 이런 코드가 잘못된 것이라는 사실을 인식하기 어렵습니다. 컴파일 오류는 최신화된 프로젝트에서는 확인할 수 있지만 일반적인 레거시에서는 어렵습니다. 일단 이런 오류는 무조건 수정해야 합니다. 전문개발자들은 "왜 동작하는 것인지 모르겠다. 작동하지 않는 것보다 더 큰 문제야"라고 말합니다. 정상적으로 작동하지 말아야 할 코드가 동적한 것은 정반대인 경우보다 더 심각한 상황입니다. 그냥 덮으면 곤란합니다.

### 스택 프레임 그리는 방법

함수 내부에 선언된 변수와 매개변수는 기본적으로 '스택'을 사용합니다.

스택은 선형 자료구조에 해당합니다. 이 스택 영역은 시스템이 관리합니다. 개발자가 스택 메모리의 지정과 해제에 관여할 필요도 없습니다. 또 관여하려고 하지 말아야 합니다.

스택이 어떤 형식으로 관리되는지 구체적으로 알아야 합니다. 관리 형식은 스택 프레임(stack frame)이라 합니다. 이번에는 스택 프레임을 구성하는 핵심 내용입니다. 스택은 최대 크기가 처음부터 정해져있습니다. 스택은 일정 크기의 주소에 주소가 증가하는 방향이 아닌 역방향으로 증가하기 때문입니다.

스택을 이해할 때는 그림을 그려보기 바랍니다.

스택의 왼쪽에는 함수의 이름과 스코프의 시작 지점을 표시하고 오른쪽에는 식별자의 이름을 기술합니다. 우리가 작성한 모든 예제들은 항상 `main()`에서 시작하기 때문에 최초로 늘어난 스택은 `main` 함수에 속한 것으로 가정합니다. 스택은 위로 쌓입니다. 메모리의 주소는 아래로 증가합니다. 메모리 주소가 증가했다는 것은 스택이 줄어들었음을 의미하고 주솟값이 작아졌다는 것은 스택의 증가를 의미한다고 생각할 수 있습니다.

```c
#include <stdlib.h>

int main(void) {
  int x = 10, y = 20;
  return EXIT_SUCCESS;
}
```

함수 내부에 선언된 변수를 순서대로 스택에 그려 표시합니다.

먼저 stack에 push했다는 개념으로 접근하면 됩니다.

포인터 변수는 별도로 표시합니다.

```c
#include <stdlib.h>

int main(void) {
  int x = 10, y = 20;
  int *pnData = &x;

  *pnData = 100;

  return EXIT_SUCCESS;
}
```

포인터 변수에 담긴 주소를 따라가면 원래 주소에 도달할 수 있다고 표시합니다.

포인터 변수는 간접지정 대상이 어디인지 포인터가 가리키는 지점을 표시해야 합니다. NULL로 초기화하면 NULL이라고 선을 그어 표시하지 않습니다. NULL 포인터는 아무것도 가리키지 않습니다.

배열의 인덱스는 아래로 증가하게 그립니다.

```c
#include <stdlib.h>

int main(void) {
  int aList[3] = {10, 20, 30};
  int *pnData = aList;
  *(pnData + 1) = 100;

  return EXIT_SUCCESS;
}
```

배열의 인덱스는 주소가 증가하는 방향으로 표시해야 합니다.

스택에 그릴 때 0번 요소가 스택의 상단에 표시되도록 그립니다. 배열의 이름은 주소상수이므로 그자체는 스택에 push하지 않습니다. 단지 주소에 대한 식별자로 표시만 합니다.

연산의 결과로 얻은 상대주소가 어디인지 스스로 표시할 수 있어야 합니다.

동적할당된 메모리는 따로 표시합니다. 메모리를 동적 할당하거나, 정정 영역을 사용하는 변수가 등장하면 이는 스택 영역이 아니므로 별도로 그려서 표시해야 합니다.

한 가지 주의해야 할 사항은 반드시 동적 할당된 메모리의 크기를 기술하고 동적 할당된 메모리의 기준주소를 포인터 변수가 가리키도록 선을 그어 표시해야 합니다.

```c
#include <stdlib.h>
#include <string.h>

int main(void) {
  int nData = 10;
  char *pszBuffer = NULL;
  pszBuffer = (char *)malloc(12);
  strcpy(pszBuffer, "Hello");
  free(pszBuffer);

  return EXIT_SUCCESS;
}
```

메모리는 해제하면 삭제표시도 하도록 합니다. 지워지지 않았다면 메모리 누수로 표시합니다. 스택프레임이 모두 사라져도 남는다면 메모리 누수를 발견한 것입니다.

매개변수는 오른쪽부터 스택에 그리며 새 스코프는 기존 스택 위에 그립니다.

```c
#include <stdlib.h>

int add(int a, int b) {
  int nResult = 0;
  nResult = a + b;
  return nResult;
}

int main(void) {
  int nResult = 0;
  nResult = add(3, 4);
  return EXIT_SUCCESS;
}
```

함수가 함수를 호출해 함수 몸체에 대한 스코프가 형성되면 스택에 가로선을 길게 그어 표시합니다.

스택을 `Add` 함수호출 전과 같은 상태로 되돌립니다.

```c
#include <stdio.h>
#include <stdlib.h>

char *GetName(void) {
  char *pszName = NULL;
  pszName = (char *)calloc(32, sizeof(char));
  printf("이름을 입력하세요. : ");
  fgets(pszName, sizeof(char) * 32, stdin);
  return pszName;
}

int main(void) {
  char *pszName = NULL;
  pszName = GetName();
  printf("당신의 이름은 %s입니다.\n", pszName);
  free(pszName);
  return EXIT_SUCCESS;
}
```

만약 여기서 스택프레임을 그려본다면 `GetName`을 Pop하고 동적할 당한 메모리는 `main`이 받습니다. 스택 프레임을 봤을 때 나중에 `main`에서 해제한다는 사실이 중요합니다.

스코프가 닫히면 그림에서 지웁니다.

함수의 몸체는 스코프로 만들어집니다. 이름이 중복될 경우 식별자를 검색하는 순서는 가장 최근에 형성된 스코프가 우선하는 것인데, 이를 스택 프레임으로 설명하면 훨씬 더 정확하게 말할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  scanf("%d", &nInput);

  if (nInput > 10) {
    int nInput = 0;
    printf("%d\n", nInput);

    if (nInput < 20) {

      int nInput = 0;
      printf("%d\n", nInput);
    }
  }

  printf("%d\n", nInput);
  return EXIT_SUCCESS;
}
```

스택에서 식별자를 검색할 때는 스택의 맨 위에서 아래쪽으로 검색합니다. 그리고 최대 함수 몸체 스코프까지 검색합니다. 그래도 못 찾으면 전역 변수를 확인합니다.

스택으로부터 꺼내어 진다(Pop)는 것은 변수가 사라진다는 의미입니다.

정적변수, 전역변수는 별도로 표시합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int TestFunc(void) {
  static int nData = 10;
  ++nData;
  return nData;
}

int main(void) {
  printf("%d\n", TestFunc());
  printf("%d\n", TestFunc());
  printf("%d\n", TestFunc());

  return EXIT_SUCCESS;
}
/*11*/
/*12*/
/*13*/
```

이 경우가 정적변수가 존재하는 경우입니다. 스택이 늘고 줄고를 반복해도 데이터 영역은 아무 관련이 없습니다.

스택프레임을 잘 이해해야 재귀호출을 정확히 이해할 수 있습니다. 또 `gets`가 Buffer overrun 보안 취약점을 갖는 원리도 파악할 수 있습니다. 매우 다양한 시스템 프로그래밍 이론을 정확히 이해하는데 유용한 도구입니다. 스택프레임을 그려보고 표시하는 연습을 자주 시도해봐야 합니다.

### 재귀호출

재귀호출은 함수가 내부에서 다시 자기 자신을 호출하는 것입니다. 우선 그게 가능한 것인가에 대한 의문이 들 수 있습니다. 하지만 안 될 이유도 없습니다.

반복문과 스택 자료구조를 합친 것이 바로 재귀호출입니다. 논리적인 코드의 구조는 반복문과 같으나 반복 과정에서 선형 자료구조인 스택이 필요한 경우 재귀호출을 사용하는 것도 전략입니다.

다음은 팩토리얼 함수를 반복문을 활용해 계산하는 코드입니다. 어려울 것이 없습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int i = 0, nFcat = 1;
  for (i = 5; i >= 1; --i) {
    nFcat *= i;
  }
  printf("5! == %d\n", nFcat);

  return EXIT_SUCCESS;
}
/*5! == 120*/
```

```c
#include <stdio.h>
#include <stdlib.h>

int factorial(int nParam) {

  int nResutl = 0;
  if (nParam == 1)
    return 1;

  nResutl = nParam * factorial(nParam - 1);
  return nResutl;
}
int main(void) {

  printf("5! == %d\n", factorial(5));
  return EXIT_SUCCESS;
}
/*5! == 120*/
```

반복문에서 조건을 만족하지 못하면 반복이 멈추지만 재귀호출에서는 조건에 부합할 때 함수가 반환하는 방법으로 멈춥니다.

재귀호출이 어려운 이유는 같은 이름을 가진 nParam이 계속 등장하는데다 자신이 자신을 호출하는 상식적이지 않은 사황이 반복되기 때문입니다. 기술적으로는 아무런 문제가 없다는 사실을 확인할 수 있습니다. 재귀호출도 그냥 함수호출입니다. 다만, 그 대상이 자기 자신일 뿐입니다.

#### 재귀호출을 이용한 문자열 출력

재귀호출을 사용하는 가장 흔한 경우는 비선형 자료구조를 다룰 때입니다. 비선형 자료구조에는 대표적으로 트리가 있습니다.

다음 예제는 문자열을 한 문자씩 재귀호출로 반복하여 출력하는 프로그램입니다.

```c
#include <stdio.h>
#include <stdlib.h>

void putData(char *str) {
  if (*str == '\0')
    return;
  putchar(*str);
  putData(str + 1);
}
int main(void) {
  putData("TestData");
  putchar('\n');

  return EXIT_SUCCESS;
}
/*TestData*/
```

`putchar`와 `putData`의 순서를 바꾸면 아마 반대로 출력되었을 것입니다.

보통 스택은 되돌리기 기능과 같은 것을 구현하기 좋습니다.

만약의 로그를 남겨도 스택형식이 더 유리합니다. 가장 최근에서 pop할 때마다 과거를 보기 때문에 파악하기 더 쉽습니다.

#### 재귀호출의 장/단점

재귀호출을 반복문과 스택 자료구조의 조합으로 정의할 수 있습니다. 재귀호출을 풀려고 하면 반복문과 스택자료구조를 활용하면 됩니다. 하지만 굳이 사용하는 이유는 이미 존재하기 때문입니다. 라이브러리를 사용할 필요가 별로 없습니다.

재귀호출은 비용이 꽤 있습니다.

1. 스택에 자동변수나 매개변수 말고도 스택 프레임을 관리하기 위한 정보를 포함합니다.
2. 함수호출에 의해 프로그램의 흐름도 변경됩니다.
3. 매개변수를 복사하는 연산도 수행해야 합니다.

반복문보다 더 많은 연산을 수행해야 합니다. 가장 큰 단점은 기본 설정을 유지했을 때 1MB 정도에 불과한 스택 메모리를 순식간에 대량으로 소모할 가능성이 높습니다.

스택 메모리를 모두 소진하면 스택 으버플로우 에러로 프로그램은 비정상 종료합니다.

재귀호출은 신중히 사용해야 합니다. 단순한 반복문으로 해결할 수 있는 것을 모나드와 재귀함수로 풀어보겠다고 겉멋들린 짓거리는 자제하기 바랍니다.

트리를 다룰 때 재귀를 사용하는 것은 보통 효과적입니다.

### 문자/문자열 처리 함수

C 언어도 당연히 C-Runtime Libraray가 있습니다. 연습문제로 직접 구현보는 것은 필요합니다. 하지만 업무 중에는 라이브러리를 사용합시다.

표준함수는 호환성이나 안정성이 이미 오랜 시간 동안 검증된 좋은 코드입니다. 연습문제로 만든 코드는 방어적 프로그래밍의 방어체계가 부족해서 근본이 없습니다.

#### 문자 처리 함수

다음 표를 참고하기 바랍니다.

| 함수이름     | 기능                                                                    |
| ------------ | ----------------------------------------------------------------------- |
| `isalpha()`  | `A~Z`, `a~z` 범위에 있는 문자인지 검사하는 함수                         |
| `isdigit()`  | `0~9`에 범위에 있는 문자(`char`)인지 검사하는 함수                      |
| `isxdigit()` | `0~9`, `A~F`, `a~f` 범위에 있는 문자(`char`)인지 검사하는 함수          |
| `isalnum()`  | `0~9`, `A~Z`, `a~z` 범위에 있는 문자(`char`)인지 검사하는 함수          |
| `islower()`  | 영문 소문자인지 검사하는 함수                                           |
| `isupper()`  | 영문 대문자인지 검사하는 함수                                           |
| `isspace()`  | `0x09~0x0D` 혹은 `0x20`에 속하는 화이트 스페이스 문자인지 검사하는 함수 |
| `toupper()`  | 영문 대문자로 변환하는 함수                                             |
| `tolower()`  | 영문 소문자로 변환하는 함수                                             |

#### 문자열 처리 함수

`gets`, `puts`, `printf`, `scanf` 모두 문자열 처리 함수들입니다.

```c
char *strcat(char * strDestination, const char *strSource);
```

```c
char *strncat(char * strDestination, const char *strSource, size_t count);
```

- `strDestination` 문자열을 추가하여 저장할 메모리 주소
- `strSource` 추가할 문자열이 저장된 메모리 주소
- `count` 추가할 문자열 길이
- `strDestination` 인자로 주어진 주소 반환
- 첫 번째 인자로 전달된 주소에 저장된 문자열에 두 번째 인자로 전달된 문자열을 주어진 길이만큼만 추가해주는 함수

Mac은 `strncat`을 사용하고 윈도우는 `strcat_s`을 사용하도록 합니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szPath[128] = {"/Home/main/C-programming-to-start-strong/"};
  char szBuffer[128] = {0};
  printf("input path: ");

  fgets(szBuffer, sizeof(szBuffer), stdin);
  strncat(szPath, szBuffer, sizeof(char) * 128);
  puts(szPath);

  return EXIT_SUCCESS;
}
/*input path: foo.txt*/
/*/Home/main/C-programming-to-start-strong/foo.txt*/
```

정말로 파일 입출력하는 것은 아닙니다.

`strcat`은 문자열 뒤에 붙여넣기 위해 대상 메모리에 저장된 문자열의 길이를 측정(`strlen`)할 수밖에 없습니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szPath[128] = {"C:\\Program File\\"};

  strncat(szPath, "CHS\\", sizeof(char) * 128);
  strncat(szPath, "C programming", sizeof(char) * 128);
  puts(szPath);

  strncpy(szPath, "C:\\Program File\\", sizeof(char) * 128);
  strncat(szPath + strlen("C:\\Program File\\"), "CHS\\", sizeof(char) * 128);
  strncat(szPath + strlen("C:\\Program File\\chs\\"), "C programming",
          sizeof(char) * 128);
  puts(szPath);

  return EXIT_SUCCESS;
}
/*C:\Program File\CHS\C programming*/
/*C:\Program File\CHS\C programming*/
```

이 코드를 컴파일 시도하면 경고가 발생할 것입니다. 일반적인 방법으로 컴파일하면 컴파일 에러가 발생할 것입니다.

`strcat`은 문자열 뒤에 붙이는 함수인데 문자열의 길이가 늘어날수록 길이 측정하기 위해 반복해야 할 횟수가 늘어나고 그만큼 효율을 떨어뜨립니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szPath[128] = {"C:\\Program File\\"};

  strncat(szPath + 17, "CHS\\", sizeof(char) * 128);
  strncat(szPath + 17 + 8, "C programming", sizeof(char) * 128);
  puts(szPath);

  return EXIT_SUCCESS;
}
```

`strlen`을 호출을 안하는 방법은 없습니다. 프로그래머가 의식해서 숫자를 바꾸는 것은 실수할 여지가 더 많습니다.

가장 확실한 것은 대안으로 우리가 직접 새로운 `strncat` 함수를 만드는 것입니다.

두번째 매개변수로 전달된 문자열을 이어 붙인 후 맨 마지막 문자(`\0`이 아닌 문자)가 저장된 메모리의 주소를 반환합니다.

```c
#include <stdio.h>
#include <stdlib.h>

char *mystrcat(char *pszDst, char *pszSrc) {

  while (*pszDst != '\0') {
    ++pszDst;
  }

  while (*pszSrc != '\0') {
    *pszDst++ = *pszSrc++;
  }
  *++pszDst = '\0';

  return --pszDst;
}

int main(void) {
  char szPath[128] = {0};
  char *pszEnd = NULL;

  pszEnd = mystrcat(szPath, "C:\\Program File\\");
  pszEnd = mystrcat(pszEnd, "CHS\\");
  pszEnd = mystrcat(pszEnd, "C programming");

  puts(szPath);

  return EXIT_SUCCESS;
}
/*C:\Program File\CHS\C programming*/
```

복사할 사이즈를 명시 안해도 되는 것은 좋습니다.

`sprintf` 함수를 이용해 문자열 붙이기

문자열을 콘솔 화면이 아니라 '메모리'에 출력한다는 점이 다릅니다. 그 외에 문자열과 관련한 모든 내용은 `printf`와 같습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szPath[128] = {0};
  char szBuffer[128] = {0};
  printf("input path: ");
  fgets(szBuffer, sizeof(szBuffer), stdin);
  sprintf(szPath, "C:\\Program File\\%s", szBuffer);
  puts(szPath);
  return EXIT_SUCCESS;
}
```

알아두면 꽤 유용합니다. 하지만 `sprintf`도 보안 결함이 있습니다. 그래서 `snprintf`를 사용하는 것이 좋습니다.

`strpbrk` 함수를 이용해 구문분석

`strpbrk` 함수는 대상 문자열에 특정 문자열이 아닌 '문자들' 중 하나가 있는지 검색합니다. 그리고 한 글자라도 일치하면 주소를 반환합니다.

```c
char * strpbrk(const char * string, const char * strCharSet);
```

- `string` 검색할 대상 문자열이 저장된 주소
- `strCharSet` 검색할 문자 집합
- 찾으면 메모리 주소 반환 못찾으면 `NULL` 반환

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szBuffer[128] = {0};
  char szSet[128] = {0};
  char *pszStart = szBuffer;

  printf("Input string: ");
  fgets(szBuffer, sizeof(szBuffer), stdin);

  printf("Input character set: ");
  fgets(szSet, sizeof(szSet), stdin);

  while ((pszStart = strpbrk(pszStart, szSet)) != NULL) {
    printf("[%p], index: %ld, %c \n", (void *)pszStart, pszStart - szBuffer,
           *pszStart);
    pszStart++;
  }

  return EXIT_SUCCESS;
}
/*Input string: Test string data*/
/*Input character set: sa*/
/*[0x16bc2b052], index: 2, s*/
/*[0x16bc2b055], index: 5, s*/
/*[0x16bc2b05d], index: 13, a*/
/*[0x16bc2b05f], index: 15, a*/
/*[0x16bc2b060], index: 16,*/
```

글자가 1개라도 찾으면 바로 메모리 주소르 반환합니다. 못찾으면 `NULL`을 반환하기 때문에 끝납니다.

마지막에 주소를 가산해야 다음 이어서 검색할 수 있습니다.

주로 구문분석에 유용한 함수입니다.

`strtok` 함수를 이용한 구문분석

다른 구문 분석 함수입니다. 하지만 골치하픈 점들이 있습니다.

```c
char * strtok(char * strToken, const char * strDelimit);
```

- `strToken` 토큰화 할 문자열이 저장된 메모리 주소
- `strDelimit` 토큰의 기준이 되는 구분자 문자집합
- 두번째 인자로 전달된 문자집합 중 하나라도 찾으면 해당 문자가 저장된 메모리의 내용을 `NULL`로 바꾸고 문자열의 시작주소 반환
- 임의의 문자열을 구분자를 근거로 토큰화 하는 함수.
  - 이 함수는 내부적으로 정적변수를 사용하므로 주의해야함

다음은 소스코드를 토큰화하는 것을 흉내낸 코드입니다. 실제로 이렇게 하면 곤란합니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char szBuffer[128] = {"nData = x + y;\nnResult = a * b;"};
  char *szSep = " *-+=%;\n";
  char *pszToken = NULL;

  pszToken = strtok(szBuffer, szSep);
  while (pszToken != NULL) {
    puts(pszToken);
    pszToken = strtok(NULL, szSep);
  }

  printf("\nszBuffer: %s\n", szBuffer);
  return EXIT_SUCCESS;
}
/*nData*/
/*x*/
/*y*/
/*nResult*/
/*a*/
/*b*/

/*szBuffer: nData*/
```

멀티쓰레드가 기본인 현재 환경에 안 맞는 점이 많이 있습니다. 검색대상에 쓰기 시도를 하는 것이 문제가 됩니다. 또 내부적으로 정적변수를 사용한다는 것도 문제입니다.

메모리에 쓰기가 가능해야 하고 반환 후 대상 메모리 내용이 수정된다는 점을 감안해야 합니다. 또 보안결함도 있습니다.

그래서 `strtok`도 자제하고 `strpbrk`를 그나마 차선으로 사용하도록 합니다.

#### 유니코드 문자열

C 언어의 문자열은 2 종류로 구별할 수 있습니다. 첫번째는 MBCS(Multi-bytes Character Sets) 문자열입니다. 두번째는 유니코드 문자열입니다.

자금까지 다룬 문자열은 MBCS 문자열입니다. 영문 한 글자는 1바이트입니다. 한글 한 글자는 2바이트입니다.

영문, 한글, 한자 표현의 차이는 프로그램의 문자열 길이에도 영향을 줍니다.

`String`은 문자가 6개이지만 저장하기 위해 7바이트가 필요합니다. 한글의 경우 `문자열`을 저장하는데 문자 개수는 3개입니다. 하지만 길이가 6이라는 애매한 부분이 있습니다. 문자열의 문자 개수와 길이가 서로 다르다는 문제가 발생합니다.

나중에 인코딩 규칙 때문에 문제가 있을 수 있습니다. 이런 문제를 극복하기 위해 유니코드가 있습니다. 유니코드는 문자 1개당 16비트 혹은 32비트입니다.

윈도우는 16비트이고 유니코드 타입은 `wchar_t`으로 2바이트입니다.

유니코드는 상수 타입으로 표기할 때 문자열 앞에 `L`을 붙여 `L"String"`으로 표기합니다. 영문, 한글 상관 없이 필요한 메모리의 크기가 `(문자열의 길이 + 1) * sizeof(wchar_t)`으로 통일됩니다.

유니코드 문자열을 MBCS 문자열로 처리 함수로 출력하면 첫 글자만 출력하는 현상이 발생할 수밖에 없습니다. `printf(L"Hello");`이라고 출력하면 화면에 `H`만 나옵니다.

> `wprinf()`, `wcscpy()` 함수

유니코드 문자열은 유니코드 문자열 전용 함수를 사용해야 합니다.

대포적으로 `printf` 대신에 `wprintf`로 출력해야 합니다. `strcpy` 대신에 `wcscpy` 함수를 사용해 복사해야 합니다. 모든 문자열 처리함수는 MBCS 버전과 유니코드 버전이 같이 존재합니다.

물론 MBCS 버전에 보안 결함이 있으면 유니코드 버전에도 보안 결함이 있습니다.

```c
#include <stdlib.h>
#include <wchar.h>

int main(void) {
  wchar_t *pwszData = L"String\n";
  wchar_t wszData[32];

  wcscpy(wszData, pwszData);
  wprintf(L"%s\n", wszData);

  return EXIT_SUCCESS;
}
/*S*/
```

이렇게 출력하는 문제가 있습니다.

```c
#include <stdlib.h>
#include <wchar.h>

int main(void) {
  wchar_t *pwszData = L"String\n";
  wchar_t wszData[32];

  wcscpy(wszData, pwszData);
  wprintf(wszData);

  return EXIT_SUCCESS;
}
/*String*/
```

이렇게 하면 잘 출력합니다.

영문은 한글자에 대해 모두 뒤에 0을 붙입니다. 메모리상 2바이트를 확보하고 남는 공간은 0으로 패딩한 것입니다. 유니코드 문자열은 MBCS 함수로 다루는 실수를 하지 말도록 조심해야 합니다.

```c
size_t wcstombs(char *mbstr, const wchar_t *wcstr, size_t count);
```

```c
size_t mbstowcs(wchar_t *wcstr, const char *mbstr, size_t count);
```

`wcstombs`은 유니코드 문자열을 MBCS 문자열로 변환할 수 있고 `mbstowcs`은 MBCS 문자열을 유니코드로 바꿀 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>

int main(void) {
  wchar_t *pwszData = L"String";
  char szData[32];
  size_t nConverted = 0;

  nConverted = wcstombs(NULL, pwszData, 32);
  printf("%ld\n", nConverted);

  nConverted = wcstombs(szData, pwszData, 32);
  printf("%s (%ld)\n", szData, nConverted);

  return EXIT_SUCCESS;
}
/*6*/
/*String (6)*/
```

사용할 일이 자주 발생하는 함수이기도 합니다. 적어도 이런 함수가 있다는 사실을 자주 기억하게 될 것입니다.

### 유틸리티 함수

시스템 시간, 난수 생성처럼 사용빈도가 높은 함수도 필요합니다.

물론 매번 유틸함수를 사용해보기 전에 어떻게 동작할것인지 정확하게 동작원리를 파악해야 합니다.

#### `atoi( )`, `atol( )`, `atof( )`

아스키문자를 원하는 숫자타입으로 변환하는 함수입니다. 공통적으로 모두 실패하면 `0`을 반환합니다.

```c
int atoi(const char *string);
```

`int`로 변환

```c
int atol(const char *string);
```

`long`으로 변환

```c
int atof(const char *string);
```

`double`로 변환

마자찬가지로 유니코드의 경우 유니코드 전용 버전의 함수를 사용하기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szBuffer[32];
  int nResult = 0;

  printf("Input string: ");
  fgets(szBuffer, 32, stdin);

  nResult = atoi(szBuffer);
  printf("%d\n", nResult);
  return EXIT_SUCCESS;
}
/*Input string: 42*/
/*42*/
```

지금은 정상적인 숫자 범위 안에 있습니다. 이번에는 범위를 벗어나보겠습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  printf("%d\n", atoi("2147483647"));
  printf("%d\n", atoi("2147483648"));
  printf("%e\n", atof("1.7e+308"));
  printf("%e\n", atof("1.7e+309"));

  return EXIT_SUCCESS;
}
/*2147483647*/
/*-2147483648*/
/*1.700000e+308*/
/*inf*/
```

책에서 보여주는 예제랑 다른 결과를 출력합니다. 이것은 CPU 아키텍쳐별로 다른 것으로 보입니다. 오버플로우 현상이 타입별로 특이하게 발생하고 있습니다. `int` 타입은 가장 작은 수로 넘어갔습니다. 하지만 `double`은 무한대가 되었습니다.

보통 이런 버그가 발생하면 찾아내기 어렵습니다. 비정상적인 종료도 아니고 그냥 계속 실행하고 있을 것이기 때문입니다.

#### `time( )`, `localtime( )`, `ctime( )`

컴퓨터에서 시간을 표시할 때는 UTC를 기준으로 표시합니다.

과학분야에서는 UTC와 GMT 차이를 아는 것이 상당히 중요합니다. 지구의 보는 곳이 물리적으로 24시간이 아닙니다.

C 언어 표준 라이브러리 함수 `time`은 1970년 1월 1일 자정부터 현재까지 흘러간 시간을 초단위로 계산해주는 함수입니다. 하지만 현재의 정확한 의미는 컴퓨터의 설정에 달려있습니다. 실제 시간과 관련이 없기 때문에 착오없기 바랍니다. 보통 반환 값을 활용하고자 하기 때문에 NULL을 대입하는 경우가 일반적입니다. 필요하면 포인터를 넣어도 됩니다.

문제가 되는 부분은 사람이 읽을 수 있는 시간이 되어야 합니다. 별도의 함수를 또 사용해야 합니다. 직접 구현은 연습으로 하고 업무 중에는 `localtime`, `ctime`을 사용하기 바랍니다. 물론 보안 문제가 있어서 보안 문제가 없는 버전을 사용하기 바랍니다.

이 시간 관련 함수도 유니코드 전용 버전이 따로 존재합니다. 맞게 사용하기 바랍니다.

```c
time_t time(time_t *timer);
```

```c
struct tm *localtime(const time_t *timer);
```

```c
char *ctime(const time_t *timer);
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {
  struct tm *ptime = {0};
  time_t t = 0;

  t = time(NULL);
  ptime = localtime(&t);

  printf("%ld\n", t);
  printf("%s", ctime(&t));

  printf("%04d-%02d-%02d\n", ptime->tm_year + 1900, ptime->tm_mon + 1,
         ptime->tm_mday);

  return EXIT_SUCCESS;
}
/*1714919364*/
/*Sun May  5 23:29:24 2024*/
/*2024-05-05*/
```

참고로 연도는 1900을 따로 더해줘야 합니다. 천단위를 정확히 표시하기 위해서는 1900년을 기준으로 합니다. 개발이 1970년이라 그렇습니다.

또 조심해야 할 부분은 달표시십니다. 자바가 C 언어의 후손이고 업혀가려던 자바스크립트 사생아도 이 영향을 받은 것 같습니다. 달을 0부터 취급한다는 점입니다. 물론 서양은 달이 문자열이라 0부터 시작하는 것이 합리적일 수 있습니다. 아시아 문화권이 달을 숫자로 표시가 때문에 이것을 이상하게 보는 부분도 있습니다.

#### `srand( )`, `rand( )`

`rand` 함수는 임의의 숫자 `0 ~ 0x7FFF` 범위로 난수를 생성합니다. 10진수로 32767입니다. 난수 최대는 보통 `RAND_MAX` 상수를 대신 사용합니다.

`srand` 함수를 호출하지 않으면 시작할 때마다 매번 같은 순서의 난수가 발생할 것입니다.

```c
void srand(unsigned int seed);
```

```c
int rand(void);
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {
  int i = 0;
  srand((unsigned)time(NULL));

  for (i = 0; i < 10; ++i) {
    printf("%6d\n", rand());
  }

  for (i = 0; i < 10; ++i) {
    printf("%6d\n", rand() % 10);
  }

  return EXIT_SUCCESS;
}
/*1979198219*/
/*2010258350*/
/*51870199*/
/*2051557558*/
/*530441074*/
/*918512021*/
/*1319082311*/
/*1342712996*/
/*1219161096*/
/*1299064445*/
/*3*/
/*4*/
/*9*/
/*7*/
/*5*/
/*9*/
/*4*/
/*8*/
/*9*/
/*9*/
```

#### `system( )`, `exit( )`

`system`은 컨맨드라인을 코드로 작성할 수 있게 해줍니다. 유니코드 버전은 `_wsystem`입니다.

`exit`은 프로그램을 즉시 종료하게 해줍니다. `main` 함수의 반환 시점과 무관하게 종료하게 만들 수 있습니다.

```c
int system(const char *command);
```

- `command` 커맨드라인에 실행할 명령을 문자열
- 성공하면 `0`을 반환하고 에러가 발생하면 `-1`을 반환

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char szCommand[512] = {0};
  printf("Input command: ");

  fgets(szCommand, 512, stdin);
  system(szCommand);

  return EXIT_SUCCESS;
}
/*Input command: pwd*/
```

```c
void exit(int status);
```

- `status`은 응용 프로그램의 종료 상태 값을 넣습니다.
- 반환 없습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  char ch;
  printf("Do you want to Exit? (Y/N)\n");
  ch = getchar();

  if (ch == 'y' || ch == 'Y') {

    puts("Exit");
    exit(1);
  }

  puts("End of main()");
  return EXIT_SUCCESS;
}
/*Do you want to Exit? (Y/N)*/
/*y*/
/*Exit*/
```

1. 매개변수로 검색 대상 문자열이 저장된 메모리의 주소와 그 대상 문자에서 찾고 싶은 문자열이 저장된 메모리의 주소를 받아 검색에 성공하면 대상 메모리에서 찾고자 하는 문자열이 저장된 위치의 인덱스를 반환하는 함수를 작성하세요. 기능적으로는 `strstr` 함수와 같지만 반환 자료형은 `char *`가 아니라 대상 메모리에 대한 인덱스를 정수타입으로 반환해야 합니다. 만일 찾는 문자열이 없다면 `-1`을 반환하는 함수로 정의합니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int findCahr(char *str, char *charSet) {
  int result = 0;
  result = strstr(str, charSet) - str;
  if (result < 0) {
    return -1;
  }

  return result;
}

int main(void) {
  char szBuffer[128] = {0};
  char szSet[128] = {0};

  printf("Input string: ");
  fgets(szBuffer, sizeof(szBuffer), stdin);

  printf("Input character set: ");
  fgets(szSet, sizeof(szSet), stdin);

  printf("%d\n", findCahr(szBuffer, szSet));
  return EXIT_SUCCESS;
}
```

2. 매개변수로 `char *`의 배열이름과 요소의 개수를 인자로 받아 오름차순으로 문자열을 정리하는 `SortString` 함수를 작성하세요, 다음 `main` 함수의 코드에 대한 출력 예를 참고하고 작성합니다.

```c
#include <stdio.h>
#include <stdlib.h>

void SortString(char *aList[], int idx) {
  // 유니코드 문자열 처리
}

int main(void) {
  char *aList[5] = {
      "정형돈", "노홍철", "하하", "유재석", "박명수",
  };
  int i = 0;
  SortString(aList, 5);

  for (i = 0; i < 5; ++i) {
    puts(aList[i]);
  }

  return EXIT_SUCCESS;
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 비교 함수
int CompareStrings(const void *a, const void *b) {
  // 두 문자열을 가나다 순서로 비교
  return strcmp(*(const char **)a, *(const char **)b);
}

void SortString(char *aList[], int idx) {
  // qsort 함수를 사용하여 문자열 배열을 정렬
  qsort(aList, idx, sizeof(char *), CompareStrings);
}

int main(void) {
  char *aList[5] = {
      "정형돈", "노홍철", "하하", "유재석", "박명수",
  };
  int i = 0;
  SortString(aList, 5);

  for (i = 0; i < 5; ++i) {
    puts(aList[i]);
  }

  return EXIT_SUCCESS;
}
/*노홍철*/
/*박명수*/
/*유재석*/
/*정형돈*/
/*하하*/
```

그냥 질문해서 해결했습니다. `qsort` 함수라는 것이 존재하는 것도 신기합니다. 유니코드 문자열인데 받아서 잘 비교합니다.

3. `int` 타입 5행 4열 배열에서 각 원소의 총합을 계산하고 반환하는 `GetTotal` 함수를 작성하세요.

```c
#include <stdio.h>
#include <stdlib.h>

int GetTotal(int arr[][4], int row, int col) {
  int result = 0, i = 0, j = 0;
  for (i = 0; i < row; ++i) {
    for (j = 0; j < col; ++j) {
      result += arr[i][j];
    }
  }

  return result;
}

int main(void) {
  int arr[5][4] = {
      {1, 2, 3, 4},     {5, 6, 7, 8},     {9, 10, 11, 12},
      {13, 14, 15, 16}, {17, 18, 19, 20},
  };

  printf("%d\n", GetTotal(arr, 5, 4));

  return EXIT_SUCCESS;
}
/*210*/
```

의도는 이차원 배열을 처리하는 방법을 질문 한 것입니다. 행과 열이 구체적인데 상황에 따라 매개변수만으로 유연하게 바뀌게 만들고자 했던 것이 의도 같습니다.

이차원 배열은 포인터와 힙메모리 활용으로 구현하기 바란 것 같지만 나중에 하겠습니다.

4. 매개변수 `char *` 두 개를 답아 각 포인터가 가리키는 대상 문자열이 같은 문자열인지 비교하는 함수를 작성합니다. 만일 같으면 `0`을 반환하고 그렇지 않으면 1을 반환합니다. 기본적인 기능은 `strcmp` 함수와 같습니다. 단, 영문 대소문자를 구별하지 않고 비교합니다. 따라서 `h`, `H`는 같다고 인식해야 합니다.

```c
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int cmp(char *str1, char *str2, int size) {
  for (int i = 0; i < size; ++i) {
    char c1 = tolower(str1[i]);
    char c2 = tolower(str2[i]);
    if (c1 != c2) {
      return 1; // 문자열이 다르면 1 반환
    }
    if (c1 == '\0' && c2 == '\0') {
			return 0; // 둘 다 NULL 문자를 만나면 0 반환
    }
  }
  return 0; // 끝까지 순회했는데 문자열이 같으면 0 반환
}

int main(void) {
  char szBuffer[128] = {0};
  char szSet[128] = {0};

  printf("Input string: ");
  fgets(szBuffer, sizeof(szBuffer), stdin);

  printf("Input character set: ");
  fgets(szSet, sizeof(szSet), stdin);

  // 불필요한 개행 문자 제거
  szBuffer[strcspn(szBuffer, "\n")] = '\0';
  szSet[strcspn(szSet, "\n")] = '\0';

  printf("%d\n", cmp(szBuffer, szSet, 128));

  return EXIT_SUCCESS;
}
```

5. 난수를 구하는 함수를 사용하여 가위바위보 게임을 구현합니다. 0 ~ 2 범위 숫자를 발생시켜서 0은 가위, 1은 바위, 2는 보라고 가정합니다. 게임 방식은 사용자로부터 0 ~ 2 범위의 정수를 입력받은 후, 이에 대응하는 0 ~ 2 범위의 난수를 발생시켜 사용자가 입력한 정보와 비교하는 방식으로 게임을 진행합니다. 반드시 사용자, 컴퓨터가 선정한 것이 무엇이며 누가 승자인지 표시해야 합니다.

```c

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 컴퓨터가 선택한 값을 반환하는 함수
int computerChoice() {
    // 난수 초기화
    srand(time(NULL));
    // 0부터 2까지의 난수 발생
    return rand() % 3;
}

int main() {
    int user, computer;

    // 사용자 입력 받기
    printf("가위(0), 바위(1), 보(2) 중 하나를 선택하세요: ");
    scanf("%d", &user);

    // 사용자 입력 유효성 검사
    if (user < 0 || user > 2) {
        printf("잘못된 입력입니다.\n");
        return EXIT_FAILURE;
    }

    // 컴퓨터 선택
    computer = computerChoice();

    // 결과 출력
    printf("사용자: ");
    switch(user) {
        case 0:
            printf("가위");
            break;
        case 1:
            printf("바위");
            break;
        case 2:
            printf("보");
            break;
    }
    printf(", 컴퓨터: ");
    switch(computer) {
        case 0:
            printf("가위");
            break;
        case 1:
            printf("바위");
            break;
        case 2:
            printf("보");
            break;
    }
    printf("\n");

    // 승패 결정
    if (user == computer) {
        printf("무승부!\n");
    } else if ((user == 0 && computer == 2) ||
               (user == 1 && computer == 0) ||
               (user == 2 && computer == 1)) {
        printf("사용자 승!\n");
    } else {
        printf("컴퓨터 승!\n");
    }

    return EXIT_SUCCESS;
}
```

6. 오늘 기준으로 10일 후와 100일 후의 날짜를 계산하여 출력하는 프로그램을 작성하세요.

```c
#include <stdio.h>
#include <time.h>

int main() {
    // 현재 시간 구하기
    time_t now;
    struct tm *current;
    time(&now);
    current = localtime(&now);

    // 10일 후 계산
    current->tm_mday += 10;
    mktime(current);
    printf("10일 후의 날짜: %d년 %d월 %d일\n", current->tm_year + 1900, current->tm_mon + 1, current->tm_mday);

    // 100일 후 계산
    current->tm_mday += 90; // 100일 후는 10일 후에 90일을 더한 것과 같음
    mktime(current);
    printf("100일 후의 날짜: %d년 %d월 %d일\n", current->tm_year + 1900, current->tm_mon + 1, current->tm_mday);

    return 0;
}
```

## 구조체와 공용체

만일 `int` 타입이나 `char` 타입 같은 기본 자료형이 그릇이라면 구조체는 식판입니다. 이 식판이라는 것이 "서로 다른 다양��� 그릇들이 모여 새로운 그릇을 형성한 것"이라 할 수 있기 때문입니다. 마찬가지로 구조체는 다양한 기본 자료형을 가진 요소들을 모아 새로운 타입으로 만든 것입니다.

구조체는 각 요소를 멤버라고 부릅니다. 공용체도 구조체처럼 멤버들이 모여 하나를 이룹니다. 그런데 구조체와 달리 한 자료에 대해 해석방법만 여러 가지를 부여한 것입니다.

흔하게 멤버는 5개를 달아둡니다.

```c
#include <stdio.h>

struct 식판{
  int 반찬[3];
  char 국[32];
  char 밥[32];
};

int main(void){
  struct 군용식판 철수꺼;
  return 0;
}
```

구조체를 선언하면 새로운 타입이 만들어집니다. 공용체, 구조체는 사용자 정의 타입입니다.

새로운 자료형이라고 할만 한게 구조체에 대한 변수를 선언 및 정의할 수 있기 때문입니다. 절대로 구조체의 선언과 인스턴스 정의를 혼동하면 안됩니다. 변수, 함수를 정의한 것과 호출한 것의 차이를 모르는 것과 같습니다. 구조체 선언은 선언입니다. 자료구조의 설계에 불과합니다.

구조체는 넓은 의미에서 자료구조입니다.

묶은 한 덩어리를 레코드라 하고 레코드 내부를 구성하는 요소들을 필드라고 합니다. 레코드를 모아 레코드 단위의 정보를 관리할 수 있는 시스템을 데이터 베이스라고 합니다.

이 중에 레코드를 코드로 기술하는 것이 가장 적절한 것이 구조체입니다. 학생에 대한 정보를 담는다면 이름, 주소, 학점 같은 정보를 필드가 구조체의 멤버가 됩니다.

### 구조체 선언 및 정의

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct USERDATA {
  int nAge;
  char szName[32];
  char szPhone[32];
};

int main(void) {
  struct USERDATA user = {0, "", ""};
  user.nAge = 10;
  strcpy(user.szName, "Hoon");
  strcpy(user.szPhone, "010-1234-5678");

  printf("%d살, %s, %s\n", user.nAge, user.szName, user.szPhone);

  return EXIT_SUCCESS;
}
/*10살, Hoon, 010-1234-5678*/
```

struct는 예약어이고 생략도 가능합니다.

구조체 정의는 형 재선언이 합쳐진 경우에 해당합니다.

구조체가 자료형이 되기 때문에 구조체 변수를 배열로 선언도 가능합니다. 대표적으로 SLL에 이용합니다. 이렇게 사용하는 이유는 배열이 연속되지 않고 존재할 수 있게 만들기 위해서입니다.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct USERDATA {
  int nAge;
  char szName[32];
  char szPhone[32];
} USERDATA;

int main(void) {

  USERDATA userdata[4] = {
      {10, "foo", "1234"},
      {11, "bar", "2345"},
      {17, "baz", "3456"},
      {12, "qux", "4567"},
  };
  int i = 0;

  for (i = 0; i < 4; ++i) {
    printf("%d살\t%s\t%s\n", userdata[i].nAge, userdata[i].szName,
           userdata[i].szPhone);
  }

  return EXIT_SUCCESS;
}
/*10살	foo	1234*/
/*11살	bar	2345*/
/*17살	baz	3456*/
/*12살	qux	4567*/
```

### 구조체 동적 할당

구조체는 사용자가 그 구조를 설계한 자료형입니다. 따라서 메모리를 해석하는 방법이라고 봐야 합니다. 구조체는 자동변수, 전역변수, 힙할당도 가능합니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct USERDATA {
  int nAge;
  char szName[32];
  char szPhone[32];
} USERDATA;

int main(void) {
  USERDATA *pUser = NULL;
  pUser = (USERDATA *)malloc(sizeof(USERDATA));

  pUser->nAge = 10;
  strcpy(pUser->szName, "Hoon");
  strcpy(pUser->szPhone, "9876");

  printf("%d살\t%s\t%s\n", pUser->nAge, pUser->szName, pUser->szPhone);
  free(pUser);

  return EXIT_SUCCESS;
}
/*10살	Hoon	9876*/
```

`sizeof` 연산자로 리팩토링하면서 바뀔 수 있는 구조체 크기를 구독하기 바랍니다.

참고로 `pUser->szName`은 `(*pUser).szName`으로 표기할 수 있습니다. 간접지정 연산자 보다 구조체 멤버 접근연산자가 더 우선이기는 합니다.

### 반환자료, 매개변수 구조체

구조체도 함수의 반환 자료형이나 매개변수가 될 수 있습니다. 구조체 변수는 배열의 이름(주소상수)와 달리 l-value가 될 수 있습니다. 함수가 구조체를 반환하면 이를 r-value로 사용해 대입연산을 수행할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct USERDATA {
  int nAge;
  char szName[32];
  char szPhone[32];
} USERDATA;

USERDATA GetUser(void) {
  USERDATA user = {0};

  scanf("%d%*c", &user.nAge);
  fgets(user.szName, sizeof(user.szName), stdin);
  fgets(user.szPhone, sizeof(user.szPhone), stdin);

  return user;
}

int main(void) {
  USERDATA user = GetUser();

  printf("%d살\t%s\t%s\n", user.nAge, user.szName, user.szPhone);
  return EXIT_SUCCESS;
}
```

개행 문자도 저장되는 문제가 있습니다.

구조체 변수를 매개변수나 반환 자료타입으로 사용하는 것은 비효율적입니다. 복사해야 할 정보 양이 기본 타입보다 크기 때문입니다. 구조체가 매개변수나 반환타입이 될 때는 주소로 주고 받는 것이 좋습니다. 다음 예시를 보기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct USERDATA {
  int nAge;
  char szName[32];
  char szPhone[32];
} USERDATA;

void GetUser(USERDATA *user) {
  scanf("%d%*c", &user->nAge);
  fgets(user->szName, sizeof(user->szName), stdin);
  fgets(user->szPhone, sizeof(user->szPhone), stdin);
}

int main(void) {
  USERDATA user = {0};
  GetUser(&user);
  printf("%d살\t%s\t%s\n", user.nAge, user.szName, user.szPhone);
  return EXIT_SUCCESS;
}
```

개행문자 저장 문제는 여전히 있습니다.

구조체 함수의 인자로 전달하면 주소를 전달합니다. 스택메모리 사용양이 작습니다. 구조체는 선언할 때마다 사이즈가 달라질 수 있습니다. 하지만 주소는 사이즈가 고정입니다. 호출 과정에서 메모리를 복사하는 연산을 수행할 때 효율이 좋습니다.

### 구조체를 멤버로 가지는 구조체

구조체 속에 구조를 가질 수 있게 선언할 수 있습니다. 자주 사용하는 문법입니다. 구조체 연산을 접근을 여러번 수행해야 할 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct MYBODY {
  int nHeight;
  int nWeight;
} MYBODY;

typedef struct USERDATA {
  char szName[32];
  char szPhone[32];
  MYBODY body;
} USERDATA;

int main(void) {
  USERDATA user = {"Hoon", "1234", {175, 70}};
  printf("%s\t%s\t%d\t%d\n", user.szName, user.szPhone, user.body.nHeight,
         user.body.nWeight);
  return EXIT_SUCCESS;
}
/*Hoon	1234	175	70*/
```

자기참조도 가능합니다. 구조체 멤버로 구조체에 대한 포인터 변수도 선언도 가능합니다. 즉 자기참조라고 합니다. 링크드 리스트에 대표적으로 많이 사용합니다. 링크드 리스트는 값과 다음 원소 주소를 가리키게 만들수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct USERDATA {
  char szName[32];
  char szPhone[32];
  struct USERDATA *pNext;
} USERDATA;

int main(void) {
  USERDATA user = {"foo", "1234", NULL};
  USERDATA newUser = {"bar", "2345", NULL};

  user.pNext = &newUser;

  printf("%s\t%s\n", user.szName, user.szPhone);
  printf("%s\t%s\n", user.pNext->szName, user.pNext->szPhone);

  return EXIT_SUCCESS;
}
/*foo	1234*/
/*bar	2345*/
```

단일 연결리스트를 만들었습니다. 심지어 화살표연산자로 다음을 접근하고 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct USERDATA {
  char szName[32];
  char szPhone[32];
  struct USERDATA *pNext;
} USERDATA;

int main(void) {
  USERDATA userList[4] = {
      {"foo", "1234", NULL},
      {"bar", "2345", NULL},
      {"baz", "3456", NULL},
      {"qux", "4567", NULL},
  };
  USERDATA *pUser = NULL;

  userList[0].pNext = &userList[1];
  userList[1].pNext = &userList[2];
  userList[2].pNext = &userList[3];
  userList[3].pNext = NULL;

  pUser = &userList[0];
  while (pUser != NULL) {
    printf("%s\t%s\n", pUser->szName, pUser->szPhone);
    pUser = pUser->pNext;
  }

  return EXIT_SUCCESS;
}
/*foo	1234*/
/*bar	2345*/
/*baz	3456*/
/*qux	4567*/
```

연결을 만드는 과정이 불편하지만 지금은 링크드 리스트를 순회하는 것을 보여줍니다.

### 구조체 멤버 맞춤

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct USERDATA {
  char ch;
  int nAge;
} USERDATA;

typedef struct MYDATA {
  char ch;
  int nAge;
  double dData;
} MYDATA;

int main(void) {
  printf("%ld\n", sizeof(USERDATA));
  printf("%ld\n", sizeof(MYDATA));

  return EXIT_SUCCESS;
}
```

결과를 예상해보세요.

`8`, `16`입니다.

`char`는 `1`이고 `int`는 `4`입니다. 또 `double`은 `8`입니다. 그렇게 되면 `5`, `13`을 예상하지만 아닙니다. 구조체는 8바이트 단위로 확보할 공간을 늘립니다.

`#pragma pack` 전처리기를 사용해서 제어는 가능합니다. 하지만 어지간히 공간복잡성이 크리티컬하지 않는 이상 권장하지 않습니다.

```c
#include <stdio.h>
#include <stdlib.h>

#pragma pack(push, 1)
typedef struct USERDATA {
  char ch;
  int nAge;
} USERDATA;

typedef struct MYDATA {
  char ch;
  int nAge;
  double dData;
} MYDATA;
#pragma pack(pop)

int main(void) {
  printf("%ld\n", sizeof(USERDATA));
  printf("%ld\n", sizeof(MYDATA));

  return EXIT_SUCCESS;
}
/*5*/
/*13*/
```

이렇게 하면 구조체는 공간이 최적화됩니다. 연속된 공간을 모두활용하면서 공간복잡성 효율이 더욱더 좋아집니다.

주의할점들이 있습니다.

파일에 저장하거나 읽어오는 경우

네트워크로 전송하거나 수신하는 경우

지금 설정한 최적화 오류가 발생할 가능성이 없는지 확인해야 합니다.

### 비트필드

구조체의 멤버가 바이트 단위가 아니라 비트 단위 데이터를 다루는 멤버로 선언되는 구조체입니다.

비트 필드를 이용하지 않고 일정 비트를 잘라내려면 마스크 연산을 사용해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct DATAFLAG {
  unsigned char main : 1;
  unsigned char left : 2;
  unsigned char right : 3;
  unsigned char top : 2;
} DATAFLAG;

int main(void) {
  DATAFLAG flagSwitch = {0, 3, 7, 4};

  printf("%d\n", flagSwitch.main);
  printf("%d\n", flagSwitch.left);
  printf("%d\n", flagSwitch.right);
  printf("%d\n", flagSwitch.top);

  printf("%x\n", *((unsigned char *)&flagSwitch));
  printf("%ld\n", sizeof(flagSwitch));

  return EXIT_SUCCESS;
}
/*0*/
/*3*/
/*7*/
/*0*/
/*3e*/
/*1*/
```

컴파일 할 때는 flag를 많이 꺼야 합니다. `4`는 오버플로우가 발생해서 `0`이 되었습니��. 표현 범위�� 초과한 것입니다.

여기는 각각의 필드 단위로 비트단위로 제어해야 합니다.

장치를 직접 제어하는 소프트웨어를 개발할 때 유용하다고 합니다.

### 공용체

공용체(union)는 서로 다른 자료형 여러 개가 모여 새로운 한 덩어리를 이룬 구조체와 달리 한 가지 자료에 대해 여러가지 해석방법(타입)을 부여하는 문법입니다. 4바이트인 int를 char 4개로 short 2개로 처리할 수 있습니다.

다음은 네트워크 관련된 프로그래밍을 흉내낸 것입니다.

이런 공용체 개념은 TCP/IP 소켓 프로그래밍을 배우다보면 만나게 될 수 있습니다. 물론 용어만 같은 것입니다.

```c
#include <stdio.h>
#include <stdlib.h>

typedef union IP_ADDR {
  int nAddress;
  short awData[2];
  unsigned char addr[4];
} IP_ADDR;

int main(void) {
  IP_ADDR Data = {0};
  Data.nAddress = 0x41424344;

  printf("%c%c%c%c\n", Data.addr[0], Data.addr[1], Data.addr[2], Data.addr[3]);

  printf("%x, %d\n", Data.awData[0], Data.awData[0]);
  printf("%x, %d\n", Data.awData[1], Data.awData[1]);
  return EXIT_SUCCESS;
}
/*DCBA*/
/*4344, 17220*/
/*4142, 16706*/
```

메모리를 3가지 방법으로 해석할 수 있습니다.

내부적으로 ipV4를 다룰 때 32비트 단위로 통신하는데 공용체를 활용하면 유용할 것입니다. 8비트 4개로 끊어 처리하면 됩니다.

1. 다음 예제의 실행결과와 이유는 무엇인가?

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct USERDATA {
  char ch;
  int nAge;
} USERDATA;

typedef struct MYDATA {
  char ch;
  int nAge;
  double dData;
} MYDATA;

int main(void) {
  printf("%ld\n", sizeof(USERDATA));
  printf("%ld\n", sizeof(MYDATA));

  return EXIT_SUCCESS;
}
```

8하고 16입인다.

char는 1바이트 공간을 차지하고 int는 4바이트 공간을 차지합니다. 5바이트 공간을 사용해야 하는데 구조체는 8바이트 단위로 확장하기 때문에 가장 작은 8바이트만큼 공간을 확보합니다.

double은 8바이트 만큼 필요하고 1바이트 char와 4바이트 int 모두 13바이트 이상 필요합니다. 8바이트 단위로 공간을 확보하는데 13바이트 이상 8배수는 16이라 16바이트를 확보합니다.

이 문제는 메모리 레이아웃과 메모리 지역성 문제입니다.

2. 자기 자신에 대한 포인터를 멤버로 갖는 구조체는 무엇이라고 하는가?

자기참고 구조체라고 부릅니다. 링크드 리스트, 트리의 Node로 많이 사용합니다.

## 파일 입출력

보조기억장치는 용량 문제에 둔감합니다.

최초 크기는 0인 상태에서 정보를 써 넣으면 자동으로 크기가 증가합니다. 메모리 크기를 미리 알고 있을 필요가 거의 없습니다.

메모리이지만 사용법은 주기억장치 보조기억장치가 서로 상당히 다릅니다.

내부적인 차이를 인식할 수 있어야 파일 관리 관련 각종 함수를 더 정확히 이해할 수 있습니다.

### 파일 시스템 기본 이론

파일 시스템은 파일 단위의 정보를 생성, 삭제, 저장, 검색할 수 있도록 정보를 구성하는 방법을 말합니다. 이 정보에는 파일의 이름이나 위치 등 정보도 있습니다.

폴더라는 말은 디렉터리라는 말과 같습니다.

파일의 위치는 경로(path)라고 부릅니다. 이런 위치는 논리적 위치입니다.

디스크 볼륨 이름부터 파일명까지 전체 정보를 표시하는 것을 절대경로라고 부릅니다. 드라이브 이름은 생략하고 표시하면 상대 경로입니다. 상대 경로는 보통 현재 경로를 기준으로 합니다.

파일시스템은 여러가지가 있습니다. NTFS, FAT32 등 많이 있습니다.

택스트 파일과 바이너라 파일입니다.

파일은 크게 텍스트 파일과 바이너리 파일로 나눌 수 있습니다. 텍스트 파일은 파일에 저장된 정보가 모두 아스키 코드나 문자열로 해석할 수 있는 정보입니다.

메모장으로 열고 볼 수 있는 파일들이 해당합니다. 텍스트 파일의 가장 중요한 특징 중 하나는 `-1`이라는 정수값을 파일의 끝(EOF)라고 표현한다는 점입니다.

텍스트 파일을 제외한 모든 파일들은 바이너리 파일입니다. 바이너리 파일은 저장 되는 정보가 어떤 것인지 구별하거나 차별하지 않습니다. 큰 의미에서 텍스트 파일이라는 것도 파이너리 파일의 한 부분으로 생각할 수 있습니다.

여기까지가 기본이론입니다.

`fopen` 함수는 특정 경로에 있는 파일을 열어서 접근할 수 있도록 FILE 구조체를 반환합니다. 파일을 열기 혹은 생성에 성공하면 `NULL`이 아니면 `fclose`로 닫아줘야 합니다. `malloc`, `free`처럼 짝으로 기억하기 바랍니다. 윈도우는 `fopen`이 보안취약점이 있어서 `fopen_s`를 사용해야 합니다.

```c
FILE *fopen(const char *filename, const char *mode);
```

- `filename`은 열고자 하는 파일의 절대경로 입니다.
- `mode`는 접근 모드입니다.
  - 문자열 주소를 줘야 합니다.
  - 파일모드는 텍스트, 바이너리랑 접근 방법인 읽기, 쓰기를 표시한 문자를 조합할 수 있습니다.
- 에러면 `NULL` 반환 성공하면 구조체의 주소를 반환할 것입니다.

| 모드 | 의미                         | 존재하는 경우           | 없는 경우 |
| ---- | ---------------------------- | ----------------------- | --------- |
| r    | 텍스트 읽기(Read)            | 파일 열기               | 에러      |
| w    | 텍스트 쓰기(Write)           | 기존 내용을 지우고 열기 | 새로 만듦 |
| a    | 텍스트 추가(Append)          | 기존 내용 뒤에 추가     | 새로 만듦 |
| r+   | 텍스트 읽기 + 갱신(Read)     | 파일 열기               | 에러      |
| w+   | 텍스트 쓰기 + 갱신(Write)    | 기존 내용을 지우고 열기 | 새로 만듦 |
| a+   | 텍스트 추가 + 갱신(Append)   | 기존 내용 뒤에 추가     | 새로 만듦 |
| rb   | 바이너리 읽기(Read)          | 파일 열기               | 에러      |
| wb   | 바이너리 쓰기(Write)         | 기존 내용을 지우고 열기 | 새로 만듦 |
| ab   | 바이너리 추가(Append)        | 기존 내용 뒤에 추가     | 새로 만듦 |
| rb+  | 바이너리 읽기 + 갱신(Read)   | 파일 열기               | 에러      |
| wb+  | 바이너리 쓰기 + 갱신(Write)  | 기존 내용을 지우고 열기 | 새로 만듦 |
| ab+  | 바이너리 추가 + 갱신(Append) | 기존 내용 뒤에 추가     | 새로 만듦 |

뭐 패턴이 안 보이면 프로그래밍 접기 바랍니다.

```c
FILE fclose(FILE *stream);
```

```c
int _fcloseall(void);
```

위 함수는 모든 파일 닫습니다. 방법이 없으면 이것도 전략입니다.

다음은 예시입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  FILE *fp = NULL;

  fp = fopen("Text.txt", "w");
  if (fp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }

  fclose(fp);
  return EXIT_SUCCESS;
}
```

실행 파일을 파일을 실행하는 위치에서 생성한다는 것이 의외입니다.

파일 접근 제어입니다.

프로그램이 파일을 이미 열어 두었으면 접근이 제한될 수 있습니다. 열려 있는 동안 삭제를 UI에서 차단 하는 것도 비슷합니다. 파일에 저장된 정보를 여러 프로그램을 동시에 편집을 차단해야 합니다. 파일을 다룰 때는 접근 제어를 반드시 고려 해야 합니다.

- 파일에 접근하려면 우선 파일을 열어야 합니다. 파일에 대한 입출력을 완료한 후에는 파일을 닫아야 합니다.
- 파일을 개방할 때는 반드시 목적(입출력, 수정)을 명시해야 합니다.
- 파일이 이미 사용 중인 경우(열려있는 상태), 접근이 제한될 수 있습니다. 그러나 경우에 따라 읽기는 허용될 수 있습니다.
- 만일 파일의 속성이 읽기 전용이면 쓰기모드는 제한됩니다.
- 경우 따라 보안 문제로 읽기도 제한될 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  FILE *fp = NULL;
  int nClosed = 0;
  fopen("Test1.txt", "w");
  fopen("Test2.txt", "w");
  fopen("Test3.txt", "w");

  nClosed = _fcloseall();
  printf("%d\n", nClosed);

  return EXIT_SUCCESS;
}
```

C99 표준이 아니라서 실행하지 않겠습니다.

프로그램이 종료되면 대부분의 경우 운영체제가 대신 닫아줍니다. 하지만 개발자 스스로 처리하는 것이 바람직합니다. 모든 프로그램이 CLI나 컴파일러처럼 짧게 실행하는 것이 아닙니다. 

특별한 경우 운영체제가 파일을 안 닫습니다. 이것은 운영체제의 커널이 특정 파일을 안 놔주는 경우입니다. 비동기 파일 입출력시도할 때 발생합니다. 

### 텍스트 파일 입출력

파일 입출력 전용 함수들은 표준입출력처럼 사용하면 됩니다. 

```c
int fprintf(FILE *stream, const char *format [, argument]...);
```

- `stream`은 파일 포인터 구조체입니다.
- `format`은 형식 문자열이 저장된 메모리 주소입니다.
- 형식문자열에 대응할 가변인자가 마지막입니다.
- 출력된 바이트 수를 반환홥니다.
- 형식 문자열의 형식을 맞춰서 출력하는 함수입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  FILE *fp = NULL;
  fp = fopen("Test.txt", "w");
  if (fp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }
  fprintf(fp, "%s\n", "Test string");
  fprintf(fp, "%s\n", "Hello world!");

  fclose(fp);

  return EXIT_SUCCESS;
}
```

```txt
Test string
Hello world!
```

파일에 문자열을 이렇게 쓰기를 할 수 있습니다.

```c
int fscanf(FILE *stream, const char *format [, argument]...);
```

- 파일 구조체와 형식문자열도 동일합니다.
- 성공적으로 읽어 들인 항목의 개수를 반환합니다.
- 형식 문자열에 맞춰서 대상 파일로부터 정보를 읽습니다. 가변인자는 정보가 저장될 메모리 주소입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nData = 0;
  char szBuffer[128] = {0};
  FILE *fp = NULL;
  fp = fopen("fscanfTest.txt", "w");
  fprintf(fp, "%d,%s\n", 20, "Test");
  if (fp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }
  fclose(fp);

  fp = fopen("fscanfTest.txt", "r");
  fscanf(fp, "%d,%s\n", &nData, szBuffer);
  fclose(fp);

  printf("%d, %s\n", nData, szBuffer);
  return EXIT_SUCCESS;
}
/*20, Test*/
```

문장 전체를 읽을 때는 `fscanf`을 사용하기보단 `fgets`를 사용하는 것이 더 적절합니다. 행마다 문자를 분석하는 방식이 더 적절합니다.

```c
int fgetc(char * stream);
```

- `stream`은 파일 구조체의 주소를 받습니다.
- 정상적이면 파일에서 읽은 문자를 반환합니다. 에러가 발생하면 `EOF`을 반환합니다.
- 대상 파일에서 문자를 읽는 함수입니다.

```c
int fputc(int c, FILE * stream);
```

- `c`는 파일에 쓸 문자입니다. `stream`은 `FILE` 포인터입니다.
- 정상적이면 쓴 문자를 반환합니다. 에러가 발생하면 `EOF`을 반환합니다.
- 대상 파일에 문자를 읽어 들이는 함수입니다.

파일을 입출력으로 읽고 쓰기를 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  FILE *fp = NULL;
  char ch;

  fp = fopen("Test.txt", "w");
  if (fp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }
  fputs("Test string!", fp);
  fclose(fp);

  fp = fopen("Test.txt", "r");
  if (fp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }

  while ((ch = fgetc(fp)) != EOF) {
    putchar(ch);
  }
  fclose(fp);

  return EXIT_SUCCESS;
}
/*Test string!*/
```

```c
char *fgets(char *string, int n, FILE *stream);
```

- 이제야 설명을 봅니다.
- `string`은 읽어 들인 문자열이 저장될 버퍼의 주소입니다. `n`은 입력 버퍼의 바이트 단위 크기입니다. `streame`은 `FIEL` 구조체를 받습니다.
- 에러는 `NULL` 정상이면 문자열을 반환합니다.
- 대상의 문자열을 읽습니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  FILE *fp = NULL;
  char szBuffer[512] = {0};
  fp = fopen("Test.txt", "w");
  if (fp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }
  fputs("Test\n", fp);
  fputs("String\n", fp);
  fputs("Data\n", fp);

  fclose(fp);

  fp = fopen("Test.txt", "r");
  if (fp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }
  while (fgets(szBuffer, sizeof(szBuffer), fp)) {
    printf("%s", szBuffer);
    memset(szBuffer, 0, sizeof(szBuffer));
  }

  fclose(fp);
  return EXIT_SUCCESS;
}
/*Test*/
/*String*/
/*Data*/
```

`fgets`의 본래 활용법입니다. `szBuffer`를 넘기면 문제가 될 것입니다. 나눠서 읽는 문제가 발생합니다. 512바이트까지 인데 1024면 512, 512 두번 읽습니다. 또 마지막 요소가 `\n`이 아닌지도 확인해봐야 합니다.

```c
int fputs(const char * string, FILE *stream);
```

- `string`은 출력할 문자열이 저장된 주소입니다. `stream`은 파일입니다.
- 정상적이면 음수가 아닌 값을 반환합니다. 에러가 발생하면 `EOF`를 반환합니다.

전달된 문자열을 쓰기하는 함수입니다. `fgets`의 반대입니다. 정보를 조합해서 쓰기를 해야 한다면 `fprintf`를 사용하는 것이 적절합니다.

```c
int fflush(FILE * stream);
```

- `stream`은 대상 파일입니다.
- 성공하면 `0`을 반환하고 실패하면 `EOF`입니다. 
- 파일에 대한 입출력을 완료하고 파일 입출력과 관련된 정보를 초기화합니다. 메모리는 초기화하지 않습니다.

버퍼에 남아있는 정보를 제거하는 것과 동일합니다. 출력 플러싱을 한다고 합니다. 카운터 값을 초기화한다고 하는데 다음 예제 코드의 포인터에 주의하기 바랍니다. 구조체 멤버에 어떤 변화를 가하는지 파악하기 바랍니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  FILE *fp = stdin;
  printf("Input string: ");

  printf("getchar( ) - %c\n", getchar());

	// 버퍼에 남은 문자열 정보를 window용으로 출력
	/*printf("[%d] %s", fp ->_cnt, fp->_base);*/
	/*printf("Read: %d\n", fp ->_ptr - fp->_base);*/

	printf("\n\ngetchar( ) - %c\n", getchar());
	/*printf("[%d] %s", fp ->_cnt, fp->_base);*/
	/*printf("Read: %d\n", fp ->_ptr - fp->_base);*/

	fflush(fp);
	/*printf("\n\nAfter flushing\n[%d] %s", fp->_cnt, fp->_base);*/
	/*printf("Read: %d\n", fp ->_ptr - fp->_base);*/

  return EXIT_SUCCESS;
}
```

윈도우 환경에서만 사용할 수 있는 코드입니다. 운영체제마다 동직이 달라서 C 언어가 다른 것으로 보입니다. 파일 시스템이 충분히 다를 수 있습니다.

### 바이너리 파일 입출력

바이너리 파일은 텍스트 파일을 제외한 모든 파일입니다.  MP3를 열고 싶으면 `fopen` 함수에 접근 모드 문자열에 `b`를 반드시 앞에 붙여야 합니다.  

fread,  fwrite 함수 모두 fgets, fputs 함수와 달리 입출력 길이가 일정한 메모리  덩어리 입니다.  문자열의 경우 전체 문자열의 길이가 달라질 수 있습니다.  사용되는 메모리랑 실제 입출력 정보가 매번 달라질 수 있습니다.

바이너리 모드 파일 입출력은 항상 정해진 길이만큼 읽고 써야 합니다.

텍스트 모드의 EOF이라도 문제 없이 읽고 쓸 수 있습니다.

```c
size_t fread(void *buffer, size_t size, size_t count, FILE *stream);
```

```c
size_t fwrite(const void *buffer, size_t size, size_t count, FILE *stream);
```

문자열 저장하는 방법보다 메모리 낭비는 더 있지만 처리속도는 유리합니다.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct USERDATA {
  char szName[16];
  char szPhone[16];
} USERDATA;

int main(void) {
  FILE *fp = NULL;
  USERDATA UserData = {"Ho-sung", "123-1234"};

  fp = fopen("Test.dat", "wb");
  if (fp == NULL)
    return EXIT_FAILURE;

  fwrite(&UserData, sizeof(USERDATA), 1, fp);

  fclose(fp);

  return EXIT_SUCCESS;
}
```

바이너리는 vim에서 확인하기는 어렵습니다. 설정으로 확인하게 하는 방법은 있습니다. 

텍스트 파일접근 하듯이 바이너리 파일을 접근해서 메모장을 여는 것처럼 해동하면 잘 안보일 것입니다.

이번에는 바이너리 파일을 읽기 시도를 하겠습니다. 경로만 같으면 문제 없습니다.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct USERDATA {
  char szName[16];
  char szPhone[16];
} USERDATA;

int main(void) {
  FILE *fp = NULL;
  USERDATA UserData = {0};

  fp = fopen("Test.dat", "rb");
  if (fp == NULL)
    return EXIT_FAILURE;

  fread(&UserData, sizeof(USERDATA), 1, fp);
  puts(UserData.szName);
  puts(UserData.szPhone);
  fclose(fp);
  return EXIT_SUCCESS;
}
/*Ho-sung*/
/*123-1234*/
```

알아 둬야 할 점이 있습니다. `fread`함수는 반환값에 따라 실패를 알아낼 수 있습니다. 읽어들이는 정보의 길이가 구조체의 길이보다 작으면 `0`을 반환해서 실패를 알아낼 수 있습니다. 그렇다는 것은 `0`이 아닌 성공 중인 1인 동안 저장된 정보 모두를 load할 수 있습니다.

파일은 논리적으로 봤을 때, 마치 배열처럼 하나로 이어진 선형 메모리라고 할 수 있습니다. 그러나 배열과 다리 파일 길이가 늘어날 수 있습니다. 파일을 처음 생성했을 때는 길이가 `0`이지만 파일에 정보를 쓰면 그만큼 파일 길이는 자동으로 늘어납니다.

실제 파일 입출력이 완료된 위치를 저장하고 있는 포인터가 존재하는데 이것을 파일 입출력 포인터라고 합니다. 일반적으로 파일 포인터는 파일을 열었을 때 맨 앞에 있으며 입출력이 발생하는 길이만큼 증가합니다.

파일 길이는 쓰기가 발생하는 만큼 자동으로 증가시켜줍니다.

문제는 입출력이 발생하는 위치입니다. 엉뚱한 위치에 의도하지 않은 입출력을 할 여지가 많습니다. 이런 이유로 `fseek`, `ftell` 함수가 있습니다. 파일 입출력 포인터를 특정 위치로 강제 이동시킵니다. 바이너리 모드로 파일 입출력할 때 이 함수는 자주 사용합니다.

```c
int fseek(FILE *stream, long offset, int origin);
```

- `stream`은 구조체 포인터입니다. `offset`은 기준 위치에 대한 바이트 단위 오프셋입니다. `origin`은 기준 위치(`SEEK_SET`, `SEEK_CUR`, `SEEK_END`)입니다. 
- 성공하면 `0`, 실패하면 음수를 반환합니다. 
- 특정 위치로 파일 포인터(입출력 대상지점)를 이동합니다.

```c
int ftell(FILE *stream);
```

- `stream`은 구조체 포인터입니다.
- 성공하면 파일 포인터의 현재 위치(`0` 이상의 값)를 반환하며, 실패하면 `-1L`을 반환합니다.
- 입출력 대상이 되는 파일 포인터의 위치를 알아내는 함수이고, 이를 이용해서 파일의 크기를 계산할 수 있습니다.

다음 예제는 바이너리 파일을 읽기모드로 열어 파일의 바이트 단위 크기를 알아내고 출력하는 프로그램입니다. 파일을 열었을 때는 포인터는 `0`번에 위치합니다.  `fseek`를 이용하면 파일 입출력 포인터를 강제로 끝으로 이동할 수 있습니다  

`ftell`을 사용하면 현재 위치를 알아내고 파일의 크기를 알아낼 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  FILE *fp = NULL;
  fp = fopen("Test.dat", "rb");

  fseek(fp, 0, SEEK_END);

  printf("size of Test.dat : %lu\n", ftell(fp));
  fclose(fp);
  return EXIT_SUCCESS;
}
/*size of Test.dat : 32*/
```

이렇게 하면 파일의 크기를 알아 낼 수 있습니다. 지금 `0`을 대입한 상황에서는 포인터 그대로 보여줍니다. 오프셋으로 포인터 앞뒤로 갈 수 있습니다.

`rewind` 함수는 파일 포인터가 현재 어디에 있는 상관없이 맨 앞으로 강제 이동하는 함수입니다. 자주는 아니지만 같이 알아둘 필요 있습니다.

```c
void rewind(FILE * stream);
```

- `stream`은 구조체 포인터입니다.
- 반환 값은 없습니다.
- 파일 포인터를 맨 앞으로 이동시킵니다. `fseek(fp, 0, SEEK_SET)`과 결과가 같습니다.

이제는 알아두면 유용한 함수들입니다.

`feof`는 파일 포인터가 맨 끝에 있는지 확인하는 함수입니다. 자주 사용하는 편은 아닙니다. `_access`는 자주 사용합니다. 특정 파일이 존재하는지, 존자하면 읽기/쓰기 전용 모드인지 확인할 수 있습니다. 

파일 존재를 확인하고 싶으면 fopen 읽기모드로 사용할 수 있습니다. 하지만 실제로 파일이 존재하지만 쓰기 전용엔데 읽기모드로는 확인할 수 없습니다. 파일 접근 모드를 직접 조사해야 할 때 사용합니다. 

문제는 운영체제마다 다른 함수를 사용해야 합니다. 윈도우는 `_access`이고 리눅스는 `access`입니다. `_access`는 보안 문제가 있어서 `_access_s`를 대신 사용할 수 있습니다. 유니코드 버전 함수는 `_waccess`입니다.

```c
int feof(FILE *stream);
```

- `stream`은 구조체 포인터입니다.
- `0`을 반환하면 파일 포인터가 끝에 있는 것이 아닙니다. 그외는 파일 끝입니다.

```c
int _access(const char * path, int mode);
```

- `path`는 접근 검사를 할 파일이 저장된 경로가 저장된 메모리에 대한 포인터입니다. `mode`는 접근 검사 값입니다. `0`은 유무, `2`는 쓰기 전용인지 확인, `4`는 읽기 전용인지 확인, `6`은 읽기 쓰기 모두 가능한지 확인합니다.
- `0`을 반환하면 해당 접근을 허용합니다. `-1`을 반환하면 파일이 존재하지 않거나 접근할 수 없을 의미합니다.

1. 표준입력장치에서 문자열을 입력받은 후, 표준출력장치로 출력하는 프로그램을 작성하세요. 단 `fgets`, `fputs`를 무조건 사용해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUF_SIZE 512

int main(void) {
  FILE *fp = NULL;
  char szBuffer[MAX_BUF_SIZE] = {0};

  fp = fopen("Test.txt", "w");
  if (fp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }
  printf("이런저런 입력하세요: ");
  fgets(szBuffer, sizeof(szBuffer), stdin);
  fputs(szBuffer, fp);

  memset(szBuffer, 0, sizeof(szBuffer));
  fclose(fp);

  fp = fopen("Test.txt", "r");
  if (fp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }
  while (fgets(szBuffer, sizeof(szBuffer), fp)) {
    printf("%s", szBuffer);
    memset(szBuffer, 0, sizeof(szBuffer));
  }
  fclose(fp);
  return EXIT_SUCCESS;
}
/*이런저런 입력하세요: test string*/
/*test string*/
```

표준입출력에 파일입출력까지 활용했습니다.

2. 현재 경로에서 `TestFile.txt`를 연 후, 사용자가 입력한 문자열을 뒤에 이어서 추가한 뒤 다시 저장하는 프로그램을 작성하세요.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUF_SIZE 512

int main(void) {
  FILE *fp = NULL;
  char szStdioBuffer[MAX_BUF_SIZE] = {0};
  char szDiskBuffer[MAX_BUF_SIZE] = {0};
  char TARGET_FILE[16] = {"Test.txt"};

  fp = fopen(TARGET_FILE, "r");
  if (fp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }
  printf("저장 전 파일 내용입니다.\n");
  while (fgets(szDiskBuffer, sizeof(szDiskBuffer), fp)) {
    printf("%s", szDiskBuffer);
    memset(szDiskBuffer, 0, sizeof(szDiskBuffer));
  }
  fclose(fp);

  fp = fopen(TARGET_FILE, "a");
  if (fp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }
  printf("이런저런 입력하세요: ");
  fgets(szStdioBuffer, sizeof(szStdioBuffer), stdin);
  fputs(szStdioBuffer, fp);
  fclose(fp);

  fp = fopen(TARGET_FILE, "r");
  if (fp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }
  printf("저장 후 파일 내용입니다.\n");
  while (fgets(szDiskBuffer, sizeof(szDiskBuffer), fp)) {
    printf("%s", szDiskBuffer);
    memset(szDiskBuffer, 0, sizeof(szDiskBuffer));
  }
  fclose(fp);
  return EXIT_SUCCESS;
}
```

3. 현재 경로에서 `TestFile.txt`를 연 후, 원본 파일에서 행 단위로 문자열을 읽어 들여 대상 파일에 복사하는 프로그램을 작성하세요. 단, 대상 파일도 현재 경로에 생성하며, 파일명은 `DstFile.txt`입니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUF_SIZE 512

int main(void) {
  FILE *rp = NULL;
  FILE *wp = NULL;
  char szDiskBuffer[MAX_BUF_SIZE] = {0};
  char START_FILE[16] = {"Test.txt"};
  char TARGET_FILE[16] = {"DstFile.txt"};

  rp = fopen(START_FILE, "r");
  wp = fopen(TARGET_FILE, "w");
  if (rp == NULL || wp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }

  printf("복사할 파일의 내용입니다.\n");
  while (fgets(szDiskBuffer, sizeof(szDiskBuffer), rp)) {
    printf("%s", szDiskBuffer);
    fputs(szDiskBuffer, wp);
    memset(szDiskBuffer, 0, sizeof(szDiskBuffer));
  }

  fclose(rp);
  fclose(wp);

  printf("복사한 파일의 내용입니다.\n");
  rp = fopen(TARGET_FILE, "r");
  if (rp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }
  while (fgets(szDiskBuffer, sizeof(szDiskBuffer), rp)) {
    printf("%s", szDiskBuffer);
    memset(szDiskBuffer, 0, sizeof(szDiskBuffer));
  }
  fclose(rp);

  return EXIT_SUCCESS;
}
```

4. `main` 함수의 인자로 두 바이너리 파일의 경로를 입력받아 바이너리 모드로 열고, 원본 파일의 내용을 읽어들여 대상 파일로 복사하는 프로그램을 작성하세요. 단 복사의 진행 과정을 백분율로 화면에 출력하고 한 번에 `4KB` 단위로 복사합니다. 그리고 대상 파일이 존재 유무에 상관없이 무조건 생성하며, 파일의 크기가 최대 `100MB` 이상인 경우는 고려하지 않습니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* 4KB */
#define UNIT_SIZE 4096

/*
 * `main` 함수의 인자로 두 바이너리 파일의 경로를 입력받아 바이너리 모드로
 * 열고, 원본 파일의 내용을 읽어들여 대상 파일로 복사하는 프로그램을 작성하세요.
 * 단 복사의 진행 과정을 백분율로 화면에 출력하고 한 번에 `4KB` 단위로
 * 복사합니다. 그리고 대상 파일이 존재 유무에 상관없이 무조건 생성하며, 파일의
 * 크기가 최대 `100MB` 이상인 경우는 고려하지 않습니다.
 */
int main(int argc, char *argv[]) {
  FILE *rp = NULL, *wp = NULL;
  char buffer[UNIT_SIZE] = {0};
  size_t bytesRead, totalBytesRead = 0;
  /*int startAdd = 0, endAdd = 0;*/
  long fileSize;
  if (argc != 3) {
    printf("현재 %d개의 파일 주소를 입력했습니다. 2개의 파이너리 파일 주소를 "
           "입력해주세요.\n",
           argc);
    printf(argv[0], argv[1], argv[2]);
    return EXIT_FAILURE;
  }

  rp = fopen(argv[1], "rb");
  wp = fopen(argv[2], "wb");
  if (rp == NULL || wp == NULL) {
    printf("ERROR: Failed to open file!");
    return EXIT_FAILURE;
  }

  fseek(rp, 0, SEEK_END);
  fileSize = ftell(rp);
  fseek(rp, 0, SEEK_SET);

  // 파일 복사
  while ((bytesRead = fread(buffer, 1, UNIT_SIZE, rp)) > 0) {
    fwrite(buffer, 1, bytesRead, wp);
    totalBytesRead += bytesRead;
    printf("\r%.2f%%", (double)totalBytesRead / fileSize * 100);
  }
  /*while (fgets(szCopy, sizeof(szCopy), rp)) {*/
  /*printf("%.2f%%\n",*/
  /*(double)(((unsigned char *)&szCopy - rp->_p) / endAdd * 100));*/
  /*fputs(szCopy, wp);*/
  /*memset(szCopy, 0, sizeof(szCopy));*/
  /*}*/
  fclose(rp);
  fclose(wp);
  return EXIT_SUCCESS;
}
```

이 문제는 나중에 다시 풀어볼 문제입니다. 결국 도움받아 해결했습니다. 이미 언어 하나 다룰 줄 아는데 도움받으면 곤란합니다.

## 변수와 상수 고급 이론

변수의 본질은 메모리입니다. 상수의 본질은 메모리에 저장된 정보 그 자체를 의미합니다. 이번에는 고급 이론을 배웁니다. 문법적인 요소만 다루면 암기입니다. 최적화를 배우려면 시스템과 관련된 이론을 이해해야 합니다.

C 언어 초보자로 시작하려면 이번 장의 내용을 모두 밀도높게 알아야 합니다. 모든 이론을 정확히 알고 적절하게 활용할 수 있어야 합니다. 방어적인 프로그래밍 요소도 다룰 것입니다. 이것도 못하면 곤란합니다. 최소 중 최소한입니다.

우리가 작성한 코드를 기계어로 번역해주는 컴파일러의 특성에 대해서 어느정도는 알아야 합니다. 또 언젠가는 직접 기계어를 작성해야 합니다. 하지만 당장은 최소한 어떤식으로 번역되는지 잘 알아야 합니다.

### 형한정어

형한정어는 변수에 적용되는 문법으로서 컴파일러의 최적화와 매우 밀접하게 관련되어 있습니다. 우리가 배우고 있는 C 언어는 당연히 고급 언어입니다. 기계가 인식할 수 있게 기계어로 번역해서 실행할 수 밖에 없는데 의도에 맞게 번역했는지 어떻게 알 수 있는가? 이런 문제가 있습니다. 의도하지 않게 문제가 발생할 여지가 없는지 가능성이 있어도 문법으로 차단할 수 있어야 합니다.

#### `const`

형한정어 `const`는 변수를 상수로 바꿉니다. 변수를 더이상 변하지 않게 합니다. 쉽게 생각하면 메모리를 읽기 전용 메모리로 만들어 주는 기능입니다.

형한정어는 메모리를 보호하기 위한 것으로 생각할 수 있습니다. 하지만 선언 시점에만 사용할 수 있습니다. 변수를 계속 호출하는 지점에서는 불가능합니다.

변수를 선언 시점에 상수화 해야 하는 이유는 무엇인가? 이 고민이 필요합니다. 결론은 유지보수의 편의성입니다. 또 컴파일러가 줄어든 변수의 수만큼 번역도 유리하고 성능향상을 꾀하기 쉽습니다.

`const` 하나가 프로그램의 성능을 달라지게 만들고 실수할 여지도 줄여줍니다.

다음 예제릴 봅시다. 상당히 간단합니다. 70점 이상은 합격 아니면 불합격입니다. 나중에 변경될 가능성이 높습니다. 이 변경될 여지를 고려하고 코드를 작성해야 합니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;

  printf("점수를 입력하세요. : ");
  scanf("%d%*c", &nInput);

  if (nInput >= 70)
    printf("합격입니다.\n");
  else
    printf("불합격입니다.\n");

  return EXIT_SUCCESS;
}
/*점수를 입력하세요. : 80*/
/*합격입니다.*/
```

구현은 성공했습니다. 그리고 합격기준을 70이 아니라 만약에 75로 바꿨다면 어떻게 하겠는가? 지금은 예제가 단순해서 변경이 쉽습니다.

하지만 이런 프로그램을 10명 정도되는 엔지니어가 프로젝트를 진행하고 소스코드가 매우 길고 6개월 동안 작성했다면 실수할 여지가 상당히 많습니다.

나중에 70이 합격 조건인데 어떻게 찾아낼 것인가? 뭐 대부분 IDE는 검색 기능이 좋은데 일일이 읽고 변경해야 합니다. 일부 70은 이런 합격과 관련된 것이고 일부 70은 아닐 수 있습니다. 일괄변경을 시도해도 문제가 될 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nInput = 0;
  const int nCUTOFF = 70;

  printf("점수를 입력하세요. : ");
  scanf("%d%*c", &nInput);

  if (nInput >= nCUTOFF)
    printf("합격입니다.\n");
  else
    printf("불합격입니다.\n");

  return EXIT_SUCCESS;
}
```

`nCUTOFF`을 따로 선언하면 합격 기준을 변경해도 수정이 쉽습니다.

잦은 변경사항을 고객 탓하는 것만큼 실력없는 개발자는 없습니다. 하드코딩한 개발자가 잘못한 것입니다. 기술은 공부라는 자신만의 노력으로 얻을 수 없습니다. 사용자의 요구 분석 능력은 `현실경험`으로 완성됩니다.

지금 예시처럼 특정 숫자, 변수의 이름을 조합하면 좀더 의미가 명확해 보이는 상수를 표현할 수 있습니다. 이를 심볼릭 상수라고 합니다.

#### 상수형 포인터

C 언어는 고급어 중 최고의 성능을 내고 있습니다. 아마도 앞으로도 계속 내고 있을 가능성이 큽니다. 이 언어는 분명히 고급어가 맞습니다. 하지만 하드웨어 지식을 적극적으로 동원해야 합니다. C 언어를 아주 잘하는 사람은 기계어를 공부하면 크게 힘들어하지 않을 정도입니다. 이것이 기본기입니다.

문제는 C 언어로 장치 제어가 목적이 아니면 C 언어로 작성하는 것이 힘든 실력없는 개발자들이 많이 양산된 세상이 되었습니다. 그 원인 중 하나는 포인터입니다. C 언어의 포인터는 강력합니다. C 언어 저자는 과거로 돌아가면 "차라리 허용하지 않는 편이 더 나았을 것들까지 허용하는 문제"가 있다고 이야기 할 정도로 강력합니다. 물론 실력으로 극복하면 됩니다.

이 때문에 다른 언어들이 이 포인터를 아예 지원하지 않거나 안전한 사용방식만 허용하기도 합니다. 가끔은 제3 문법을 지원하고 이름도 바꿉니다. C++ 처럼 훌륭한 언어의 참조자가 해당합니다.

문제가 있다면 포인터를 난발하면 C 언어를 기계어로 번역할 때 효율적인 기계어 코드가 될 수 있도록 번역하기 어렵습니다. 또 동시성 프로그래밍의 성능저하도 당연히 발생시킵니다. 이런 골치아픈 문제는 당연히 실력 문제입니다. 일단 실력 없는 사람들을 위해 소개합니다. 포인터를 상수화하면 컴파일러를 도와줄 수 있습니다.

```c
#include <stdlib.h>

int main(void) {
  char szBuffer[32] = {"I am a boy."};
  const char *pszBuffer = szBuffer;

  szBuffer[0] = 'i';

  *pszBuffer = 'i';

  return EXIT_SUCCESS;
}
```

린트부터 에러를 던집니다.

`const`가 수식하는 대상은 `pszBuffer`가 아니라 포인터가 가리키는 대상입니다. 포인터로 간접지정 연산을 수행하면 포인터가 가리키는 대상을 변수화할 수 있습니다. 상수 포인터가 아니라 일반 포인터라면 메모리에 쓰기를 수행하도 문법적으로 문제가 없습니다. 상수 포인터는 허용하지 않습니다. 지금 린트에러가 발생하는 `pszBuffer`는 보면 알지만 쓰기 시도입니다.

함수 내부에서 상수 포인터 변수를 지역변수로 선언해서 사용할 일은 자주 없습니다. 그러나 코드가 2개의 함수로 분할된 상황을 생각하면 이야기는 달라집니다. 정의자는 함수가 주소를 매개변수로 받는 Call by reference로 정의자 함수의 연산으로 인해 호출자의 메모리가 변경될 가능성이 없도록 문법으로 강제할 노력이 필요 없습니다.

```c
#include <stdio.h>
#include <stdlib.h>

void PrintString(const char *pszParam) { puts(pszParam); }

int main(void) {
  char szBuffer[32] = {"I am a boy."};
  PrintString(szBuffer);
  PrintString("You are a girl.");

  return EXIT_SUCCESS;
}
/*I am a boy.*/
/*You are a girl.*/
```

이런 경우는 별로 없습니다. 

함수 내부에서 대상 메모리에 쓰기를 시도할 일이 없다면 이렇게 매개변수 선언부터 상수로 처리하는 것이 좋습니다. 

`const` 예약어는 안전장치입니다. 포인터를 안전하게 처리하도록 만들어서 프로그램의 안정성을 높이는 역할을 할 수 있습니다.

다음은 `const`가 수식하는 대상이 달라지는 경우입니다.

```c
#include <stdlib.h>

int main(void) {
  int nData = 10;

  const int *pnData = &nData;

  int *const pnNewData = &nData;

  // 아래 모두 에러
  *pnData = 20;
  pnNewData = NULL;

  return EXIT_SUCCESS;
}
```

포인터 변수가 가리키는 대상이 상수화됩니다. `pnData`는 포인터가 가리키는 대상을 상수화합니다. `pnNewData`를 정의하는 부분은 포인터 변수 그자체를 상수화합니다. 포인터가 가리키는 메모리는 수정할 수 있지만 포인터가 변해서 다른 대상을 가리킬 수 없는 상태가 됩니다.

포인터로 심각한 프로그램 오류를 만들 수 있는 방법은 여러 가지가 있습니다. 그중 가낭 흔한 사고는 포인터도 변수라는 사실을 잊어서 생기는 것들입니다.

#### 심볼릭 상수를 만드는 또 다른 방법

심볼릭 상수를 만드는 방법은 형한정어 `const` 이외 한 가지 방법 더 있습니다. `#define` 전처리기를 사용하는 것입니다. 

```c
#include <stdio.h>
#include <stdlib.h>

#define CUTOFF 70

int main(void) {
  int nInput = 0;
  printf("점수를 입력하세요. : ");
  scanf("%d%*c", &nInput);

  if (nInput >= CUTOFF)
    printf("합격입니다.\n");
  else
    printf("불합격입니다.\n");

  return EXIT_SUCCESS;
}
```

이렇게 작성하는 방법이 있습니다. 논리적으로 동일합니다. 하지만 CUTOFF 이름은 컴파일을 진행하기에 앞서 모두 70으로 바뀝니다. 컴파일러는 찾아 바꾸고 번역을 시작합니다. const를 사용하든 전처리기를 사용하든 코드 외형상 크게 달라지는 것은 없습니다. 전처리기를 사용하면 문법적으로 완전히 상수입니다.

다음은 더 일반적으로 작성하는 배열 크기 결정하는데 사용하는 방법입니다.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXLENGTH 32

int main(void) {
  char szName[MAXLENGTH] = {0};

  printf("이름을 입력하세요: ");
  fgets(szName, sizeof(char) * MAXLENGTH, stdin);
  return EXIT_SUCCESS;
}
```

이것도 같습니다. `MAXLENGTH`를 컴파일 전에 32로 바꿉니다.

주관적인 부분입니다. 배열을 선언할 때는 상수를 선언할지 리터럴 상수로 기술해도 무방할지 스스로 결정해야 합니다.

C99 표준과 다른 코드입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  const int nSize = 32;
  char szName[nSize] = {0};

  printf("이름을 입력하세요: ");
  fgets(szName, sizeof(szName), stdin);
  return EXIT_SUCCESS;
}
```

윈도우를 제외하면 gcc리로는 그냥 통과하는 코드입니다. 하지만 윈도우는 컴파일에러를 발생시킬 것입니다.

VLA(Variable Length Array)를 검색하고 조사하기 바랍니다.

#### `volatile`

변수와 관련된 모든 연산에 대해 컴파일러가 최적화 규칙을 적용하지 않습니다. 컴파일러의 판단이 필요하지 않음에도 불구하고 최적화 규칙을 적용하지 않습니다. 컴파일러 최적화에 도움을 주는 `const`와 정반대 역할을 합니다.

여기서 최적화를 하지 않는 수준은 CPU 기계 수준까지 적용됩니다. CPU는 빠른 처리를 위해 캐시 메모리도 사용합니다. `volatile`로 선언된 변수는 캐시처리할 수 없습니다. 효율이 떨어지지만 메모리에 정말 정보가 읽고 쓰는 행위는 보장받을 수 있습니다.

비효율적인 것을 알고 있지만 해야 하는 연산이 있을 수 있습니다. 그런데 컴파일러는 이런거 모릅니다. 필요없다고 판단하면 소스코드의 의미가 그대로 기계어로 번역되지 않을 수 있습니다. 이런 경우는 주로 임베디드 프로그래밍 환경입니다. 혹시 AVR을 제어하는 프로그램이나 운영체제 개발해야 한다면 이 형한정어 `volatile`에 대해 잘 알고 있어야 합니다.

다음은 반복문 100회 동안 `nData`에 10을 계속 할당하고 출력하는 프로그램입니다. 결과는 같아서 비효율적인 프로그램입니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int nData = 10, i = 0;

  for (i = 0; i < 100; ++i) {
    nData = 10;
  }
  printf("%d\n", nData);
  return EXIT_SUCCESS;
}
/*10*/
```

디버그 모드로 프로그램을 실행하면 디스어셈블리 화면을 볼 수 있습니다. 디버그 모드로 프로그램을 빌드했을 때 논리적으로 불필요한 부분이든 아니든 기계어로 번역합니다. 하지만 프로그램을 릴리즈모드로 번역하면 쓸데없는 코드를 판단하고 번역하지 않습니다.

프로그램을 다시 빌드하고 디버그하면 위치 중단점의 디스어셈빌리를 확인할 수 있습니다. 필요없는 부분이 생략된 것을 볼 수 있을 것입니다.

최적화는 두려움의 대상으로 여기는 실력없는 개발자들이 많습니다. 많은 C/C++ 개발자들이 자신의 PC에 개발할 때 문제가 없는데 프로그램을 완성하고 고객에게 전달하면 문제가 되는 현상을 경험할 수 있습니다. 디버그 모드에서는 문제가 없는데 릴리즈에서는 문제가 될 수 있습니다. 상상하지 못한 버그가 있을 수 있거나 기술적으로 설명할 수 없는 결과는 가끔 발생합니다. 이런 원인은 실력없는 사람들이 최적화 시도를 실력없이 하기 때문입니다. 

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  volatile int nData = 10;
  int i = 0;
  for (i = 0; i < 100; ++i) {
    nData = 10;
  }
  printf("%d\n", nData);
  return EXIT_SUCCESS;
}
```

이렇게 되면 최적화 규칙을 적용하지 않아서 직접 확인이 가능해집니다. 릴리즈모드에서 무슨일이 일어나는지 관측할 때 활용해볼 수 있습니다.

### `extern` 외부변수 선언

함수를 작성할 때 원형 선언과 정의를 분리할 수 있습니다. 변수도 외부 변수 선언과 정의로 구분할 수 있습니다. 함수는 선언만 있고 정의가 누락되면 컴파일러가 링크 오류를 던집니다. 외부변수 선언도 비슷합니다.

이번 예제는 2개의 파일이 필요합니다.

```c
#include "Test.c"
#include <stdio.h>
#include <stdlib.h>

void InitCounter(int nData);
void IncreaseCounter();

extern int g_nCouter;

int main(void) {
  InitCounter(10);
  printf("%d\n", g_nCouter);
  IncreaseCounter();
  printf("%d\n", g_nCouter);

  return EXIT_SUCCESS;
}
```

여기까지 작성하고 컴파일 시도하는 정신나간 사람은 없기 바랍니다.

```c title="Test.c"
int g_nCounter = 0;

void InitCounter(int nData) { g_nCounter = nData; }

void IncreaseCounter(void) { g_nCounter++; }
```

이제 컴파일 시도하고 실행하면 정상동작할 것입니다. `Test.c`는 `main`함수가 없습니다. 한 프로젝트 내부에 여러 파일이 존재할 때는 한 파일에만 `main`이 존재해야 합니다. 외부변수 선언은 일반 변수 선언과 같은 형식으로 기술합니다. `extern` 예약어 붙이면 됩니다. 주의할 점은 절대 초깃값을 호출하는 곳에서 붙이면 안됩니다. 선언 및 정의가 됩니다. 

`extern`은 문법상 기억분류 지정자입니다. 

선언과 정의하는 파일을 분리한 것입니다. 

obj 파일이 만들어지는데 컴파일 과정에서 선언만 있어도 문제가 없는 것을 알아야 합니다. 정의는 다른 곳에 있다고 가정하고 넘어가기 때문입니다. 링크 타임에는 둘이 하나로 합치는데 원형 선언과 외부변수로 선언된 것이 실체가 어느 obj에 있는지 짝을 맞춥니다.

결국 외부변수라는 말의 의미는 변수의 정의가 현재 파일이 아니라 다른 파일에 존재한다는 의미입니다. 

컴파일은 넘기고 링크 과정에서 다른 외부 obj 파일에서 실체를 찾는 점이 중요합니다. 만약에 못찾으면 링크 오류가 발생합니다.

### 형 재선언

형 재선언은 `typedef` 예약어로 새로운 자료형을 선언하는 문법입니다. 만약에 새로운 자료형을 선언 했다면 그 자료형은 사용자 정의 타입입니다. 

형 재선언, 사용자 정의 선언, 형 재정의 등 불리는게 많습니다. 형 재선언이 맞는 표현합니다.

```c
#include <stdio.h>
#include <stdlib.h>

typedef unsigned int UINT;

int main(void) {
  UINT uData = 10;
  printf("%u\n", uData);

  return EXIT_SUCCESS;
}
/*10*/
```

주의할 점은 형 재선언은 `#define`과 다르게 끝에 세미 콜론(`;`)을 붙여야 합니다. 물론 `#define`을 이용해 동일한 효과를 얻을 수 있습니다. 

```c
#include <stdio.h>
#include <stdlib.h>

typedef const char *LPSTR;

int main(void) {
  LPSTR pszData = NULL;
  pszData = "HelloWorld";
  printf("%s\n", pszData);

  return EXIT_SUCCESS;
}
/*HelloWorld*/
```

형 재선언의 문제가 있습니다. 어떻게 변수명만으로 포인터인지 알려줄 것인가? 실수할 여지가 많아집니다. 

형 재선언을 남발하면 분석하기 힘든 코드가 될 수 있습니다.

Wind32 API는 형 재선언이 너무 많아 이해하기 어렵다고 평가받습니다. 물론 실력 문제입니다. 이정도는 쉽게 파악할 능력이 되어야 합니다.

### 열거형 상수

여러 개의 심볼릭 상수를 한꺼번에 정의하고 구조체처럼 새로운 정의 자료형으로 활용하는 것이 가능합니다.

열거형 상수는 장점이 있습니다. 코드 가독성을 높이는데 활용하기 좋습니다. 

참고로 `enum` 예약어를 사용합니다.

```c
#include <stdio.h>
#include <stdlib.h>

enum ACTION { MOVE, JUMP, ATTACK };

typedef enum COLOR { RED = 100, GREEN, BLUE } COLOR;

int main(void) {
  enum ACTION act = MOVE;
  COLOR color = GREEN;

  printf("ACTION: %d, COLOR: %d\n", act, color);

  return EXIT_SUCCESS;
}
/*ACTION: 0, COLOR: 101*/
```

의미를 파악하고 활용하게 만들기 쉽습니다. switch-case 문에서 특히 이해하기 쉽습니다.

불필요한 자료형이 생성되어 문제라고 생각할 수 있습니다. 실제로 이런 경우는 있습니다. 하지만 그런 경우가 아니라면 가독성을 높이기 유용한 문법입니다.

본인이 만들어 놓은 코드라고 해도 1 ~ 2 개월 지나면 혼란스럽습니다. 다른 사람 코드는 더합니다. 가독성을 위해 엄청난 노력을 많이 해야 합니다.

1. `const int pnData`와 `int * const pnData`라는 선언은 모두 `int` 타입에 대한 포인터 변수 선언입니다. 그러나 `const` 형 한정어의 적용 대상이 다릅니다. 구체적으로 무엇이 어떻게 다른지 설명하세요.

전자는 포인터가 가리키는 대상 상수화 합니다. 처음 할당한 변수 값이후 변경이 불가능합니다.

후자는 포인터 변수 자체를 상수로 취급합니다. 포인터가 보고 있는 대상의 주소가 상수가 됩니다. 포인터가 보고 있는 주소 안에 있는 값을 수정해도 됩니다. 

2. 심볼릭 상수를 정의할 수 있는 2가 방법이 무엇인지 답하시오.

읽기 전용 변수가 될 `const`를 통한 선언과 컴파일 타임에 적용될 `#define`입니다.

3. 외부 변수를 선언하기 위해 예약어는 무엇인지 답하세요.

`extern`입니다.

4. 게임을 개발하면서 최상위, 바닥, 왼쪽, 오른쪽에 해당하는 정보를 열거형 상수로 정의하려고 합니다. 만일 열거형 상수의 이름이 `MYMOVE`이라고 할 때 `TOP`, `BOTTOM`, `LEFT`, `RIGHT`를 선언하려고 합니다. 어떻게 해야 하는지 코드를 직접 보여주세요.

```c
enum MYENUM { TOP, BOTTOM, LEFT, RIGHT };
```
